/*
Project: Q Compiler and Interpreter
Info header for C distribution.

Typical Build Instructions:

  gcc -m64 -O3 pc_win64.c -opc.exe         # Windows
  gcc -m64 -O3 pc_lin64.c -opc -lm -ldl    # Linux

Actual program name varies according to target OS and target word size.
The -m64 or -m32 flag should match that in the file name, or it can be
omitted when gcc defaults to the right value.

This program is an interpreter for the Q language.

It runs precompiled bytecode programs, or it can also compile Q source
programs into single-file .pc bytecode files.

Run as follows:


  pc hello.q      # Compile hello.q to hello.pc then run hello.pc

  pc hello.pc     # Run hello.pc (created from prior compilations)

  pc hello        # Run hello.pc if present else hello.q
                  # Unless hello.q is newer then always compile/run that
                  # (Requires Windows target to compare file times)

Test hello.q file:

  proc start =
    println "Hello, World!"
  end

*/

/*
  M to C Whole Program Translator
  Input:  pc.m plus imported modules
  Output: \c\qq_nos64.c (this file, or renamed from that)
          File represents entire program
  Target: C64
  OS:     No OS

  Modules:
  Module 1: pc.m
  Module 2: c:/mx/msysc.m
  Module 3: c:/mx/clib.m
  Module 4: c:/mx/mlib.m
  Module 5: c:/mx/osnos.m
  Module 6: pc_types.m
  Module 7: pc_decls.m
  Module 8: pq_common.m
  Module 9: pc_support.m
  Module 10: pc_misc.m
  Module 11: pc_pcfns.m
  Module 12: pc_objects.m
  Module 13: pc_bigint.m
  Module 14: pc_print.m
  Module 15: pc_jhandlers.m
  Module 16: pc_oslayer.m
  Module 17: c:/mx/osnosdll.m
  Module 18: pc_host.m
  Module 19: pc_dxfns.m
  Module 20: pc_khandlers.m
  Module 21: pc_assem_c.m
  Module 22: qc.m
  Module 23: var_types.m
  Module 24: var_decls.m
  Module 25: qc_tables.m
  Module 26: qc_support.m
  Module 27: qc_lex.m
  Module 28: qc_parse.m
  Module 29: qc_lib.m
  Module 30: qc_parselib.m
  Module 31: qc_pclgen.m
  Module 32: qc_pcllib.m
  Module 33: q_libs.m

*********** Start of C Code **********/


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>

#pragma pack(1)

typedef int8_t int8;
typedef int16_t int16;
typedef int32_t int32;
typedef int64_t int64;

typedef uint8_t uint8;
typedef uint16_t uint16;
typedef uint32_t uint32;
typedef uint64_t uint64;

typedef unsigned char byte;

#ifndef CALLBACK
#define CALLBACK
#endif

/* Forward Struct Declarations */
struct mlib_strbuffer;
struct osnos_rsystemtime;
struct osnos_os_getdllprocaddr_rec;
struct pc_decls_uflagsrec;
struct pc_decls_fieldrec;
struct pc_decls_strec;
struct pc_decls_objrec;
struct pc_decls_varrec;
struct pc_decls_genfieldnamerec;
struct pc_decls_genfielddatarec;
struct pc_decls_modulerec;
struct pc_decls_dllprocrec;
struct pc_decls_procrec;
struct pc_decls_fmtrec;
struct pc_host_dimrec;
struct pc_host_overloadrec;
struct pc_host_pch_setoverload_rec;
struct var_decls_attribrec;
struct var_decls_uflagsrec;
struct var_decls_fieldrec;
struct var_decls_strec;
struct var_decls_unitrec;
struct var_decls_genfieldnamerec;
struct var_decls_genfielddatarec;
struct var_decls_modulerec;
struct var_decls_dllprocrec;
struct var_decls_procrec;
struct qc_lex_lexrec;
struct pc_getinputfile_switchrec;

/* Struct Definitions */
struct mlib_strbuffer {
    byte *  strptr;
    int32 length;
    int32 allocated;
};

struct osnos_rsystemtime {
    int64 year;
    int64 month;
    int64 dayofweek;
    int64 day;
    int64 hour;
    int64 minute;
    int64 second;
    int64 milliseconds;
};

struct osnos_os_getdllprocaddr_rec {
    byte *  name;
    void *  addr;
};

struct pc_decls_uflagsrec {
    byte codes[7];
    byte ulength;
};

struct pc_decls_fieldrec {
    byte *  name;
    int16 recordtype;
    int16 fieldtype;
    int32 fieldoffset;
};

struct pc_decls_strec {
    byte *  name;
    struct pc_decls_strec* owner;
    struct pc_decls_strec* deflist;
    struct pc_decls_strec* nextdef;
    byte *  metadata;
    byte symbol;
    byte nameid;
    int16 subcode;
    int16 mode;
    byte ax_at;
    byte ax_moduleno;
    int32 index;
    union {
        void *  address;
        int32 offset;
        uint64 *  pcaddress;
    };
};

struct pc_decls_objrec {
    union {
        struct {
            uint32 refcount;
            uint16 elemtag;
            union {
                byte mutable;
                byte bitoffset;
            };
            byte objtype;
        };
        uint64 refcountx;
    };
    union {
        byte *  ptr;
        struct pc_decls_varrec *  vptr;
        byte *  strptr;
        int32 (*bnptr)[];
    };
    union {
        struct {
            union {
                struct {
                    uint32 length;
                    int32 lower;
                };
            };
            union {
                struct pc_decls_objrec* objptr2;
                struct {
                    uint32 allocated;
                    uint32 dictitems;
                };
                uint64 allocated64;
            };
        };
        byte data128[16];
    };
};

struct pc_decls_varrec {
    union {
        struct {
            uint16 tag;
            byte hasref;
            union {
                byte stackadj;
                byte opdims;
                byte ittype;
            };
        };
        uint32 tagx;
    };
    union {
        struct {
            uint16 refelemtag;
            byte refbitoffset;
            byte spare2;
        };
        struct {
            int16 frameoffset;
            byte exceptiontype;
            byte nexceptions;
        };
        int32 frameptr_low;
        int32 itcount;
        uint32 bndigits;
    };
    union {
        struct pc_decls_objrec *  objptr;
        struct pc_decls_varrec* varptr;
        byte *  packptr;
        byte *  refptr;
        int64 *  dptr;
        int64 value;
        uint64 uvalue;
        double xvalue;
        uint64 *  retaddr;
        struct {
            int32 range_lower;
            int32 range_upper;
        };
    };
};

struct pc_decls_genfieldnamerec {
    byte *  name;
    int32 dataindex;
    union {
        int32 datalength;
        int32 datalast;
    };
};

struct pc_decls_genfielddatarec {
    int32 fieldindex;
    int32 recordtype;
    int32 fieldtype;
    union {
        int32 offset;
        uint32 index;
        uint32 procoffset;
    };
};

struct pc_decls_modulerec {
    byte *  name;
    byte *  filename;
    byte *  sourcecode;
    uint64 (*pccode)[];
    uint16 (*linetable)[];
    int32 sourcelen;
    int32 npccode;
    int32 pcindex;
    int32 level;
    int32 exported;
    byte importmap[50];
};

struct pc_decls_dllprocrec {
    byte *  name;
    void (*address)(void);
    int32 dllindex;
};

struct pc_decls_procrec {
    struct pc_decls_strec *  def;
    struct pc_decls_procrec* nextproc;
};

struct pc_decls_fmtrec {
    byte minwidth;
    int8 precision;
    byte base;
    byte quotechar;
    byte padchar;
    byte realfmt;
    byte plus;
    byte sepchar;
    byte lettercase;
    byte justify;
    byte suffix;
    byte usigned;
    byte charmode;
    byte showtypex;
    byte spare[2];
};

struct pc_host_dimrec {
    int64 lbound;
    int64 upper;
    int64 length;
};

struct pc_host_overloadrec {
    int64 optype;
    int64 optype2;
    uint64 *  pchandler;
    struct pc_host_overloadrec* nextrec;
};

struct pc_host_pch_setoverload_rec {
    int64 cmd;
    void *  tableptr;
    void *  handleptr;
    struct pc_host_overloadrec * *  ovlist;
};

struct var_decls_attribrec {
    byte ax_global;
    byte ax_static;
    byte ax_equals;
    byte ax_at;
    byte ax_byrefmode;
    byte ax_optional;
    byte ax_varparams;
    byte ax_used;
    byte ax_forward;
    byte ax_frame;
    byte ax_autovar;
    byte ax_nparams;
    byte ax_fflang;
    byte ax_moduleno;
    byte ax_baseclass;
    union {
        byte ax_align;
        byte ax_dllindex;
        byte ax_extmodno;
    };
};

struct var_decls_uflagsrec {
    byte codes[7];
    byte ulength;
};

struct var_decls_fieldrec {
    byte *  name;
    int16 recordtype;
    int16 fieldtype;
    int64 fieldoffset;
};

struct var_decls_strec {
    byte *  name;
    struct var_decls_strec* owner;
    struct var_decls_strec* deflist;
    struct var_decls_strec* nextdef;
    struct var_decls_strec* nextdupl;
    struct var_decls_strec* prevdupl;
    union {
        struct var_decls_strec* nextparam;
        struct var_decls_unitrec *  callchain;
    };
    struct var_decls_unitrec *  code;
    union {
        struct var_decls_strec* paramlist;
        struct var_decls_uflagsrec uflags;
    };
    union {
        struct var_decls_strec* equiv;
        byte *  docstring;
    };
    union {
        byte *  truename;
        byte *  metadata;
        byte *  macrovalue;
    };
    byte namelen;
    byte symbol;
    byte nameid;
    byte sparebyte;
    int16 subcode;
    int16 mode;
    int32 index;
    union {
        void *  address;
        int32 offset;
        int64 *  pcaddress;
        int32 base_class;
        int32 bcindex;
    };
    int32 lineno;
    struct var_decls_attribrec attribs;
};

struct var_decls_unitrec {
    int32 tag;
    int32 lineno;
    struct var_decls_unitrec* a;
    struct var_decls_unitrec* b;
    struct var_decls_unitrec* c;
    struct var_decls_unitrec* nextunit;
    union {
        struct var_decls_strec *  def;
        int64 value;
        uint64 uvalue;
        double xvalue;
        byte *  svalue;
        struct var_decls_strec *  labeldef;
        struct {
            int32 range_lower;
            int32 range_upper;
        };
    };
    union {
        int32 opcode;
        int32 index;
        int32 trylevel;
        int32 slength;
        byte dottedname;
    };
    int32 valuemode;
};

struct var_decls_genfieldnamerec {
    union {
        struct var_decls_strec *  def;
        byte *  name;
    };
    int32 dataindex;
    union {
        int32 datalength;
        int32 datalast;
    };
};

struct var_decls_genfielddatarec {
    int32 fieldindex;
    int32 recordtype;
    int32 fieldtype;
    union {
        int32 offset;
        uint32 index;
        uint32 procoffset;
    };
};

struct var_decls_modulerec {
    byte *  name;
    byte *  filename;
    byte *  sourcecode;
    struct var_decls_strec *  stmodule;
    int64 (*pccode)[];
    uint16 (*linetable)[];
    int32 sourcelen;
    int32 npccode;
    int32 pcindex;
    int32 level;
    int32 exported;
    byte importmap[50];
};

struct var_decls_dllprocrec {
    byte *  name;
    void (*address)(void);
    int32 dllindex;
};

struct var_decls_procrec {
    struct var_decls_strec *  def;
    struct var_decls_procrec* nextproc;
};

struct qc_lex_lexrec {
    union {
        int64 value;
        double xvalue;
        uint64 uvalue;
        byte *  svalue;
        struct var_decls_strec *  symptr;
    };
    int64 symbol;
    int64 subcode;
    int64 length;
    int64 lineno;
    int64 fileno;
    int64 hashvalue;
};

struct pc_getinputfile_switchrec {
    byte *  switchname;
    int64 *  switchaddr;
};


/* PROCDECLS */
void start(void);
static void pc_initlogfile(void);
static void pc_closelogfile(void);
static void pc_initdata(void);
static byte * pc_getinputfile(int64 * filetype);
static void pc_showpcl(byte * caption,int64 n,int64 phase);
static void pc_showgenfields(void);
static void pc_do_showprogdiags_pc(byte * caption);
int64 pc_runcode(int64 frompc);
static void pc_initbytecode(int64 frompc);
static void pc_disploop(void);
static void pc_pclinit(void);
static void pc_fixup_all_pc(void);
static void pc_fixup_module_pc(int64 mx);
static int64 * pc_disploop_fn(int64 n);
static void pc_disploop_deb(void);
static void pc_getsyscmdline(void);
static void pc_showmodules(void);
static void pc_starttiming(void);
static void pc_showtiming(void);
void pc_runproc(void * fnptr,struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * dest);
static void pc_showinttiming(byte * caption);
static void pc_allocatestrings(void);
static int64 pc_loadprogram(byte * filespec,int64 * filetype);
static int64 pc_loadpcfile(byte * filespec);
void pc_initpcldata(void);
static struct pc_decls_strec * pc_createstentry(int64 index,byte * name,int64 owner,int64 id);
static void pc_findnewestfile(byte * * lastfilename,int64 * lastfiletime,int64 * lastfiletype,byte * filename,byte * fileext,int64 filetype);
static void pc_showcaption(void);
static uint64 * pc_getprocaddr(int64 n);
static int32 pc_getfileint(byte * data,int64 offset);
static int64 pc_checkpackfile(void);
void pc_pcl_initusertypes(void);
int64 msysc_m_getdotindex(uint64 a,int64 i);
void msysc_m_setdotindex(uint64 * a,int64 i,int64 x);
int64 msysc_m_getdotslice(uint64 a,int64 i,int64 j);
void msysc_m_setdotslice(uint64 * a,int64 i,int64 j,uint64 x);
int64 msysc_m_getnprocs(void);
void * msysc_m_getprocaddr(int64 n);
byte * msysc_m_getprocname(int64 n);
int64 msysc_m_imin(int64 a,int64 b);
int64 msysc_m_imax(int64 a,int64 b);
extern int32 __getmainargs(int32 * _1,void * _2,void * _3,int64 _4,void * _5);
void * mlib_pcm_alloc(int64 n);
void mlib_pcm_free(void * p,int64 n);
void mlib_pcm_freeac(void * p,int64 alloc);
void mlib_pcm_copymem4(void * p,void * q,int64 n);
void mlib_pcm_clearmem(void * p,int64 n);
void mlib_pcm_init(void);
int64 mlib_pcm_getac(int64 size);
void * mlib_pcm_newblock(int64 itemsize);
int64 mlib_pcm_round(int64 n);
int64 mlib_pcm_array(int64 n);
void mlib_pcm_printfreelist(int64 size,uint64 * p);
void mlib_pcm_diags(byte * caption);
void * mlib_pcm_allocz(int64 n);
byte * mlib_pcm_copyheapstring(byte * s);
static void mlib_addtomemalloc(int32 * ptr,int64 size);
static void mlib_removefrommemalloc(int32 * ptr,int64 size);
void * mlib_allocmem(int64 n);
void * mlib_reallocmem(void * p,int64 n);
void mlib_abortprogram(byte * s);
int64 mlib_getfilesize(void * handlex);
void mlib_readrandom(void * handlex,byte * mem,int64 offset,int64 size);
int64 mlib_writerandom(void * handlex,byte * mem,int64 offset,int64 size);
byte * mlib_readfile(byte * filename);
int64 mlib_writefile(byte * filename,byte * data,int64 size);
int64 mlib_checkfile(byte * file);
void mlib_readlinen(void * handlex,byte * buffer,int64 size);
void mlib_iconvlcn(byte * s,int64 n);
void mlib_iconvucn(byte * s,int64 n);
void mlib_convlcstring(byte * s);
void mlib_convucstring(byte * s);
byte * mlib_changeext(byte * s,byte * newext);
byte * mlib_extractext(byte * s,int64 period);
byte * mlib_extractpath(byte * s);
byte * mlib_extractfile(byte * s);
byte * mlib_extractbasefile(byte * s);
byte * mlib_addext(byte * s,byte * newext);
void * mlib_alloctable(int64 n,int64 size);
void * mlib_zalloctable(int64 n,int64 size);
void mlib_checkfreelists(byte * s);
void * mlib_pcm_alloc32(void);
void mlib_pcm_free32(void * p);
void mlib_outbyte(void * f,int64 x);
void mlib_outword16(void * f,uint64 x);
void mlib_outword(void * f,uint64 x);
void mlib_outword64(void * f,uint64 x);
int64 mlib_myeof(void * f);
void * mlib_pcm_smallallocz(int64 n);
void * mlib_pcm_smallalloc(int64 n);
void mlib_strbuffer_add(struct mlib_strbuffer * dest,byte * s,int64 n);
void mlib_gs_init(struct mlib_strbuffer * dest);
void mlib_gs_free(struct mlib_strbuffer * dest);
void mlib_gs_str(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_char(struct mlib_strbuffer * dest,byte c);
void mlib_gs_strn(struct mlib_strbuffer * dest,byte * s,int64 length);
void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s);
void mlib_gs_strint(struct mlib_strbuffer * dest,int64 a);
void mlib_gs_strln(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_strsp(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_line(struct mlib_strbuffer * dest);
int64 mlib_gs_getcol(struct mlib_strbuffer * dest);
void mlib_gs_leftstr(struct mlib_strbuffer * dest,byte * s,int64 w,int64 padch);
void mlib_gs_leftint(struct mlib_strbuffer * dest,int64 a,int64 w,int64 padch);
void mlib_gs_padto(struct mlib_strbuffer * dest,int64 col,int64 ch);
void mlib_gs_println(struct mlib_strbuffer * dest,void * f);
int64 mlib_nextcmdparam(int64 * paramno,byte * * name,byte * * value,byte * defext);
static int64 mlib_readnextfileitem(byte * * fileptr,byte * * item);
void mlib_ipadstr(byte * s,int64 width,byte * padchar);
byte * mlib_padstr(byte * s,int64 width,byte * padchar);
byte * mlib_chr(int64 c);
int64 mlib_cmpstring(byte * s,byte * t);
int64 mlib_cmpstringn(byte * s,byte * t,int64 n);
int64 mlib_eqstring(byte * s,byte * t);
int64 mlib_cmpbytes(byte * p,byte * q,int64 n);
int64 mlib_eqbytes(byte * p,byte * q,int64 n);
void osnos_os_init(void);
int64 osnos_os_execwait(byte * cmdline,int64 newconsole,byte * workdir);
int64 osnos_os_execcmd(byte * cmdline,int64 newconsole);
int64 osnos_os_getch(void);
int64 osnos_os_kbhit(void);
void osnos_os_flushkeys(void);
void * osnos_os_getconsolein(void);
void * osnos_os_getconsoleout(void);
void * osnos_os_proginstance(void);
uint64 osnos_os_getdllinst(byte * name);
void (*osnos_os_getdllprocaddr(int64 hinst,byte * name))(void);
void osnos_os_initwindows(void);
int64 osnos_os_getchx(void);
byte * osnos_os_getos(void);
int64 osnos_os_getoscode(void);
int64 osnos_os_iswindows(void);
int64 osnos_os_shellexec(byte * opc,byte * file);
void osnos_os_sleep(int64 a);
void * osnos_os_getstdin(void);
void * osnos_os_getstdout(void);
byte * osnos_os_gethostname(void);
int64 osnos_os_gethostsize(void);
byte * osnos_os_getmpath(void);
void osnos_os_exitprocess(int64 x);
int64 osnos_os_gettimestamp(void);
int64 osnos_os_gettickcount(void);
int64 osnos_os_clock(void);
int64 osnos_os_getclockspersec(void);
void osnos_os_setmesshandler(void * addr);
int64 osnos_os_filelastwritetime(byte * filename);
int64 osnos_os_hpcounter(void);
int64 osnos_os_hpfrequency(void);
void osnos_os_getsystime(void * tm);
void osnos_os_peek(void);
void pc_support_prterror(byte * mess);
int64 pc_support_testelem(byte (*p)[],int64 n);
void pc_support_setelem(byte (*p)[],int64 n);
void pc_support_pcustype_def(byte * mess,struct pc_decls_varrec * x);
uint64 * pc_support_pcustype(byte * mess,struct pc_decls_varrec * x);
uint64 * pc_support_pcustypet(byte * mess,int64 t);
void pc_support_pcmxtypes_def(byte * mess,struct pc_decls_varrec * x,struct pc_decls_varrec * y);
uint64 * pc_support_pcmxtypes(byte * mess,struct pc_decls_varrec * x,struct pc_decls_varrec * y);
uint64 * pc_support_pcmxtypestt(byte * mess,int64 s,int64 t);
byte * pc_support_gettypename(int64 t);
void pc_support_inittypetables(void);
uint64 * pc_support_pcerror(byte * mess);
void pc_support_vxunimpl(byte * mess);
void pc_support_pclunimpl(int64 cmd);
byte * pc_support_convcstring(byte * svalue,int64 length);
int64 pc_support_getintvalue(struct pc_decls_varrec * p);
int64 pc_support_nextpoweroftwo(int64 x);
static void pc_support_showlinenumber(void);
static void pc_support_printlinenumber(int64 lineno,int64 moduleno,byte * calledfrom);
void pc_support_findlinenumber(uint64 * ptr,int64 * lineno,int64 * moduleno);
int64 pc_support_findpcindex(uint64 * ptr,int64 * moduleno);
void pc_support_showlinetable(byte * caption,int64 i);
void pc_support_writezstring(void * f,byte * s);
void pc_support_writezint(void * f,int64 x);
void pc_support_writezint4(void * f,int64 x);
void pc_support_writezrange(void * f,byte * p);
void pc_support_writezreal(void * f,double x);
void pc_support_writezeof(void * f);
static void pc_support_zerror(byte * mess);
int64 pc_support_readzvalue(byte * * pp,int32 * dest,int32 * dest2);
int64 pc_support_readzint(byte * * p);
int64 pc_support_readzdint(byte * * p);
double pc_support_readzreal(byte * * p);
byte * pc_support_readzstring(byte * * p,int64 * ilength);
byte * pc_support_readzblock(byte * * pp,int64 length);
void pc_support_checkmt(int64 id);
int64 pc_support_ipower(int64 a,int64 n);
void pc_support_loaderror(byte * mess,byte * mess2);
int64 pc_support_gettypesig(int64 s,int64 t);
byte * pc_support_getfnname(void * fnaddr);
void pc_support_junimpl(byte * s);
uint64 * pc_misc_raiseexception(int64 exceptno);
void pc_misc_raise_error(int64 error_no);
static void pc_misc_default_exception(int64 exceptno);
void pc_pcfns_pc_ufree(struct pc_decls_varrec * p);
void pc_pcfns_pc_cfree(struct pc_decls_varrec * p);
void pc_pcfns_pc_ufreex(struct pc_decls_varrec * p);
void pc_pcfns_pc_freeref(struct pc_decls_objrec * p,int64 tag);
void pc_pcfns_pc_cshare(struct pc_decls_varrec * p);
void pc_pcfns_pc_ushare(struct pc_decls_varrec * p);
void pc_pcfns_pc_dupl(struct pc_decls_varrec * p);
void pc_pcfns_j_free_s(struct pc_decls_varrec * p);
void pc_pcfns_j_free_l_m_d(struct pc_decls_varrec * p);
void pc_pcfns_j_free_k(struct pc_decls_varrec * p);
void pc_pcfns_j_free_a_j(struct pc_decls_varrec * p);
void pc_pcfns_j_free_b_e(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_s(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_l_m_d(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_a_j(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_b(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_e(struct pc_decls_varrec * p);
void pc_pcfns_j_dupl_k(struct pc_decls_varrec * p);
void pc_pcfns_pc_makelist(int64 n,struct pc_decls_varrec * a,struct pc_decls_varrec * b,int64 lower);
void pc_pcfns_pc_makerecord(int64 n,int64 t,struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_makearray(int64 n,int64 arraytype,int64 elemtype,int64 lower,struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_makerange(struct pc_decls_varrec * x,struct pc_decls_varrec * y,struct pc_decls_varrec * z);
void pc_pcfns_pc_makeset(int64 n,struct pc_decls_varrec * data,struct pc_decls_varrec * dest);
void pc_pcfns_pc_makestruct(int64 n,int64 t,struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_makedict(int64 n,struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_storepacked(byte * p,struct pc_decls_varrec * q,int64 t);
static void pc_pcfns_adddictitem(struct pc_decls_varrec * d,struct pc_decls_varrec * p,struct pc_decls_varrec * q);
struct pc_decls_varrec * pc_pcfns_finddictitem(struct pc_decls_objrec * d,struct pc_decls_varrec * p,int64 doins);
static void pc_pcfns_expanddict(struct pc_decls_objrec * d);
static void pc_pcfns_setfslength(byte * s,int64 m,int64 n);
int64 pc_pcfns_getfslength(byte * s,int64 m);
int64 pc_pcfns_gethashvalue(struct pc_decls_varrec * p);
void pc_pcfns_pc_storeptr(struct pc_decls_varrec * p,struct pc_decls_varrec * q);
void pc_pcfns_pc_storebit(byte * p,int64 shift,struct pc_decls_varrec * q,int64 t);
void pc_pcfns_pc_popptrlist(struct pc_decls_varrec * p,struct pc_decls_varrec * q);
void pc_pcfns_pc_loadpacked(void * p,int64 t,struct pc_decls_varrec * dest,struct pc_decls_objrec * ownerobj);
void pc_pcfns_pc_loadbit(byte * p,int64 shift,int64 t,struct pc_decls_varrec * dest);
void pc_pcfns_pc_loadptr(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_pcfns_pc_storestring(struct pc_decls_varrec * p,struct pc_decls_varrec * q);
void pc_pcfns_pc_iconvert(int64 t,struct pc_decls_varrec * x);
void pc_pcfns_pc_iconvcase(struct pc_decls_varrec * a,struct pc_decls_varrec * b,int64 upper);
int64 pc_pcfns_pc_eqstring_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64 pc_pcfns_pc_equal_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y,int64 shallow);
int64 pc_pcfns_comparebytes(byte * p,byte * q,int64 n);
int64 pc_pcfns_pc_compare_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64 pc_pcfns_cmpstringlen(byte * s,byte * t,int64 slen,int64 tlen);
int64 pc_pcfns_pc_eqstring(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64 pc_pcfns_pc_equal(struct pc_decls_varrec * x,struct pc_decls_varrec * y,int64 shallow);
int64 pc_pcfns_pc_compare(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64 pc_pcfns_u8inarray(byte a,struct pc_decls_objrec * p);
int64 pc_pcfns_u16inarray(uint16 a,struct pc_decls_objrec * p);
int64 pc_pcfns_u32inarray(uint32 a,struct pc_decls_objrec * p);
int64 pc_pcfns_u64inarray(uint64 a,struct pc_decls_objrec * p);
int64 pc_pcfns_bitinbits(byte a,struct pc_decls_objrec * p);
int64 pc_pcfns_pc_strinstr(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
byte * pc_pcfns_getbitoffset(byte * p,int64 offset,int64 index,int64 t,byte * newoffset);
void pc_pcfns_pc_iappendlist(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_iappendarray(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_mul_listi(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_pcfns_pc_mul_stri(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_pcfns_pc_duplvar(struct pc_decls_varrec * p);
void pc_pcfns_pc_iconcatlist(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_iappendbits(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
void pc_pcfns_pc_makestring(byte * s,int64 length,struct pc_decls_varrec * dest);
void pc_pcfns_pc_makestringx(byte * s,int64 length,int64 allocated,struct pc_decls_varrec * dest);
void pc_pcfns_pc_makestringn(int64 length,struct pc_decls_varrec * dest);
void pc_pcfns_pc_emptystring(struct pc_decls_varrec * dest);
void pc_pcfns_pc_makechar(int64 ch,struct pc_decls_varrec * dest);
struct pc_decls_objrec * pc_objects_newobject(void);
void pc_objects_freeobject(struct pc_decls_objrec * p);
struct pc_decls_objrec * pc_objects_addref_obj(struct pc_decls_objrec * p);
void pc_objects_makezobjects(void);
struct pc_decls_varrec * pc_objects_make_listdata(int64 length,uint32 * allocated,int64 clear);
void pc_objects_free_listdata(struct pc_decls_varrec * p,int64 allocated);
struct pc_decls_varrec * pc_objects_make_arraydata(int64 length,int64 elemtype,uint32 * allocated,int64 clear);
void pc_objects_free_arraydata(struct pc_decls_varrec * p,int64 elemtype,int64 allocated);
byte * pc_objects_make_bitdata(int64 length,int64 elemtype,uint64 * allocated,int64 clear);
void pc_objects_free_bitdata(byte * p,int64 elemtype,int64 allocated);
struct pc_decls_objrec * pc_objects_make_listobj(int64 length,int64 lower);
struct pc_decls_objrec * pc_objects_make_arrayobj(int64 length,int64 elemtype,int64 lower);
struct pc_decls_objrec * pc_objects_make_setobj(int64 length);
struct pc_decls_objrec * pc_objects_make_bitsobj(int64 length,int64 elemtype,int64 lower);
void pc_objects_resize_listobj(struct pc_decls_objrec * p,int64 n);
void pc_objects_resize_arrayobj(struct pc_decls_objrec * p,int64 n);
void pc_objects_resize_bitsobj(struct pc_decls_objrec * p,int64 n);
struct pc_decls_objrec * pc_objects_make_strslicexobj(byte * s,int64 length);
struct pc_decls_objrec * pc_objects_copyonwrite(struct pc_decls_objrec * p,int64 tag);
int64 pc_objects_get_objbytes(struct pc_decls_objrec * p);
void pc_bigint_bn_makestr(byte * s,int64 length,struct pc_decls_varrec * dest);
void pc_bigint_bn_makeint(int64 aa,struct pc_decls_varrec * dest);
static void pc_bigint_bn_makeu(byte * s,int64 nchars,struct pc_decls_varrec * bn);
void pc_bigint_bn_makeu_base(byte * s,int64 nchars,struct pc_decls_varrec * bn,int64 base);
static int64 pc_bigint_strvaln(byte * s,int64 n);
static void pc_bigint_makebigint(int64 ndigits,struct pc_decls_varrec * dest);
void pc_bigint_freebigint(struct pc_decls_varrec * bn);
void pc_bigint_bn_neg(struct pc_decls_varrec * bn);
void pc_bigint_bn_abs(struct pc_decls_varrec * bn);
void pc_bigint_bn_add(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
static void pc_bigint_bn_addu(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bigint_bn_sub(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
static void pc_bigint_bn_subu(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bigint_bn_mul(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bigint_muldigit(struct pc_decls_varrec * a,int64 b,int64 d,struct pc_decls_varrec * c);
static void pc_bigint_bn_zero(struct pc_decls_varrec * bn);
void pc_bigint_bn_mulu(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bigint_bn_div(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
void pc_bigint_bn_divu(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
int64 pc_bigint_bn_equal(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
int64 pc_bigint_bn_cmp(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
int64 pc_bigint_bn_int(struct pc_decls_varrec * a);
int64 pc_bigint_bn_digits(struct pc_decls_varrec * bn);
void pc_bigint_bn_power(struct pc_decls_varrec * a,int64 n,struct pc_decls_varrec * dest);
void pc_bigint_bn_reduce(struct pc_decls_varrec * bn);
void pc_print_pch_print(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt);
void pc_print_pch_println(void);
void pc_print_pch_startprintcon(void);
void pc_print_pch_startprint(struct pc_decls_varrec * p);
void pc_print_pch_endprint(void);
void pc_print_pch_strstartprint(void);
void pc_print_pch_strendprint(struct pc_decls_varrec * dest);
void pc_print_pch_setformat(struct pc_decls_varrec * p);
void pc_print_pch_setformat2(struct pc_decls_varrec * p);
void pc_print_pch_dprint(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt);
void pc_print_pch_printnogap(void);
static void pc_print_initfmtcode(struct pc_decls_fmtrec * f);
static int64 pc_print_i64mintostr(byte * s,int64 base,int64 sep);
static int64 pc_print_u64tostr(uint64 aa,byte * s,uint64 base,int64 sep);
static int64 pc_print_i64tostrfmt(int64 aa,byte * s,struct pc_decls_fmtrec * fmt,int64 usigned);
static int64 pc_print_u64tostrfmt(int64 aa,byte * s,struct pc_decls_fmtrec * fmt);
static int64 pc_print_strtostrfmt(byte * s,byte * t,int64 n,struct pc_decls_fmtrec * fmt);
static int64 pc_print_expandstr(byte * s,byte * t,int64 n,struct pc_decls_fmtrec * fmt);
void pc_print_pc_strtofmt(byte * s,int64 slen,struct pc_decls_fmtrec * fmt);
static void pc_print_printstrz(byte * s);
static void pc_print_printstr_n(byte * s,int64 n);
void pc_print_printerror(byte * s);
void pc_print_addstring(struct pc_decls_objrec * p,byte * t,int64 n);
void pc_print_j_tostr_i(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_r(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_w(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_n(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_s(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_l(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_a(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_b(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_e(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_k(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_j(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_d(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
void pc_print_j_tostr_z(struct pc_decls_varrec * a,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
static void pc_print_printnextfmtchars(int64 last);
static int64 pc_print_getreadfmtcode(struct pc_decls_varrec * p);
void pc_print_pch_sreadln(struct pc_decls_varrec * dev,struct pc_decls_varrec * dest);
void pc_print_pch_strtoval(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt,struct pc_decls_varrec * dest);
void pc_print_pch_reread(void);
void pc_print_pch_rereadln(void);
static byte * pc_print_readname(byte * s,int64 length,struct pc_decls_varrec * dest);
static byte * pc_print_readstring(byte * s,int64 length,struct pc_decls_varrec * dest);
static byte * pc_print_readint(byte * sold,int64 length,struct pc_decls_varrec * dest);
static byte * pc_print_readhex(byte * sold,int64 length,struct pc_decls_varrec * dest);
static byte * pc_print_readbin(byte * sold,int64 length,struct pc_decls_varrec * dest);
static byte * pc_print_readreal(byte * sold,int64 length,struct pc_decls_varrec * dest);
void pc_print_pch_readln(struct pc_decls_varrec * dev);
static void pc_print_stepkbpos(byte * s);
void pc_print_pch_sread(struct pc_decls_varrec * fmt,struct pc_decls_varrec * dest);
static void pc_print_domultichar(byte * p,int64 n,byte * dest,struct pc_decls_fmtrec * fmt);
void pc_print_pch_tostr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
struct pc_decls_fmtrec * pc_print_pc_getfmt(struct pc_decls_varrec * p,struct pc_decls_fmtrec * fmt);
static void pc_print_pc_readlinen(void * handlex,byte * buffer,int64 size);
static byte * pc_print_readitem(byte * s,int64 length,byte * * itemstr,int64 * itemlength);
static byte * pc_print_readany(byte * sold,int64 length,struct pc_decls_varrec * dest);
static void pc_print_strtoreal(byte * s,int64 length,struct pc_decls_varrec * dest);
static void pc_print_strtoint(byte * s,int64 length,struct pc_decls_varrec * dest);
static void pc_print_calltostrtable(struct pc_decls_varrec * q,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
static byte * pc_print_printbn(struct pc_decls_varrec * a0,struct pc_decls_fmtrec * fmt,int64 * length);
void pc_jhandlers_initcalltables(void);
static void pc_jhandlers_initjhandler(byte * p,void * fnaddr);
static void pc_jhandlers_add_stable_entry(void * (*table)[],int64 t,void * fnaddr);
static void pc_jhandlers_add_dtable_entry(uint64 * (*(*table)[])(void),int64 s,int64 t,void * fnaddr);
static void pc_jhandlers_def_handler(void);
static void pc_jhandlers_ddef_handler(void);
uint64 * pc_jhandlers_j_add_i_w(void);
uint64 * pc_jhandlers_j_add_r(void);
uint64 * pc_jhandlers_j_add_s(void);
uint64 * pc_jhandlers_j_add_j(void);
uint64 * pc_jhandlers_j_add_e(void);
uint64 * pc_jhandlers_j_add_z(void);
uint64 * pc_jhandlers_j_add_iw_wi(void);
uint64 * pc_jhandlers_j_add_zz(void);
uint64 * pc_jhandlers_j_sub_i_w(void);
uint64 * pc_jhandlers_j_sub_r(void);
uint64 * pc_jhandlers_j_sub_p(void);
uint64 * pc_jhandlers_j_sub_j(void);
uint64 * pc_jhandlers_j_sub_e(void);
uint64 * pc_jhandlers_j_sub_z(void);
uint64 * pc_jhandlers_j_sub_zz(void);
static uint64 * pc_jhandlers_j_mixed_iw_wi(void);
static uint64 * pc_jhandlers_j_mixed_ir(void);
static uint64 * pc_jhandlers_j_mixed_ri(void);
static uint64 * pc_jhandlers_j_mixed_ij(void);
static uint64 * pc_jhandlers_j_mixed_ji(void);
uint64 * pc_jhandlers_j_mul_i_w(void);
uint64 * pc_jhandlers_j_mul_r(void);
uint64 * pc_jhandlers_j_mul_j(void);
uint64 * pc_jhandlers_j_mul_z(void);
uint64 * pc_jhandlers_j_mul_li(void);
uint64 * pc_jhandlers_j_mul_si(void);
uint64 * pc_jhandlers_j_mul_e(void);
uint64 * pc_jhandlers_j_mul_zz(void);
uint64 * pc_jhandlers_j_div_i(void);
uint64 * pc_jhandlers_j_div_r(void);
uint64 * pc_jhandlers_j_div_z(void);
uint64 * pc_jhandlers_j_jumple_i(void);
uint64 * pc_jhandlers_j_jumple_r(void);
uint64 * pc_jhandlers_j_jumple_s(void);
uint64 * pc_jhandlers_j_jumple_z(void);
uint64 * pc_jhandlers_j_jumpeq_i_r_t_o(void);
uint64 * pc_jhandlers_j_jumpeq_v_p_f_g(void);
uint64 * pc_jhandlers_j_jumpeq_s(void);
uint64 * pc_jhandlers_j_jumpeq_z(void);
uint64 * pc_jhandlers_j_jumpeq_zz(void);
uint64 * pc_jhandlers_j_jumpne_i_r_t_o(void);
uint64 * pc_jhandlers_j_jumpne_v_p_f_g(void);
uint64 * pc_jhandlers_j_jumpne_s(void);
uint64 * pc_jhandlers_j_jumpne_z(void);
uint64 * pc_jhandlers_j_jumpne_zz(void);
uint64 * pc_jhandlers_j_jumpge_i(void);
uint64 * pc_jhandlers_j_jumpge_w(void);
uint64 * pc_jhandlers_j_jumpge_r(void);
uint64 * pc_jhandlers_j_jumpge_z(void);
uint64 * pc_jhandlers_j_jumpgt_i(void);
uint64 * pc_jhandlers_j_jumpgt_w(void);
uint64 * pc_jhandlers_j_jumpgt_r(void);
uint64 * pc_jhandlers_j_jumpgt_z(void);
uint64 * pc_jhandlers_j_jumplt_i(void);
uint64 * pc_jhandlers_j_jumplt_v_p(void);
uint64 * pc_jhandlers_j_jumplt_r(void);
uint64 * pc_jhandlers_j_jumplt_z(void);
uint64 * pc_jhandlers_j_pushix_li_mi(void);
uint64 * pc_jhandlers_j_pushix_vi(void);
uint64 * pc_jhandlers_j_pushix_ln(void);
uint64 * pc_jhandlers_j_pushix_ll(void);
uint64 * pc_jhandlers_j_pushix_le(void);
uint64 * pc_jhandlers_j_pushix_ai(void);
uint64 * pc_jhandlers_j_pushix_bi_ei(void);
uint64 * pc_jhandlers_j_pushix_an(void);
uint64 * pc_jhandlers_j_pushix_si(void);
uint64 * pc_jhandlers_j_pushix_sn(void);
uint64 * pc_jhandlers_j_pushix_bn(void);
uint64 * pc_jhandlers_j_pushix_di(void);
uint64 * pc_jhandlers_j_pushix_zz(void);
uint64 * pc_jhandlers_j_pushixref_li(void);
uint64 * pc_jhandlers_j_pushixref_ln(void);
uint64 * pc_jhandlers_j_pushixref_ai(void);
uint64 * pc_jhandlers_j_pushixref_si(void);
uint64 * pc_jhandlers_j_pushixref_bi_ei(void);
uint64 * pc_jhandlers_j_pushixref_zz(void);
uint64 * pc_jhandlers_j_pushdotix_si(void);
uint64 * pc_jhandlers_j_pushdotix_sn(void);
uint64 * pc_jhandlers_j_pushdotix_ii(void);
uint64 * pc_jhandlers_j_pushdotix_in(void);
uint64 * pc_jhandlers_j_pushdotix_ei(void);
uint64 * pc_jhandlers_j_pushdotix_mi(void);
uint64 * pc_jhandlers_j_pushdotix_zz(void);
uint64 * pc_jhandlers_j_pushdotixref_si(void);
uint64 * pc_jhandlers_j_pushdotixref_sn(void);
uint64 * pc_jhandlers_j_pushdotixref_ii(void);
uint64 * pc_jhandlers_j_pushdotixref_ei(void);
uint64 * pc_jhandlers_j_pushdotixref_zz(void);
uint64 * pc_jhandlers_j_addto_i(void);
uint64 * pc_jhandlers_j_addto_r(void);
uint64 * pc_jhandlers_j_addto_s(void);
uint64 * pc_jhandlers_j_addto_p(void);
uint64 * pc_jhandlers_j_addto_z(void);
uint64 * pc_jhandlers_j_addto_si(void);
uint64 * pc_jhandlers_j_addto_ir(void);
uint64 * pc_jhandlers_j_addto_ri(void);
uint64 * pc_jhandlers_j_addto_zz(void);
uint64 * pc_jhandlers_j_subto_i(void);
uint64 * pc_jhandlers_j_subto_r(void);
uint64 * pc_jhandlers_j_subto_z(void);
uint64 * pc_jhandlers_j_multo_i_w(void);
uint64 * pc_jhandlers_j_multo_r(void);
uint64 * pc_jhandlers_j_multo_z(void);
uint64 * pc_jhandlers_j_divto_i_w(void);
uint64 * pc_jhandlers_j_divto_r(void);
uint64 * pc_jhandlers_j_divto_z(void);
uint64 * pc_jhandlers_j_idivto_i(void);
uint64 * pc_jhandlers_j_idivto_z(void);
uint64 * pc_jhandlers_j_iand_i_w(void);
uint64 * pc_jhandlers_j_iand_e(void);
uint64 * pc_jhandlers_j_iand_z(void);
uint64 * pc_jhandlers_j_ior_i_w(void);
uint64 * pc_jhandlers_j_ior_e(void);
uint64 * pc_jhandlers_j_ior_z(void);
uint64 * pc_jhandlers_j_ixor_i_w(void);
uint64 * pc_jhandlers_j_ixor_e(void);
uint64 * pc_jhandlers_j_ixor_z(void);
uint64 * pc_jhandlers_j_iandto_i_w(void);
uint64 * pc_jhandlers_j_iandto_z(void);
uint64 * pc_jhandlers_j_iorto_i_w(void);
uint64 * pc_jhandlers_j_iorto_z(void);
uint64 * pc_jhandlers_j_ixorto_i_w(void);
uint64 * pc_jhandlers_j_ixorto_z(void);
uint64 * pc_jhandlers_j_shlto_i(void);
uint64 * pc_jhandlers_j_shlto_z(void);
uint64 * pc_jhandlers_j_shrto_i(void);
uint64 * pc_jhandlers_j_shrto_z(void);
uint64 * pc_jhandlers_j_concat_s(void);
uint64 * pc_jhandlers_j_concat_l(void);
uint64 * pc_jhandlers_j_concat_z(void);
uint64 * pc_jhandlers_j_concatto_s(void);
uint64 * pc_jhandlers_j_concatto_l(void);
uint64 * pc_jhandlers_j_concatto_z(void);
uint64 * pc_jhandlers_j_append_s(void);
uint64 * pc_jhandlers_j_append_l(void);
uint64 * pc_jhandlers_j_append_a(void);
uint64 * pc_jhandlers_j_append_b(void);
uint64 * pc_jhandlers_j_append_z(void);
uint64 * pc_jhandlers_j_appendto_s(void);
uint64 * pc_jhandlers_j_appendto_l(void);
uint64 * pc_jhandlers_j_appendto_a(void);
uint64 * pc_jhandlers_j_appendto_b_e(void);
uint64 * pc_jhandlers_j_appendto_z(void);
uint64 * pc_jhandlers_j_max_i(void);
uint64 * pc_jhandlers_j_max_r(void);
uint64 * pc_jhandlers_j_max_z(void);
uint64 * pc_jhandlers_j_min_z(void);
uint64 * pc_jhandlers_j_len_l_a_e_s_b_m_k_d(void);
uint64 * pc_jhandlers_j_len_n(void);
uint64 * pc_jhandlers_j_len_z(void);
uint64 * pc_jhandlers_j_lwb_l_a_b(void);
uint64 * pc_jhandlers_j_lwb_s_m_k_d(void);
uint64 * pc_jhandlers_j_lwb_e(void);
uint64 * pc_jhandlers_j_lwb_n(void);
uint64 * pc_jhandlers_j_lwb_z(void);
uint64 * pc_jhandlers_j_upb_l_a_b(void);
uint64 * pc_jhandlers_j_upb_s_m_k_d(void);
uint64 * pc_jhandlers_j_upb_e(void);
uint64 * pc_jhandlers_j_upb_n(void);
uint64 * pc_jhandlers_j_upb_z(void);
uint64 * pc_jhandlers_j_bounds_l_a_b_s_m_k_e(void);
uint64 * pc_jhandlers_j_bounds_n(void);
uint64 * pc_jhandlers_j_bounds_z(void);
uint64 * pc_jhandlers_j_minto_i(void);
uint64 * pc_jhandlers_j_minto_r(void);
uint64 * pc_jhandlers_j_minto_z(void);
uint64 * pc_jhandlers_j_maxto_i(void);
uint64 * pc_jhandlers_j_maxto_r(void);
uint64 * pc_jhandlers_j_maxto_z(void);
uint64 * pc_jhandlers_j_neg_i_w(void);
uint64 * pc_jhandlers_j_neg_r(void);
uint64 * pc_jhandlers_j_neg_j(void);
uint64 * pc_jhandlers_j_neg_e(void);
uint64 * pc_jhandlers_j_neg_z(void);
uint64 * pc_jhandlers_j_abs_i_w(void);
uint64 * pc_jhandlers_j_abs_r(void);
uint64 * pc_jhandlers_j_abs_j(void);
uint64 * pc_jhandlers_j_abs_z(void);
uint64 * pc_jhandlers_j_inot_i_w(void);
uint64 * pc_jhandlers_j_inot_e(void);
uint64 * pc_jhandlers_j_inot_z(void);
uint64 * pc_jhandlers_j_istrue_i_w_r(void);
uint64 * pc_jhandlers_j_istrue_l_a_e_s_b(void);
uint64 * pc_jhandlers_j_istrue_k_m_h(void);
uint64 * pc_jhandlers_j_istrue_j(void);
uint64 * pc_jhandlers_j_istrue_z(void);
uint64 * pc_jhandlers_j_jumpfalse_i_w_r_v_p_f(void);
uint64 * pc_jhandlers_j_jumpfalse_s_l_e_a_b(void);
uint64 * pc_jhandlers_j_jumpfalse_z(void);
uint64 * pc_jhandlers_j_jumptrue_i_r_w_v_p_f(void);
uint64 * pc_jhandlers_j_jumptrue_s_l_e_a_b(void);
uint64 * pc_jhandlers_j_jumptrue_z(void);
uint64 * pc_jhandlers_j_shl_i_w(void);
uint64 * pc_jhandlers_j_shl_z(void);
uint64 * pc_jhandlers_j_shr_i(void);
uint64 * pc_jhandlers_j_shr_z(void);
uint64 * pc_jhandlers_j_shr_wi(void);
uint64 * pc_jhandlers_j_shr_zz(void);
uint64 * pc_jhandlers_j_idiv_i_w(void);
uint64 * pc_jhandlers_j_idiv_j(void);
uint64 * pc_jhandlers_j_idiv_z(void);
int64 pc_oslayer_runproc_m(void * amsg);
void pc_oslayer_os_getconsize(struct pc_decls_varrec * result);
void pc_oslayer_pch_setmesshandler(struct pc_decls_varrec * fn);
void pc_oslayer_pch_gethostname(struct pc_decls_varrec * result);
void pc_oslayer_os_initdllmodules(void);
int64 pc_oslayer_os_loaddllmodule(byte * dllname);
void pc_oslayer_os_initdllfunctions(void);
void * pc_oslayer_os_loaddllfunction(int64 fnindex);
void pc_oslayer_pch_getos(struct pc_decls_varrec * result);
void pc_oslayer_pch_gethostsize(struct pc_decls_varrec * result);
void pc_oslayer_pch_iswindows(struct pc_decls_varrec * result);
void pc_oslayer_os_calldll(int64 calltype,int64 fnindex,int64 offset,int64 nparams,int64 restype,struct pc_decls_varrec * dest);
static int64 pc_oslayer_calldll_mint(void (*fnaddr)(void),int64 (*params)[],int64 nparams);
static double pc_oslayer_calldll_mreal(void (*fnaddr)(void),int64 (*params)[],int64 nparams);
static int64 pc_oslayer_calldll_cint(void (*fnaddr)(void),int64 (*params)[],int64 nparams);
static double pc_oslayer_calldll_creal(void (*fnaddr)(void),double (*params)[],int64 nparams);
int64 osnosdll_os_calldll_wint(void * fnaddr,int64 (*params)[],int64 nparams);
double osnosdll_os_calldll_wreal(void * fnaddr,int64 (*params)[],int64 nparams);
void osnosdll_os_dummycall(double a,double b,double c,double d);
void pc_host_callhostfunction(int64 hostfn,int64 calledasfn);
static void pc_host_pch_leftstr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result);
static void pc_host_pch_rightstr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result);
static void pc_host_pch_convlc(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_convuc(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_iconvlc(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
static void pc_host_pch_iconvuc(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
static void pc_host_pch_stop(void);
static void pc_host_pch_stopx(struct pc_decls_varrec * a);
static void pc_host_pch_ismain(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_waitkey(struct pc_decls_varrec * result);
static void pc_host_pch_testkey(struct pc_decls_varrec * result);
static void pc_host_pch_execwait(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result);
static void pc_host_pch_execcmd(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result);
static void pc_host_pch_makestr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_makestrslice(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_makeref(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_new(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * d,struct pc_decls_varrec * result);
static void pc_host_pch_newheap(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * d,struct pc_decls_varrec * result);
static void pc_host_pch_heapvar(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_freeheap(struct pc_decls_varrec * a);
static void pc_host_pch_getcmdparam(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_setpcerror(struct pc_decls_varrec * a);
static void pc_host_pch_setdebug(struct pc_decls_varrec * a);
static void pc_host_pch_setfprintf(struct pc_decls_varrec * a,struct pc_decls_varrec * b);
static void pc_host_pch_ticks(struct pc_decls_varrec * result);
static void pc_host_pch_sleep(struct pc_decls_varrec * a);
static void pc_host_pch_random(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_findmetafunction(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_loadpcl(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_runpcl(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_runtask(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_callext(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
static void pc_host_pch_system(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_shellexec(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_gethash(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_test(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_pcldata(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result);
static void pc_host_pch_getcstring(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_getparam(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_clearlist(struct pc_decls_varrec * a);
static void pc_host_pch_makelink(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_allparams(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_stackvars(struct pc_decls_varrec * result);
static void pc_host_pch_makeempty(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_readlines(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_dictitems(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_pch_setoverload(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c);
static void pc_host_pch_errorinfo(struct pc_decls_varrec * a,struct pc_decls_varrec * result);
static void pc_host_getbounds(struct pc_decls_varrec * p,struct pc_host_dimrec * dims,int64 lower);
static int64 pc_host_checkparam(struct pc_decls_varrec * p,int64 tag,int64 defaultx);
static void pc_host_leftstring(struct pc_decls_varrec * a,int64 n,struct pc_decls_varrec * result);
static void pc_host_rightstring(struct pc_decls_varrec * a,int64 n,struct pc_decls_varrec * result);
static void pc_host_padstring_right(struct pc_decls_varrec * a,int64 n,int64 fillchar,struct pc_decls_varrec * result);
static void pc_host_padstring_left(struct pc_decls_varrec * a,int64 n,int64 fillchar,struct pc_decls_varrec * result);
static void pc_host_pcld_makevint(struct pc_decls_varrec * p,int64 a);
static void pc_host_pcld_makelist(struct pc_decls_varrec * p,struct pc_decls_varrec * result,int64 n);
static void pc_host_getproctabledata(struct pc_decls_procrec * p,struct pc_decls_varrec * result);
static uint64 * pc_host_convert_handler(int64 _1);
static void pc_host_addtoproclist(struct pc_decls_strec * d);
static uint64 * pc_host_tostr_handler(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest);
static void pc_host_addovrecord(struct pc_host_overloadrec * * p,int64 t,uint64 * fnptr);
void pc_dxfns_dx_iorset(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_dx_iandset(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_dx_ixorset(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_dx_inotset(struct pc_decls_varrec * x);
void pc_dxfns_dx_subset(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_inotsetbits(int64 * p,int64 n);
void pc_dxfns_iorsetbits(int64 * p,int64 * q,int64 n);
void pc_dxfns_iandsetbits(int64 * p,int64 * q,int64 n);
void pc_dxfns_ixorsetbits(int64 * p,int64 * q,int64 n);
void pc_dxfns_subsetbits(int64 * p,int64 * q,int64 n);
void pc_dxfns_iresizeset(struct pc_decls_varrec * p,int64 n);
int64 pc_dxfns_dx_varinvar(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
int64 pc_dxfns_dx_mixed(struct pc_decls_varrec * x,struct pc_decls_varrec * y);
void pc_dxfns_resize_stringobj(struct pc_decls_objrec * p,int64 n);
void * pc_khandlers_k_zero(void);
void * pc_khandlers_k_nop(void);
void * pc_khandlers_k_procstart(void);
void * pc_khandlers_k_procend(void);
void * pc_khandlers_k_endmodule(void);
void * pc_khandlers_k_push_m(void);
void * pc_khandlers_k_push_f(void);
void * pc_khandlers_k_push_am(void);
void * pc_khandlers_k_push_af(void);
void * pc_khandlers_k_push_ap(void);
void * pc_khandlers_k_push_al(void);
void * pc_khandlers_k_push_ci(void);
void * pc_khandlers_k_push_cw(void);
void * pc_khandlers_k_push_cr(void);
void * pc_khandlers_k_push_cn(void);
void * pc_khandlers_k_push_cs(void);
void * pc_khandlers_k_push_t(void);
void * pc_khandlers_k_push_op(void);
void * pc_khandlers_k_pushz(void);
void * pc_khandlers_k_pushz_void(void);
void * pc_khandlers_k_pushz_str(void);
void * pc_khandlers_k_pushz_list(void);
void * pc_khandlers_k_pushz_listl(void);
void * pc_khandlers_k_pushz_set(void);
void * pc_khandlers_k_pushz_arrayl(void);
void * pc_khandlers_k_pop_m(void);
void * pc_khandlers_k_pop_f(void);
void * pc_khandlers_k_store_m(void);
void * pc_khandlers_k_store_f(void);
void * pc_khandlers_k_pushptr(void);
void * pc_khandlers_k_popptr(void);
void * pc_khandlers_k_storeptr(void);
void * pc_khandlers_k_zpop_m(void);
void * pc_khandlers_k_zpop_f(void);
void * pc_khandlers_k_zstore_m(void);
void * pc_khandlers_k_zstore_f(void);
void * pc_khandlers_k_copy(void);
void * pc_khandlers_k_swap(void);
void * pc_khandlers_k_convptr(void);
void * pc_khandlers_k_jump(void);
void * pc_khandlers_k_jumpptr(void);
void * pc_khandlers_k_jumptrue(void);
void * pc_khandlers_k_jumpfalse(void);
void * pc_khandlers_k_jumpdef(void);
void * pc_khandlers_k_jumpvoid(void);
void * pc_khandlers_k_jumpeq(void);
void * pc_khandlers_k_jumpne(void);
void * pc_khandlers_k_jumplt(void);
void * pc_khandlers_k_jumple(void);
void * pc_khandlers_k_jumpge(void);
void * pc_khandlers_k_jumpgt(void);
void * pc_khandlers_k_jumptesteq(void);
void * pc_khandlers_k_jumptestne(void);
void * pc_khandlers_k_jumplabel(void);
void * pc_khandlers_k_jumpclabel(void);
void * pc_khandlers_k_switch(void);
void * pc_khandlers_k_cswitch(void);
void * pc_khandlers_k_new(void);
void * pc_khandlers_k_to_f(void);
void * pc_khandlers_k_for_fci(void);
void * pc_khandlers_k_for_ff(void);
void * pc_khandlers_k_ford_fci(void);
void * pc_khandlers_k_ford_ff(void);
void * pc_khandlers_k_call(void);
void * pc_khandlers_k_callptr(void);
void * pc_khandlers_k_return(void);
void * pc_khandlers_k_startdll(void);
void * pc_khandlers_k_pushdll(void);
void * pc_khandlers_k_calldll(void);
void * pc_khandlers_k_callhost(void);
void * pc_khandlers_k_stackframe(void);
void * pc_khandlers_k_free(void);
void * pc_khandlers_k_addsp(void);
void * pc_khandlers_k_stop(void);
void * pc_khandlers_k_test(void);
void * pc_khandlers_k_makelist(void);
void * pc_khandlers_k_makerecord(void);
void * pc_khandlers_k_makearray(void);
void * pc_khandlers_k_makestruct(void);
void * pc_khandlers_k_makeset(void);
void * pc_khandlers_k_makerange(void);
void * pc_khandlers_k_makedict(void);
void * pc_khandlers_k_pushdot(void);
void * pc_khandlers_k_pushdotref(void);
void * pc_khandlers_k_softconv(void);
void * pc_khandlers_k_hardconv(void);
void * pc_khandlers_k_mixed(void);
void * pc_khandlers_k_incrptr(void);
void * pc_khandlers_k_incrto_m(void);
void * pc_khandlers_k_incrto_f(void);
void * pc_khandlers_k_loadincr(void);
void * pc_khandlers_k_incrload(void);
void * pc_khandlers_k_decrptr(void);
void * pc_khandlers_k_decrto_m(void);
void * pc_khandlers_k_decrto_f(void);
void * pc_khandlers_k_loaddecr(void);
void * pc_khandlers_k_decrload(void);
void * pc_khandlers_k_incr(void);
void * pc_khandlers_k_decr(void);
void * pc_khandlers_k_neg(void);
void * pc_khandlers_k_abs(void);
void * pc_khandlers_k_not(void);
void * pc_khandlers_k_inot(void);
void * pc_khandlers_k_istrue(void);
void * pc_khandlers_k_asc(void);
void * pc_khandlers_k_chr(void);
void * pc_khandlers_k_sqrt(void);
void * pc_khandlers_k_sqr(void);
void * pc_khandlers_k_cube(void);
void * pc_khandlers_k_sin(void);
void * pc_khandlers_k_cos(void);
void * pc_khandlers_k_tan(void);
void * pc_khandlers_k_asin(void);
void * pc_khandlers_k_acos(void);
void * pc_khandlers_k_atan(void);
void * pc_khandlers_k_sign(void);
void * pc_khandlers_k_ln(void);
void * pc_khandlers_k_log(void);
void * pc_khandlers_k_lg(void);
void * pc_khandlers_k_exp(void);
void * pc_khandlers_k_round(void);
void * pc_khandlers_k_floor(void);
void * pc_khandlers_k_ceil(void);
void * pc_khandlers_k_fract(void);
void * pc_khandlers_k_negto(void);
void * pc_khandlers_k_absto(void);
void * pc_khandlers_k_notto(void);
void * pc_khandlers_k_inotto(void);
void * pc_khandlers_k_len(void);
void * pc_khandlers_k_lwb(void);
void * pc_khandlers_k_upb(void);
void * pc_khandlers_k_bounds(void);
void * pc_khandlers_k_bits(void);
void * pc_khandlers_k_bytes(void);
void * pc_khandlers_k_type(void);
void * pc_khandlers_k_elemtype(void);
void * pc_khandlers_k_basetype(void);
void * pc_khandlers_k_minval(void);
void * pc_khandlers_k_maxval(void);
void * pc_khandlers_k_isint(void);
void * pc_khandlers_k_isreal(void);
void * pc_khandlers_k_isstring(void);
void * pc_khandlers_k_isrange(void);
void * pc_khandlers_k_isnumber(void);
void * pc_khandlers_k_isarray(void);
void * pc_khandlers_k_isrecord(void);
void * pc_khandlers_k_ispointer(void);
void * pc_khandlers_k_ismutable(void);
void * pc_khandlers_k_isset(void);
void * pc_khandlers_k_isvoid(void);
void * pc_khandlers_k_isdef(void);
void * pc_khandlers_k_tostr(void);
void * pc_khandlers_k_isequal(void);
void * pc_khandlers_k_add(void);
void * pc_khandlers_k_sub(void);
void * pc_khandlers_k_mul(void);
void * pc_khandlers_k_div(void);
void * pc_khandlers_k_idiv(void);
void * pc_khandlers_k_rem(void);
void * pc_khandlers_k_divrem(void);
void * pc_khandlers_k_iand(void);
void * pc_khandlers_k_ior(void);
void * pc_khandlers_k_ixor(void);
void * pc_khandlers_k_shl(void);
void * pc_khandlers_k_shr(void);
void * pc_khandlers_k_in(void);
void * pc_khandlers_k_notin(void);
void * pc_khandlers_k_inrev(void);
void * pc_khandlers_k_eq(void);
void * pc_khandlers_k_ne(void);
void * pc_khandlers_k_lt(void);
void * pc_khandlers_k_le(void);
void * pc_khandlers_k_ge(void);
void * pc_khandlers_k_gt(void);
void * pc_khandlers_k_min(void);
void * pc_khandlers_k_max(void);
void * pc_khandlers_k_concat(void);
void * pc_khandlers_k_append(void);
void * pc_khandlers_k_power(void);
void * pc_khandlers_k_atan2(void);
void * pc_khandlers_k_addto(void);
void * pc_khandlers_k_subto(void);
void * pc_khandlers_k_multo(void);
void * pc_khandlers_k_divto(void);
void * pc_khandlers_k_idivto(void);
void * pc_khandlers_k_iandto(void);
void * pc_khandlers_k_iorto(void);
void * pc_khandlers_k_ixorto(void);
void * pc_khandlers_k_shlto(void);
void * pc_khandlers_k_shrto(void);
void * pc_khandlers_k_minto(void);
void * pc_khandlers_k_maxto(void);
void * pc_khandlers_k_concatto(void);
void * pc_khandlers_k_appendto(void);
void * pc_khandlers_k_pushix(void);
void * pc_khandlers_k_pushdotix(void);
void * pc_khandlers_k_pushkeyix(void);
void * pc_khandlers_k_pushkeyixd(void);
void * pc_khandlers_k_pushixref(void);
void * pc_khandlers_k_pushdotixref(void);
void * pc_khandlers_k_pushkeyixref(void);
void * pc_khandlers_k_pushbyteix(void);
void * pc_khandlers_k_pushbyteixref(void);
void * pc_khandlers_k_appendset(void);
void * pc_khandlers_k_pushdotm(void);
void * pc_khandlers_k_pushdott(void);
void * pc_khandlers_k_push_ad(void);
void * pc_khandlers_k_push_try(void);
void * pc_khandlers_k_raise(void);
void * pc_khandlers_k_applyop(void);
void * pc_khandlers_k_makeiter(void);
void * pc_khandlers_k_forall(void);
void * pc_khandlers_k_forallx(void);
void * pc_khandlers_k_foreach(void);
void * pc_khandlers_k_foreachx(void);
void * pc_khandlers_k_expandrange(void);
void pc_assem_c_fixup_asm(int64 mx);
int64 pc_assem_c_asmavailable(void);
void pc_assem_c_addcountint(void * cmd);
void pc_assem_c_addcountext(void);
void pc_assem_c_showasmcmd(void * cmd);
int64 * pc_assem_c_disploop_asm(void);
uint32 pc_assem_c_getasmjump(int64 cmd);
int64 qc_qcompiler(byte * infile,byte * outfile);
void qc_qcstart(void);
static void qc_do_loadmodules(void);
static int64 qc_loadmainmodule(byte * filespec);
static int64 qc_loadmodule(byte * modulename,byte * filespec,byte * source,int64 length,int64 id,int64 * exportflag);
static int64 qc_loadimport(byte * modulename,int64 * exportflag);
static int64 qc_readimportlist(struct var_decls_modulerec * m,byte * (*importnames)[],byte (*importflags)[],int64 maximports);
static void qc_initlogfile(void);
static void qc_closelogfile(void);
static void qc_initdata(void);
static void qc_initsearchdirs(void);
static byte * qc_getmodulestr(byte * modulename,byte * filespec);
static byte * qc_findmodule(byte * modulename);
static int64 qc_checkname(byte * name,int64 length);
static void qc_getinputoptions(void);
static void qc_do_option(int64 sw,byte * value);
static int64 qc_do_parse(int64 n);
static int64 qc_do_codegen(int64 n);
static void qc_showast(void);
static void qc_showstflat(byte * caption);
static void qc_showsttree(void);
static void qc_showpcl(byte * caption,int64 phase);
static void qc_showgenfields(void);
static void qc_loaderror(byte * mess,byte * mess2);
static void qc_do_showprogdiags_pc(byte * caption);
static void qc_getsyscmdline(void);
static void qc_showmodules(void);
static void qc_do_compilemodules(void);
static int64 qc_compilemodule(int64 n);
static void qc_starttiming(void);
static void qc_showtiming(void);
static void qc_do_writeqafile(void);
static void qc_checkkeyword(byte * kwd);
static int64 qc_readinttoken(void);
static int64 qc_do_loadqafile(void);
static void qc_showinttiming(byte * caption);
static void qc_do_writepcfile(void);
static void qc_writesymbols(int64 mx);
static void qc_showpcsymbol(struct var_decls_strec * d);
static void qc_writepccode2pc(int64 mx);
static void qc_writestructfields(void);
static void qc_fixup_genfields(void);
static void qc_showoptions(void);
static void qc_showoutput(void);
static void qc_showhelp(void);
int64 qc_nextcmd(int64 * paramno,byte * * name,byte * * value,byte * defext);
static void qc_writedocs(void);
void qc_support_prterror(byte * mess);
void qc_support_serror(byte * mess);
void qc_support_gerror(byte * mess,struct var_decls_unitrec * p);
void qc_support_nxerror(byte * mess,struct var_decls_unitrec * p);
int64 qc_support_testelem(byte (*p)[],int64 n);
void qc_support_setelem(byte (*p)[],int64 n);
void qc_support_inittypetables(void);
int64 qc_support_nextpoweroftwo(int64 x);
void qc_support_initpcdest(void);
int64 qc_support_getpcpos(void);
void qc_support_setpcpos(int64 pos);
int64 qc_support_writepcdata(byte * filename);
void qc_support_writezstring(byte * s);
void qc_support_writezblock(byte * s,int64 length);
void qc_support_writezint(int64 x);
void qc_support_writezint4(int64 x);
void qc_support_writezrange(byte * p);
void qc_support_writezreal(double x);
void qc_support_writezeof(void);
int64 qc_support_ipower(int64 a,int64 n);
void qc_support_gs_additem(struct mlib_strbuffer * dest,byte * s);
static int64 qc_support_isalphanum(int64 c);
static void qc_support_gs_copytostr(struct mlib_strbuffer * source,byte * s);
static void qc_support_outpcbyte(int64 x);
static void qc_support_outpcword(int64 x);
static void qc_support_outpcword16(int64 x);
void qc_lex_lexreadtoken(void);
static void qc_lex_lxreadstring(int64 termchar);
static void qc_lex_readnumber(int64 base);
static void qc_lex_readrealnumber(byte * intstart,int64 intlen,int64 base);
static int64 qc_lex_readexponent(int64 base);
static void qc_lex_lxerror(byte * mess);
void qc_lex_printsymbol(struct qc_lex_lexrec * lp);
static void qc_lex_stringtonumber(byte * s,int64 length,int64 base,int64 numtype);
void qc_lex_lexsetup(void);
void qc_lex_printstrn(byte * s,int64 length);
static byte * qc_lex_scannumber(int64 base);
static void qc_lex_readrawstring(void);
static int64 qc_lex_lookup(void);
static int64 qc_lex_gethashvaluez(byte * s);
static void qc_lex_inithashtable(void);
static int64 qc_lex_dolexdirective(int64 index);
static void qc_lex_lexreadline(void);
void qc_lex_startlex(byte * caption,byte * sourcecode);
byte * qc_lex_convertzstring(byte * s,int64 length);
struct var_decls_strec * qc_lex_addnamestr(byte * name);
void qc_lex_ps1(byte * caption);
void qc_lex_ps2(byte * caption);
void qc_lex_ps(byte * caption);
void qc_lex_lex(void);
void qc_lex_showhashtablesize(void);
static void qc_lex_addmacro(struct var_decls_strec * symptr,byte * value,int64 length);
static void qc_lex_stackmacro(byte * s);
static void qc_lex_unstackmacro(void);
int64 qc_parse_parsemodule(int64 n);
int64 qc_parse_readmoduledefs(struct var_decls_strec * owner);
static void qc_parse_initparser(void);
static void qc_parse_skipsemi(void);
static void qc_parse_addalias(struct var_decls_strec * stold,struct var_decls_strec * stnew);
static struct var_decls_unitrec * qc_parse_makeblock(struct var_decls_unitrec * p);
static void qc_parse_convertstmtexpr(struct var_decls_unitrec * p);
static void qc_parse_checkequals(void);
static int64 qc_parse_getcurrline(void);
static int64 qc_parse_checkbegin(int64 fbrack);
static void qc_parse_checkbeginend(int64 closesym,int64 kwd,int64 startline);
static void qc_parse_checkend(int64 endsym,int64 endkwd1,int64 endkwd2,int64 startline);
static void qc_parse_addgenfield(struct var_decls_strec * d);
static void qc_parse_readvardef(struct var_decls_strec * owner,int64 isglobal,int64 isstatic,int64 varid);
static void qc_parse_readconstdef(struct var_decls_strec * owner,int64 isglobal);
static struct var_decls_unitrec * qc_parse_readexpression(void);
static struct var_decls_unitrec * qc_parse_readfactor(int64 level);
static struct var_decls_unitrec * qc_parse_readterm(void);
static struct var_decls_unitrec * qc_parse_readlbrack(void);
static void qc_parse_addlistunit(struct var_decls_unitrec * * ulist,struct var_decls_unitrec * * ulistx,struct var_decls_unitrec * p);
static void qc_parse_addlistparam(struct var_decls_strec * * ulist,struct var_decls_strec * * ulistx,struct var_decls_strec * p);
static struct var_decls_unitrec * qc_parse_readlsqbrack(void);
static struct var_decls_unitrec * qc_parse_readcast(void);
static struct var_decls_unitrec * qc_parse_readopc(void);
static struct var_decls_unitrec * qc_parse_readsprint(void);
static struct var_decls_unitrec * qc_parse_readsread(void);
static struct var_decls_unitrec * qc_parse_readcompilervar(void);
static struct var_decls_unitrec * qc_parse_readcastx(void);
void qc_parse_checksymbol(int64 symbol);
static int64 qc_parse_readtypespec(struct var_decls_strec * owner,int64 typedefx);
static struct var_decls_unitrec * qc_parse_readhostparams(struct var_decls_unitrec * lhs,int64 isfn);
static struct var_decls_unitrec * qc_parse_readslist(int64 iscall,int64 donulls);
static struct var_decls_unitrec * qc_parse_readindex(struct var_decls_unitrec * p,int64 dot);
static struct var_decls_unitrec * qc_parse_readkeyindex(struct var_decls_unitrec * p,int64 dot);
static struct var_decls_unitrec * qc_parse_readdotsuffix(struct var_decls_unitrec * p);
int64 qc_parse_isconstexpr(struct var_decls_unitrec * p);
static struct var_decls_unitrec * qc_parse_readconstexpr(struct var_decls_strec * owner,int64 needconst);
static int64 qc_parse_readconstexprvalue(struct var_decls_strec * owner);
static int64 qc_parse_readconstint(void);
static void qc_parse_readprocdef(struct var_decls_strec * procowner,int64 isglobal,int64 fflang);
struct var_decls_strec * qc_parse_readprocdecl(struct var_decls_strec * procowner,int64 isglobal,int64 fflang);
static struct var_decls_strec * qc_parse_readparams(struct var_decls_strec * owner,int64 fflang,int64 * varparams,int64 * inparams);
static struct var_decls_unitrec * qc_parse_readblock(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readexecstmt(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readstmtexpr(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readcondsuffix(struct var_decls_unitrec * p);
static struct var_decls_unitrec * qc_parse_readif(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readgoto(struct var_decls_strec * owner,int64 gototag);
static struct var_decls_unitrec * qc_parse_readunless(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readswitchcase(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readstop(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readreturn(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readdo(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readto(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readwhile(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readrepeat(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readloopcontrol(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readprint(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readread(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readtry(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readraise(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readfor(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_readforall(struct var_decls_strec * owner);
void qc_parse_readtypedef(struct var_decls_strec * owner,int64 isglobal);
static int64 qc_parse_readstructdef(struct var_decls_strec * owner,int64 typedefx,int64 kwd);
void qc_parse_readstructfields(struct var_decls_strec * owner,int64 m);
void qc_parse_readtabledef(struct var_decls_strec * owner,int64 isglobal);
void qc_parse_readclassdef(struct var_decls_strec * owner,int64 isglobal);
static void qc_parse_readclassbody(struct var_decls_strec * owner,int64 classkwd);
static int64 qc_parse_readenumtype(struct var_decls_strec * owner,int64 typedefx,int64 isglobal);
static void qc_parse_duplfield(struct var_decls_strec * p,struct var_decls_strec * q);
void qc_parse_readrecordfields(struct var_decls_strec * owner);
static void qc_parse_readimportmodule(struct var_decls_strec * owner);
static void qc_parse_readimportbody(struct var_decls_strec * owner);
static struct var_decls_strec * qc_parse_createlabel(struct var_decls_strec * stname,int64 islabeldef);
static struct var_decls_strec * qc_parse_createprocdef(struct var_decls_strec * owner,struct var_decls_strec * stname,int64 id,byte * truename);
static void qc_parse_createproccall(struct var_decls_strec * owner,struct var_decls_strec * stname,struct var_decls_unitrec * p);
static struct var_decls_strec * qc_parse_readequivfield(struct var_decls_strec * owner);
static struct var_decls_unitrec * qc_parse_testconstruct(struct var_decls_unitrec * p);
static struct var_decls_unitrec * qc_parse_readapplyop(int64 inexpr);
static struct var_decls_strec * qc_lib_newstrec(void);
void qc_lib_initqclib(void);
struct var_decls_strec * qc_lib_getduplnameptr(struct var_decls_strec * owner,struct var_decls_strec * symptr,int64 id);
void qc_lib_adddef(struct var_decls_strec * owner,struct var_decls_strec * p);
void qc_lib_adddef_nodupl(struct var_decls_strec * owner,struct var_decls_strec * p);
void qc_lib_printst(void * f,struct var_decls_strec * p,int64 level);
static void qc_lib_printstrec(void * f,struct var_decls_strec * p,int64 level);
void qc_lib_printstflat(void * f);
static struct var_decls_unitrec * qc_lib_newunitrec(void);
struct var_decls_unitrec * qc_lib_createname(struct var_decls_strec * p);
struct var_decls_unitrec * qc_lib_createunit0(int64 tag);
struct var_decls_unitrec * qc_lib_createunit1(int64 tag,struct var_decls_unitrec * p);
struct var_decls_unitrec * qc_lib_createunit2(int64 tag,struct var_decls_unitrec * p,struct var_decls_unitrec * q);
struct var_decls_unitrec * qc_lib_createunit3(int64 tag,struct var_decls_unitrec * p,struct var_decls_unitrec * q,struct var_decls_unitrec * r);
struct var_decls_unitrec * qc_lib_createconstunit(uint64 a,int64 t);
struct var_decls_unitrec * qc_lib_createstringconstunit(byte * s,int64 length);
int64 qc_lib_getoptocode(int64 opc);
int64 qc_lib_checkpackedtype(int64 m);
void qc_lib_checkunpackedtype(int64 t);
int64 qc_lib_checkdlltype(int64 m);
int64 qc_lib_createtype(struct var_decls_strec * d);
int64 qc_lib_createusertype(struct var_decls_strec * stname);
int64 qc_lib_createusertypefromstr(byte * name);
int64 qc_lib_getconstvalue(struct var_decls_unitrec * p,int64 id);
int64 qc_lib_getrangelwb(struct var_decls_unitrec * p);
int64 qc_lib_getrangeupb(struct var_decls_unitrec * p);
struct var_decls_unitrec * qc_lib_getrangelwbunit(struct var_decls_unitrec * p);
struct var_decls_unitrec * qc_lib_getrangeupbunit(struct var_decls_unitrec * p);
int64 qc_lib_createarraymode(int64 target,int64 lower,int64 length,int64 typedefx);
byte * qc_lib_nextautotype(void);
int64 qc_lib_createstringmode(int64 t,int64 length,int64 typedefx);
int64 qc_lib_createrefpackmode(int64 target,int64 typedefx);
int64 qc_lib_getscope(struct var_decls_strec * p);
void qc_lib_setnameptr(struct var_decls_unitrec * p);
void qc_lib_printcode_all(void * f,byte * caption);
void qc_lib_printcode(void * f,byte * caption,int64 n);
void qc_lib_printunit(void * dev,struct var_decls_unitrec * p,int64 level,byte * prefix);
static void qc_lib_printunitlist(void * dev,struct var_decls_unitrec * p,int64 level,byte * prefix);
static byte * qc_lib_getprefix(int64 level,byte * prefix,struct var_decls_unitrec * p);
byte * qc_lib_getdottedname(struct var_decls_strec * p);
static byte * qc_lib_getlineinfok(void);
struct var_decls_strec * qc_lib_getavname(struct var_decls_strec * owner,int64 id);
void qc_lib_unionstr_clear(struct var_decls_uflagsrec * u);
void qc_lib_unionstr_append(struct var_decls_uflagsrec * u,int64 c);
void qc_lib_unionstr_concat(struct var_decls_uflagsrec * u,struct var_decls_uflagsrec * v);
int64 qc_lib_unionstr_last(struct var_decls_uflagsrec * u);
void qc_lib_unionstr_copy(struct var_decls_uflagsrec * u,struct var_decls_uflagsrec * v);
void qc_lib_unionstr_print(struct var_decls_uflagsrec * u);
int64 qc_lib_createrecordmode(struct var_decls_strec * owner,int64 t,int64 typedefx);
int64 qc_lib_createenummode(struct var_decls_strec * owner,int64 typedefx);
void qc_lib_convertstring(byte * s,byte * t);
struct mlib_strbuffer * qc_lib_strexpr(struct var_decls_unitrec * p);
static void qc_lib_jeval(struct mlib_strbuffer * dest,struct var_decls_unitrec * p);
byte * qc_lib_getopcjname(int64 opc);
byte * qc_lib_strmode(int64 m,int64 expand);
void qc_lib_istrmode(int64 m,int64 expand,byte * dest);
int64 qc_lib_countunits(struct var_decls_unitrec * p);
struct var_decls_strec * qc_lib_finddefstr(struct var_decls_strec * owner,byte * name);
static void qc_lib_purgesymbol(struct var_decls_strec * p,struct var_decls_strec * prev,int64 del);
void qc_lib_purgesymbollist(struct var_decls_strec * p,int64 ismodule,int64 del);
void qc_lib_purgeprocs(struct var_decls_strec * p,int64 del);
void qc_lib_purgeproc(struct var_decls_strec * p,int64 del);
void qc_lib_printmodelist(void * f);
void qc_lib_printgenfieldtable(void * f,byte * caption);
void qc_lib_addtoproclist(struct var_decls_strec * d);
struct var_decls_strec * qc_parselib_px_typecheck(struct var_decls_strec * owner,struct var_decls_strec * stname,int64 add);
struct var_decls_strec * qc_parselib_resolvetopname(struct var_decls_strec * owner,struct var_decls_strec * stnewname,int64 fmodule);
void qc_parselib_px_name(struct var_decls_strec * stmod,struct var_decls_strec * stproc,struct var_decls_unitrec * p,int64 fmodule);
void qc_parselib_evalbinop(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_parselib_evalbinop_real(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_parselib_makenewconst(struct var_decls_unitrec * p,int64 value,int64 t);
struct var_decls_strec * qc_parselib_finddupl(struct var_decls_strec * owner,struct var_decls_strec * lst);
void qc_parselib_px_dot(struct var_decls_strec * stmod,struct var_decls_strec * stproc,struct var_decls_unitrec * p);
void qc_parselib_evalmonop(struct var_decls_unitrec * p);
int64 qc_parselib_checkdict(struct var_decls_unitrec * p);
void qc_parselib_checkconstlist(struct var_decls_unitrec * p);
static void qc_pclgen_do_tag(struct var_decls_unitrec * p);
int64 qc_pclgen_codegen(int64 n);
void qc_pclgen_convertalltypes(void);
static void qc_pclgen_scanidata(struct var_decls_strec * p);
static void qc_pclgen_genidata(struct var_decls_strec * p);
static void qc_pclgen_initgenpcl(int64 sourcelen);
void qc_pclgen_doprogramstartup(void);
static void qc_pclgen_do_block(struct var_decls_unitrec * p);
static void qc_pclgen_do_print(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_fprint(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c);
static void qc_pclgen_do_read(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_assign(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_to(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c);
static void qc_pclgen_do_while(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c);
static void qc_pclgen_do_repeat(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_forstep(struct var_decls_unitrec * p,struct var_decls_unitrec * pvar,struct var_decls_unitrec * pbody,struct var_decls_unitrec * pautovar);
static void qc_pclgen_do_forall(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pbody,struct var_decls_unitrec * pautovar);
static void qc_pclgen_do_do(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_cfor(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_if(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * pelse);
static void qc_pclgen_do_longif(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_callproc(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_callhostproc(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_return(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_genstartproc(struct var_decls_strec * dmodule);
static void qc_pclgen_do_procdef(struct var_decls_strec * p);
static void qc_pclgen_genprocentry(struct var_decls_strec * p,int64 * nfreevars,int64 * nnofreevars);
static void qc_pclgen_genprocexit(int64 nfree,int64 nnofree);
static void qc_pclgen_do_preincr(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_exit(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_goto(struct var_decls_unitrec * p,struct var_decls_unitrec * a);
static void qc_pclgen_do_switch(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse);
static void qc_pclgen_do_simpleswitch(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse,int64 a,int64 b);
static void qc_pclgen_do_case(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse);
static void qc_pclgen_do_try(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_applyop(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c);
static void qc_pclgen_evalref(struct var_decls_unitrec * p);
static int64 qc_pclgen_getpclop(int64 opc);
static void qc_pclgen_genjumpl(int64 lab);
static int64 qc_pclgen_definelabel(void);
static int64 qc_pclgen_createfwdlabel(void);
static void qc_pclgen_definefwdlabel(int64 * oldlab);
static void qc_pclgen_stacklooplabels(int64 * a,int64 * b,int64 * c,int64 * d);
static void qc_pclgen_unstacklooplabels(void);
static int64 qc_pclgen_findlooplabel(int64 k,int64 n);
static int64 qc_pclgen_issimpleparam(struct var_decls_unitrec * p);
static void qc_pclgen_genjumpcond(int64 opc,struct var_decls_unitrec * p,int64 lab);
static void qc_pclgen_gcomparejump(int64 jumpopc,struct var_decls_unitrec * p,struct var_decls_unitrec * lhs,struct var_decls_unitrec * rhs,int64 lab);
static int64 qc_pclgen_reversecond(int64 op);
static void qc_pclgen_do_convert(int64 m,struct var_decls_unitrec * p);
static void qc_pclgen_do_selectx(struct var_decls_unitrec * pindex,struct var_decls_unitrec * pplist,struct var_decls_unitrec * pelse);
static void qc_pclgen_do_calldll(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static int64 qc_pclgen_islogical(struct var_decls_unitrec * p);
static void qc_pclgen_do_and(struct var_decls_unitrec * x,struct var_decls_unitrec * y);
static void qc_pclgen_do_or(struct var_decls_unitrec * x,struct var_decls_unitrec * y);
static void qc_pclgen_do_callptr(struct var_decls_unitrec * p,struct var_decls_unitrec * pproc,struct var_decls_unitrec * pparams);
static void qc_pclgen_do_callmproc(struct var_decls_unitrec * p,struct var_decls_unitrec * pproc,struct var_decls_unitrec * pparams,int64 calledasfn);
static int64 qc_pclgen_checkblockreturn(struct var_decls_unitrec * p);
static void qc_pclgen_genfree(int64 n);
static void qc_pclgen_do_clamp(struct var_decls_unitrec * x,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_applyopx(struct var_decls_unitrec * x,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_do_calldllvar(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static void qc_pclgen_callhostfn(int64 fnindex,int64 calledasfn);
static void qc_pclgen_extractparams(struct var_decls_strec * d,struct var_decls_strec * (*params)[]);
static int64 qc_pclgen_unitstoarray(struct var_decls_unitrec * p,struct var_decls_unitrec * (*plist)[],int64 maxunits);
static void qc_pclgen_do_idiv(struct var_decls_unitrec * a,struct var_decls_unitrec * b);
static int64 qc_pclgen_ispoweroftwo(int64 x);
static void qc_pclgen_genpushint(uint64 a);
static struct var_decls_unitrec * qc_pclgen_checkeqeq(struct var_decls_unitrec * p);
void qc_pcllib_initpcl(int64 size);
void qc_pcllib_initpcldata(void);
void qc_pcllib_initpclgen(void);
static void qc_pcllib_writepcl3(int64 pc);
static byte * qc_pcllib_writepclopnd3(int64 fmt,int64 x,int64 n,int64 cmdcode);
struct mlib_strbuffer * qc_pcllib_writepccode(byte * caption,int64 n);
void qc_pcllib_genpc(int64 opc);
void qc_pcllib_genopnd_int(int64 x);
void qc_pcllib_genopnd_s(struct var_decls_strec * d);
void qc_pcllib_genpc_int(int64 opc,int64 a);
void qc_pcllib_genpc_int2(int64 opc,int64 a,int64 b);
void qc_pcllib_genpc_int4(int64 opc,int64 a,int64 b,int64 c,int64 d);
void qc_pcllib_genpc_s(int64 opc,struct var_decls_strec * d);
void qc_pcllib_genpc_str(int64 opc,byte * s,int64 length);
void qc_pcllib_genopnd_str(byte * s,int64 length);
void qc_pcllib_genpc_lab(int64 opc,int64 a);
int64 qc_pcllib_isframe_s(struct var_decls_strec * p);
void qc_pcllib_converttype(int64 m);
static int64 qc_pcllib_scanstruct(int64 fstruct,struct var_decls_strec * (*flist)[],int64 flistlen,int64 * index,int64 nextoffset,int64 countmode);
static int64 qc_pcllib_scanrecord(struct var_decls_strec * (*flist)[],int64 flistlen);
static void qc_pcllib_shiftflagsleft(struct var_decls_uflagsrec * flags);
static void qc_pcllib_gstest(int64 id);
int64 qc_pcllib_addstringtotable(byte * s,int64 length);
byte * q_libs_getintlib(byte * name);

/* VARS */
static int64 pc_floadpc = (int64)0;
static int64 pc_fshowlog = (int64)0;
static int64 pc_fruncode = (int64)0;
static int64 pc_fshowtimes = (int64)0;
static int64 pc_fshowfixedup = (int64)0;
static int64 pc_logdest = (int64)0;
static int64 pc_dopause = (int64)0;
static byte *  pc_packexeptr;
static int64 pc_packexesize;
static byte *  pc_packfilename;
static int64 pc_packfilesize;
static byte *  pc_packfileptr;
static int64 pc_totalpclopcodes = (int64)0;
static int64 pc_totallines = (int64)0;
static int64 pc_nstringobjects = (int64)0;
static int64 pc_parse_tx;
static int64 pc_sttree_tx;
static int64 pc_stflat_tx;
static int64 pc_last_tx;
static int64 pc_pclcode_tx;
static int64 pc_genfields_tx;
static int64 *  pc_txpos = &pc_pclcode_tx;
static int64 pc_clockstart;
static int64 pc_modulelevel;
static int64 pc_dispatch_type = (int64)5;
static void *  pc_handlertable[217] =     {
    0,
    (void *)(&pc_khandlers_k_nop),
    (void *)(&pc_khandlers_k_procstart),
    (void *)(&pc_khandlers_k_procend),
    (void *)(&pc_khandlers_k_endmodule),
    (void *)(&pc_khandlers_k_push_m),
    (void *)(&pc_khandlers_k_push_f),
    (void *)(&pc_khandlers_k_push_am),
    (void *)(&pc_khandlers_k_push_af),
    (void *)(&pc_khandlers_k_push_ap),
    (void *)(&pc_khandlers_k_push_al),
    (void *)(&pc_khandlers_k_push_ci),
    (void *)(&pc_khandlers_k_push_cw),
    (void *)(&pc_khandlers_k_push_cr),
    (void *)(&pc_khandlers_k_push_cn),
    (void *)(&pc_khandlers_k_push_cs),
    (void *)(&pc_khandlers_k_push_t),
    (void *)(&pc_khandlers_k_push_op),
    (void *)(&pc_khandlers_k_pushz),
    (void *)(&pc_khandlers_k_pushz_void),
    (void *)(&pc_khandlers_k_pushz_str),
    (void *)(&pc_khandlers_k_pushz_list),
    (void *)(&pc_khandlers_k_pushz_listl),
    (void *)(&pc_khandlers_k_pushz_set),
    (void *)(&pc_khandlers_k_pushz_arrayl),
    (void *)(&pc_khandlers_k_pop_m),
    (void *)(&pc_khandlers_k_pop_f),
    (void *)(&pc_khandlers_k_store_m),
    (void *)(&pc_khandlers_k_store_f),
    (void *)(&pc_khandlers_k_pushptr),
    (void *)(&pc_khandlers_k_popptr),
    (void *)(&pc_khandlers_k_storeptr),
    (void *)(&pc_khandlers_k_zpop_m),
    (void *)(&pc_khandlers_k_zpop_f),
    (void *)(&pc_khandlers_k_zstore_m),
    (void *)(&pc_khandlers_k_zstore_f),
    (void *)(&pc_khandlers_k_copy),
    (void *)(&pc_khandlers_k_swap),
    (void *)(&pc_khandlers_k_convptr),
    (void *)(&pc_khandlers_k_jump),
    (void *)(&pc_khandlers_k_jumpptr),
    (void *)(&pc_khandlers_k_jumptrue),
    (void *)(&pc_khandlers_k_jumpfalse),
    (void *)(&pc_khandlers_k_jumpdef),
    (void *)(&pc_khandlers_k_jumpvoid),
    (void *)(&pc_khandlers_k_jumpeq),
    (void *)(&pc_khandlers_k_jumpne),
    (void *)(&pc_khandlers_k_jumplt),
    (void *)(&pc_khandlers_k_jumple),
    (void *)(&pc_khandlers_k_jumpge),
    (void *)(&pc_khandlers_k_jumpgt),
    (void *)(&pc_khandlers_k_jumptesteq),
    (void *)(&pc_khandlers_k_jumptestne),
    (void *)(&pc_khandlers_k_jumplabel),
    (void *)(&pc_khandlers_k_jumpclabel),
    (void *)(&pc_khandlers_k_switch),
    (void *)(&pc_khandlers_k_cswitch),
    (void *)(&pc_khandlers_k_new),
    (void *)(&pc_khandlers_k_to_f),
    (void *)(&pc_khandlers_k_for_fci),
    (void *)(&pc_khandlers_k_for_ff),
    (void *)(&pc_khandlers_k_ford_fci),
    (void *)(&pc_khandlers_k_ford_ff),
    (void *)(&pc_khandlers_k_call),
    (void *)(&pc_khandlers_k_callptr),
    (void *)(&pc_khandlers_k_return),
    (void *)(&pc_khandlers_k_startdll),
    (void *)(&pc_khandlers_k_pushdll),
    (void *)(&pc_khandlers_k_calldll),
    (void *)(&pc_khandlers_k_callhost),
    (void *)(&pc_khandlers_k_stackframe),
    (void *)(&pc_khandlers_k_free),
    (void *)(&pc_khandlers_k_addsp),
    (void *)(&pc_khandlers_k_stop),
    (void *)(&pc_khandlers_k_test),
    (void *)(&pc_khandlers_k_makelist),
    (void *)(&pc_khandlers_k_makerecord),
    (void *)(&pc_khandlers_k_makearray),
    (void *)(&pc_khandlers_k_makestruct),
    (void *)(&pc_khandlers_k_makeset),
    (void *)(&pc_khandlers_k_makerange),
    (void *)(&pc_khandlers_k_makedict),
    (void *)(&pc_khandlers_k_pushdot),
    (void *)(&pc_khandlers_k_pushdotref),
    (void *)(&pc_khandlers_k_softconv),
    (void *)(&pc_khandlers_k_hardconv),
    (void *)(&pc_khandlers_k_mixed),
    (void *)(&pc_khandlers_k_incrptr),
    (void *)(&pc_khandlers_k_incrto_m),
    (void *)(&pc_khandlers_k_incrto_f),
    (void *)(&pc_khandlers_k_loadincr),
    (void *)(&pc_khandlers_k_incrload),
    (void *)(&pc_khandlers_k_decrptr),
    (void *)(&pc_khandlers_k_decrto_m),
    (void *)(&pc_khandlers_k_decrto_f),
    (void *)(&pc_khandlers_k_loaddecr),
    (void *)(&pc_khandlers_k_decrload),
    (void *)(&pc_khandlers_k_incr),
    (void *)(&pc_khandlers_k_decr),
    (void *)(&pc_khandlers_k_neg),
    (void *)(&pc_khandlers_k_abs),
    (void *)(&pc_khandlers_k_not),
    (void *)(&pc_khandlers_k_inot),
    (void *)(&pc_khandlers_k_istrue),
    (void *)(&pc_khandlers_k_asc),
    (void *)(&pc_khandlers_k_chr),
    (void *)(&pc_khandlers_k_sqrt),
    (void *)(&pc_khandlers_k_sqr),
    (void *)(&pc_khandlers_k_cube),
    (void *)(&pc_khandlers_k_sin),
    (void *)(&pc_khandlers_k_cos),
    (void *)(&pc_khandlers_k_tan),
    (void *)(&pc_khandlers_k_asin),
    (void *)(&pc_khandlers_k_acos),
    (void *)(&pc_khandlers_k_atan),
    (void *)(&pc_khandlers_k_sign),
    (void *)(&pc_khandlers_k_ln),
    (void *)(&pc_khandlers_k_log),
    (void *)(&pc_khandlers_k_lg),
    (void *)(&pc_khandlers_k_exp),
    (void *)(&pc_khandlers_k_round),
    (void *)(&pc_khandlers_k_floor),
    (void *)(&pc_khandlers_k_ceil),
    (void *)(&pc_khandlers_k_fract),
    (void *)(&pc_khandlers_k_negto),
    (void *)(&pc_khandlers_k_absto),
    (void *)(&pc_khandlers_k_notto),
    (void *)(&pc_khandlers_k_inotto),
    (void *)(&pc_khandlers_k_len),
    (void *)(&pc_khandlers_k_lwb),
    (void *)(&pc_khandlers_k_upb),
    (void *)(&pc_khandlers_k_bounds),
    (void *)(&pc_khandlers_k_bits),
    (void *)(&pc_khandlers_k_bytes),
    (void *)(&pc_khandlers_k_type),
    (void *)(&pc_khandlers_k_elemtype),
    (void *)(&pc_khandlers_k_basetype),
    (void *)(&pc_khandlers_k_minval),
    (void *)(&pc_khandlers_k_maxval),
    (void *)(&pc_khandlers_k_isint),
    (void *)(&pc_khandlers_k_isreal),
    (void *)(&pc_khandlers_k_isstring),
    (void *)(&pc_khandlers_k_isrange),
    (void *)(&pc_khandlers_k_isnumber),
    (void *)(&pc_khandlers_k_isarray),
    (void *)(&pc_khandlers_k_isrecord),
    (void *)(&pc_khandlers_k_ispointer),
    (void *)(&pc_khandlers_k_ismutable),
    (void *)(&pc_khandlers_k_isset),
    (void *)(&pc_khandlers_k_isvoid),
    (void *)(&pc_khandlers_k_isdef),
    (void *)(&pc_khandlers_k_tostr),
    (void *)(&pc_khandlers_k_isequal),
    (void *)(&pc_khandlers_k_add),
    (void *)(&pc_khandlers_k_sub),
    (void *)(&pc_khandlers_k_mul),
    (void *)(&pc_khandlers_k_div),
    (void *)(&pc_khandlers_k_idiv),
    (void *)(&pc_khandlers_k_rem),
    (void *)(&pc_khandlers_k_divrem),
    (void *)(&pc_khandlers_k_iand),
    (void *)(&pc_khandlers_k_ior),
    (void *)(&pc_khandlers_k_ixor),
    (void *)(&pc_khandlers_k_shl),
    (void *)(&pc_khandlers_k_shr),
    (void *)(&pc_khandlers_k_in),
    (void *)(&pc_khandlers_k_notin),
    (void *)(&pc_khandlers_k_inrev),
    (void *)(&pc_khandlers_k_eq),
    (void *)(&pc_khandlers_k_ne),
    (void *)(&pc_khandlers_k_lt),
    (void *)(&pc_khandlers_k_le),
    (void *)(&pc_khandlers_k_ge),
    (void *)(&pc_khandlers_k_gt),
    (void *)(&pc_khandlers_k_min),
    (void *)(&pc_khandlers_k_max),
    (void *)(&pc_khandlers_k_concat),
    (void *)(&pc_khandlers_k_append),
    (void *)(&pc_khandlers_k_power),
    (void *)(&pc_khandlers_k_atan2),
    (void *)(&pc_khandlers_k_addto),
    (void *)(&pc_khandlers_k_subto),
    (void *)(&pc_khandlers_k_multo),
    (void *)(&pc_khandlers_k_divto),
    (void *)(&pc_khandlers_k_idivto),
    (void *)(&pc_khandlers_k_iandto),
    (void *)(&pc_khandlers_k_iorto),
    (void *)(&pc_khandlers_k_ixorto),
    (void *)(&pc_khandlers_k_shlto),
    (void *)(&pc_khandlers_k_shrto),
    (void *)(&pc_khandlers_k_minto),
    (void *)(&pc_khandlers_k_maxto),
    (void *)(&pc_khandlers_k_concatto),
    (void *)(&pc_khandlers_k_appendto),
    (void *)(&pc_khandlers_k_pushix),
    (void *)(&pc_khandlers_k_pushdotix),
    (void *)(&pc_khandlers_k_pushkeyix),
    (void *)(&pc_khandlers_k_pushkeyixd),
    (void *)(&pc_khandlers_k_pushixref),
    (void *)(&pc_khandlers_k_pushdotixref),
    (void *)(&pc_khandlers_k_pushkeyixref),
    (void *)(&pc_khandlers_k_pushbyteix),
    (void *)(&pc_khandlers_k_pushbyteixref),
    (void *)(&pc_khandlers_k_appendset),
    (void *)(&pc_khandlers_k_pushdotm),
    (void *)(&pc_khandlers_k_pushdott),
    (void *)(&pc_khandlers_k_push_ad),
    (void *)(&pc_khandlers_k_push_try),
    (void *)(&pc_khandlers_k_raise),
    (void *)(&pc_khandlers_k_applyop),
    (void *)(&pc_khandlers_k_makeiter),
    (void *)(&pc_khandlers_k_forall),
    (void *)(&pc_khandlers_k_forallx),
    (void *)(&pc_khandlers_k_foreach),
    (void *)(&pc_khandlers_k_foreachx),
    (void *)(&pc_khandlers_k_expandrange),
    0
};
static void *  msysc__fnaddresses[]= {
    &start,
    &pc_initlogfile,
    &pc_closelogfile,
    &pc_initdata,
    &pc_getinputfile,
    &pc_showpcl,
    &pc_showgenfields,
    &pc_do_showprogdiags_pc,
    &pc_runcode,
    &pc_initbytecode,
    &pc_disploop,
    &pc_pclinit,
    &pc_fixup_all_pc,
    &pc_fixup_module_pc,
    &pc_disploop_fn,
    &pc_disploop_deb,
    &pc_getsyscmdline,
    &pc_showmodules,
    &pc_starttiming,
    &pc_showtiming,
    &pc_runproc,
    &pc_showinttiming,
    &pc_allocatestrings,
    &pc_loadprogram,
    &pc_loadpcfile,
    &pc_initpcldata,
    &pc_createstentry,
    &pc_findnewestfile,
    &pc_showcaption,
    &pc_getprocaddr,
    &pc_getfileint,
    &pc_checkpackfile,
    &pc_pcl_initusertypes,
    &msysc_m_getdotindex,
    &msysc_m_setdotindex,
    &msysc_m_getdotslice,
    &msysc_m_setdotslice,
    &msysc_m_getnprocs,
    &msysc_m_getprocaddr,
    &msysc_m_getprocname,
    &msysc_m_imin,
    &msysc_m_imax,
    &mlib_pcm_alloc,
    &mlib_pcm_free,
    &mlib_pcm_freeac,
    &mlib_pcm_copymem4,
    &mlib_pcm_clearmem,
    &mlib_pcm_init,
    &mlib_pcm_getac,
    &mlib_pcm_newblock,
    &mlib_pcm_round,
    &mlib_pcm_array,
    &mlib_pcm_printfreelist,
    &mlib_pcm_diags,
    &mlib_pcm_allocz,
    &mlib_pcm_copyheapstring,
    &mlib_addtomemalloc,
    &mlib_removefrommemalloc,
    &mlib_allocmem,
    &mlib_reallocmem,
    &mlib_abortprogram,
    &mlib_getfilesize,
    &mlib_readrandom,
    &mlib_writerandom,
    &mlib_readfile,
    &mlib_writefile,
    &mlib_checkfile,
    &mlib_readlinen,
    &mlib_iconvlcn,
    &mlib_iconvucn,
    &mlib_convlcstring,
    &mlib_convucstring,
    &mlib_changeext,
    &mlib_extractext,
    &mlib_extractpath,
    &mlib_extractfile,
    &mlib_extractbasefile,
    &mlib_addext,
    &mlib_alloctable,
    &mlib_zalloctable,
    &mlib_checkfreelists,
    &mlib_pcm_alloc32,
    &mlib_pcm_free32,
    &mlib_outbyte,
    &mlib_outword16,
    &mlib_outword,
    &mlib_outword64,
    &mlib_myeof,
    &mlib_pcm_smallallocz,
    &mlib_pcm_smallalloc,
    &mlib_strbuffer_add,
    &mlib_gs_init,
    &mlib_gs_free,
    &mlib_gs_str,
    &mlib_gs_char,
    &mlib_gs_strn,
    &mlib_gs_strvar,
    &mlib_gs_strint,
    &mlib_gs_strln,
    &mlib_gs_strsp,
    &mlib_gs_line,
    &mlib_gs_getcol,
    &mlib_gs_leftstr,
    &mlib_gs_leftint,
    &mlib_gs_padto,
    &mlib_gs_println,
    &mlib_nextcmdparam,
    &mlib_readnextfileitem,
    &mlib_ipadstr,
    &mlib_padstr,
    &mlib_chr,
    &mlib_cmpstring,
    &mlib_cmpstringn,
    &mlib_eqstring,
    &mlib_cmpbytes,
    &mlib_eqbytes,
    &osnos_os_init,
    &osnos_os_execwait,
    &osnos_os_execcmd,
    &osnos_os_getch,
    &osnos_os_kbhit,
    &osnos_os_flushkeys,
    &osnos_os_getconsolein,
    &osnos_os_getconsoleout,
    &osnos_os_proginstance,
    &osnos_os_getdllinst,
    &osnos_os_getdllprocaddr,
    &osnos_os_initwindows,
    &osnos_os_getchx,
    &osnos_os_getos,
    &osnos_os_getoscode,
    &osnos_os_iswindows,
    &osnos_os_shellexec,
    &osnos_os_sleep,
    &osnos_os_getstdin,
    &osnos_os_getstdout,
    &osnos_os_gethostname,
    &osnos_os_gethostsize,
    &osnos_os_getmpath,
    &osnos_os_exitprocess,
    &osnos_os_gettimestamp,
    &osnos_os_gettickcount,
    &osnos_os_clock,
    &osnos_os_getclockspersec,
    &osnos_os_setmesshandler,
    &osnos_os_filelastwritetime,
    &osnos_os_hpcounter,
    &osnos_os_hpfrequency,
    &osnos_os_getsystime,
    &osnos_os_peek,
    &pc_support_prterror,
    &pc_support_testelem,
    &pc_support_setelem,
    &pc_support_pcustype_def,
    &pc_support_pcustype,
    &pc_support_pcustypet,
    &pc_support_pcmxtypes_def,
    &pc_support_pcmxtypes,
    &pc_support_pcmxtypestt,
    &pc_support_gettypename,
    &pc_support_inittypetables,
    &pc_support_pcerror,
    &pc_support_vxunimpl,
    &pc_support_pclunimpl,
    &pc_support_convcstring,
    &pc_support_getintvalue,
    &pc_support_nextpoweroftwo,
    &pc_support_showlinenumber,
    &pc_support_printlinenumber,
    &pc_support_findlinenumber,
    &pc_support_findpcindex,
    &pc_support_showlinetable,
    &pc_support_writezstring,
    &pc_support_writezint,
    &pc_support_writezint4,
    &pc_support_writezrange,
    &pc_support_writezreal,
    &pc_support_writezeof,
    &pc_support_zerror,
    &pc_support_readzvalue,
    &pc_support_readzint,
    &pc_support_readzdint,
    &pc_support_readzreal,
    &pc_support_readzstring,
    &pc_support_readzblock,
    &pc_support_checkmt,
    &pc_support_ipower,
    &pc_support_loaderror,
    &pc_support_gettypesig,
    &pc_support_getfnname,
    &pc_support_junimpl,
    &pc_misc_raiseexception,
    &pc_misc_raise_error,
    &pc_misc_default_exception,
    &pc_pcfns_pc_ufree,
    &pc_pcfns_pc_cfree,
    &pc_pcfns_pc_ufreex,
    &pc_pcfns_pc_freeref,
    &pc_pcfns_pc_cshare,
    &pc_pcfns_pc_ushare,
    &pc_pcfns_pc_dupl,
    &pc_pcfns_j_free_s,
    &pc_pcfns_j_free_l_m_d,
    &pc_pcfns_j_free_k,
    &pc_pcfns_j_free_a_j,
    &pc_pcfns_j_free_b_e,
    &pc_pcfns_j_dupl_s,
    &pc_pcfns_j_dupl_l_m_d,
    &pc_pcfns_j_dupl_a_j,
    &pc_pcfns_j_dupl_b,
    &pc_pcfns_j_dupl_e,
    &pc_pcfns_j_dupl_k,
    &pc_pcfns_pc_makelist,
    &pc_pcfns_pc_makerecord,
    &pc_pcfns_pc_makearray,
    &pc_pcfns_pc_makerange,
    &pc_pcfns_pc_makeset,
    &pc_pcfns_pc_makestruct,
    &pc_pcfns_pc_makedict,
    &pc_pcfns_pc_storepacked,
    &pc_pcfns_adddictitem,
    &pc_pcfns_finddictitem,
    &pc_pcfns_expanddict,
    &pc_pcfns_setfslength,
    &pc_pcfns_getfslength,
    &pc_pcfns_gethashvalue,
    &pc_pcfns_pc_storeptr,
    &pc_pcfns_pc_storebit,
    &pc_pcfns_pc_popptrlist,
    &pc_pcfns_pc_loadpacked,
    &pc_pcfns_pc_loadbit,
    &pc_pcfns_pc_loadptr,
    &pc_pcfns_pc_storestring,
    &pc_pcfns_pc_iconvert,
    &pc_pcfns_pc_iconvcase,
    &pc_pcfns_pc_eqstring_nf,
    &pc_pcfns_pc_equal_nf,
    &pc_pcfns_comparebytes,
    &pc_pcfns_pc_compare_nf,
    &pc_pcfns_cmpstringlen,
    &pc_pcfns_pc_eqstring,
    &pc_pcfns_pc_equal,
    &pc_pcfns_pc_compare,
    &pc_pcfns_u8inarray,
    &pc_pcfns_u16inarray,
    &pc_pcfns_u32inarray,
    &pc_pcfns_u64inarray,
    &pc_pcfns_bitinbits,
    &pc_pcfns_pc_strinstr,
    &pc_pcfns_getbitoffset,
    &pc_pcfns_pc_iappendlist,
    &pc_pcfns_pc_iappendarray,
    &pc_pcfns_pc_mul_listi,
    &pc_pcfns_pc_mul_stri,
    &pc_pcfns_pc_duplvar,
    &pc_pcfns_pc_iconcatlist,
    &pc_pcfns_pc_iappendbits,
    &pc_pcfns_pc_makestring,
    &pc_pcfns_pc_makestringx,
    &pc_pcfns_pc_makestringn,
    &pc_pcfns_pc_emptystring,
    &pc_pcfns_pc_makechar,
    &pc_objects_newobject,
    &pc_objects_freeobject,
    &pc_objects_addref_obj,
    &pc_objects_makezobjects,
    &pc_objects_make_listdata,
    &pc_objects_free_listdata,
    &pc_objects_make_arraydata,
    &pc_objects_free_arraydata,
    &pc_objects_make_bitdata,
    &pc_objects_free_bitdata,
    &pc_objects_make_listobj,
    &pc_objects_make_arrayobj,
    &pc_objects_make_setobj,
    &pc_objects_make_bitsobj,
    &pc_objects_resize_listobj,
    &pc_objects_resize_arrayobj,
    &pc_objects_resize_bitsobj,
    &pc_objects_make_strslicexobj,
    &pc_objects_copyonwrite,
    &pc_objects_get_objbytes,
    &pc_bigint_bn_makestr,
    &pc_bigint_bn_makeint,
    &pc_bigint_bn_makeu,
    &pc_bigint_bn_makeu_base,
    &pc_bigint_strvaln,
    &pc_bigint_makebigint,
    &pc_bigint_freebigint,
    &pc_bigint_bn_neg,
    &pc_bigint_bn_abs,
    &pc_bigint_bn_add,
    &pc_bigint_bn_addu,
    &pc_bigint_bn_sub,
    &pc_bigint_bn_subu,
    &pc_bigint_bn_mul,
    &pc_bigint_muldigit,
    &pc_bigint_bn_zero,
    &pc_bigint_bn_mulu,
    &pc_bigint_bn_div,
    &pc_bigint_bn_divu,
    &pc_bigint_bn_equal,
    &pc_bigint_bn_cmp,
    &pc_bigint_bn_int,
    &pc_bigint_bn_digits,
    &pc_bigint_bn_power,
    &pc_bigint_bn_reduce,
    &pc_print_pch_print,
    &pc_print_pch_println,
    &pc_print_pch_startprintcon,
    &pc_print_pch_startprint,
    &pc_print_pch_endprint,
    &pc_print_pch_strstartprint,
    &pc_print_pch_strendprint,
    &pc_print_pch_setformat,
    &pc_print_pch_setformat2,
    &pc_print_pch_dprint,
    &pc_print_pch_printnogap,
    &pc_print_initfmtcode,
    &pc_print_i64mintostr,
    &pc_print_u64tostr,
    &pc_print_i64tostrfmt,
    &pc_print_u64tostrfmt,
    &pc_print_strtostrfmt,
    &pc_print_expandstr,
    &pc_print_pc_strtofmt,
    &pc_print_printstrz,
    &pc_print_printstr_n,
    &pc_print_printerror,
    &pc_print_addstring,
    &pc_print_j_tostr_i,
    &pc_print_j_tostr_r,
    &pc_print_j_tostr_w,
    &pc_print_j_tostr_n,
    &pc_print_j_tostr_s,
    &pc_print_j_tostr_l,
    &pc_print_j_tostr_a,
    &pc_print_j_tostr_b,
    &pc_print_j_tostr_e,
    &pc_print_j_tostr_k,
    &pc_print_j_tostr_j,
    &pc_print_j_tostr_d,
    &pc_print_j_tostr_z,
    &pc_print_printnextfmtchars,
    &pc_print_getreadfmtcode,
    &pc_print_pch_sreadln,
    &pc_print_pch_strtoval,
    &pc_print_pch_reread,
    &pc_print_pch_rereadln,
    &pc_print_readname,
    &pc_print_readstring,
    &pc_print_readint,
    &pc_print_readhex,
    &pc_print_readbin,
    &pc_print_readreal,
    &pc_print_pch_readln,
    &pc_print_stepkbpos,
    &pc_print_pch_sread,
    &pc_print_domultichar,
    &pc_print_pch_tostr,
    &pc_print_pc_getfmt,
    &pc_print_pc_readlinen,
    &pc_print_readitem,
    &pc_print_readany,
    &pc_print_strtoreal,
    &pc_print_strtoint,
    &pc_print_calltostrtable,
    &pc_print_printbn,
    &pc_jhandlers_initcalltables,
    &pc_jhandlers_initjhandler,
    &pc_jhandlers_add_stable_entry,
    &pc_jhandlers_add_dtable_entry,
    &pc_jhandlers_def_handler,
    &pc_jhandlers_ddef_handler,
    &pc_jhandlers_j_add_i_w,
    &pc_jhandlers_j_add_r,
    &pc_jhandlers_j_add_s,
    &pc_jhandlers_j_add_j,
    &pc_jhandlers_j_add_e,
    &pc_jhandlers_j_add_z,
    &pc_jhandlers_j_add_iw_wi,
    &pc_jhandlers_j_add_zz,
    &pc_jhandlers_j_sub_i_w,
    &pc_jhandlers_j_sub_r,
    &pc_jhandlers_j_sub_p,
    &pc_jhandlers_j_sub_j,
    &pc_jhandlers_j_sub_e,
    &pc_jhandlers_j_sub_z,
    &pc_jhandlers_j_sub_zz,
    &pc_jhandlers_j_mixed_iw_wi,
    &pc_jhandlers_j_mixed_ir,
    &pc_jhandlers_j_mixed_ri,
    &pc_jhandlers_j_mixed_ij,
    &pc_jhandlers_j_mixed_ji,
    &pc_jhandlers_j_mul_i_w,
    &pc_jhandlers_j_mul_r,
    &pc_jhandlers_j_mul_j,
    &pc_jhandlers_j_mul_z,
    &pc_jhandlers_j_mul_li,
    &pc_jhandlers_j_mul_si,
    &pc_jhandlers_j_mul_e,
    &pc_jhandlers_j_mul_zz,
    &pc_jhandlers_j_div_i,
    &pc_jhandlers_j_div_r,
    &pc_jhandlers_j_div_z,
    &pc_jhandlers_j_jumple_i,
    &pc_jhandlers_j_jumple_r,
    &pc_jhandlers_j_jumple_s,
    &pc_jhandlers_j_jumple_z,
    &pc_jhandlers_j_jumpeq_i_r_t_o,
    &pc_jhandlers_j_jumpeq_v_p_f_g,
    &pc_jhandlers_j_jumpeq_s,
    &pc_jhandlers_j_jumpeq_z,
    &pc_jhandlers_j_jumpeq_zz,
    &pc_jhandlers_j_jumpne_i_r_t_o,
    &pc_jhandlers_j_jumpne_v_p_f_g,
    &pc_jhandlers_j_jumpne_s,
    &pc_jhandlers_j_jumpne_z,
    &pc_jhandlers_j_jumpne_zz,
    &pc_jhandlers_j_jumpge_i,
    &pc_jhandlers_j_jumpge_w,
    &pc_jhandlers_j_jumpge_r,
    &pc_jhandlers_j_jumpge_z,
    &pc_jhandlers_j_jumpgt_i,
    &pc_jhandlers_j_jumpgt_w,
    &pc_jhandlers_j_jumpgt_r,
    &pc_jhandlers_j_jumpgt_z,
    &pc_jhandlers_j_jumplt_i,
    &pc_jhandlers_j_jumplt_v_p,
    &pc_jhandlers_j_jumplt_r,
    &pc_jhandlers_j_jumplt_z,
    &pc_jhandlers_j_pushix_li_mi,
    &pc_jhandlers_j_pushix_vi,
    &pc_jhandlers_j_pushix_ln,
    &pc_jhandlers_j_pushix_ll,
    &pc_jhandlers_j_pushix_le,
    &pc_jhandlers_j_pushix_ai,
    &pc_jhandlers_j_pushix_bi_ei,
    &pc_jhandlers_j_pushix_an,
    &pc_jhandlers_j_pushix_si,
    &pc_jhandlers_j_pushix_sn,
    &pc_jhandlers_j_pushix_bn,
    &pc_jhandlers_j_pushix_di,
    &pc_jhandlers_j_pushix_zz,
    &pc_jhandlers_j_pushixref_li,
    &pc_jhandlers_j_pushixref_ln,
    &pc_jhandlers_j_pushixref_ai,
    &pc_jhandlers_j_pushixref_si,
    &pc_jhandlers_j_pushixref_bi_ei,
    &pc_jhandlers_j_pushixref_zz,
    &pc_jhandlers_j_pushdotix_si,
    &pc_jhandlers_j_pushdotix_sn,
    &pc_jhandlers_j_pushdotix_ii,
    &pc_jhandlers_j_pushdotix_in,
    &pc_jhandlers_j_pushdotix_ei,
    &pc_jhandlers_j_pushdotix_mi,
    &pc_jhandlers_j_pushdotix_zz,
    &pc_jhandlers_j_pushdotixref_si,
    &pc_jhandlers_j_pushdotixref_sn,
    &pc_jhandlers_j_pushdotixref_ii,
    &pc_jhandlers_j_pushdotixref_ei,
    &pc_jhandlers_j_pushdotixref_zz,
    &pc_jhandlers_j_addto_i,
    &pc_jhandlers_j_addto_r,
    &pc_jhandlers_j_addto_s,
    &pc_jhandlers_j_addto_p,
    &pc_jhandlers_j_addto_z,
    &pc_jhandlers_j_addto_si,
    &pc_jhandlers_j_addto_ir,
    &pc_jhandlers_j_addto_ri,
    &pc_jhandlers_j_addto_zz,
    &pc_jhandlers_j_subto_i,
    &pc_jhandlers_j_subto_r,
    &pc_jhandlers_j_subto_z,
    &pc_jhandlers_j_multo_i_w,
    &pc_jhandlers_j_multo_r,
    &pc_jhandlers_j_multo_z,
    &pc_jhandlers_j_divto_i_w,
    &pc_jhandlers_j_divto_r,
    &pc_jhandlers_j_divto_z,
    &pc_jhandlers_j_idivto_i,
    &pc_jhandlers_j_idivto_z,
    &pc_jhandlers_j_iand_i_w,
    &pc_jhandlers_j_iand_e,
    &pc_jhandlers_j_iand_z,
    &pc_jhandlers_j_ior_i_w,
    &pc_jhandlers_j_ior_e,
    &pc_jhandlers_j_ior_z,
    &pc_jhandlers_j_ixor_i_w,
    &pc_jhandlers_j_ixor_e,
    &pc_jhandlers_j_ixor_z,
    &pc_jhandlers_j_iandto_i_w,
    &pc_jhandlers_j_iandto_z,
    &pc_jhandlers_j_iorto_i_w,
    &pc_jhandlers_j_iorto_z,
    &pc_jhandlers_j_ixorto_i_w,
    &pc_jhandlers_j_ixorto_z,
    &pc_jhandlers_j_shlto_i,
    &pc_jhandlers_j_shlto_z,
    &pc_jhandlers_j_shrto_i,
    &pc_jhandlers_j_shrto_z,
    &pc_jhandlers_j_concat_s,
    &pc_jhandlers_j_concat_l,
    &pc_jhandlers_j_concat_z,
    &pc_jhandlers_j_concatto_s,
    &pc_jhandlers_j_concatto_l,
    &pc_jhandlers_j_concatto_z,
    &pc_jhandlers_j_append_s,
    &pc_jhandlers_j_append_l,
    &pc_jhandlers_j_append_a,
    &pc_jhandlers_j_append_b,
    &pc_jhandlers_j_append_z,
    &pc_jhandlers_j_appendto_s,
    &pc_jhandlers_j_appendto_l,
    &pc_jhandlers_j_appendto_a,
    &pc_jhandlers_j_appendto_b_e,
    &pc_jhandlers_j_appendto_z,
    &pc_jhandlers_j_max_i,
    &pc_jhandlers_j_max_r,
    &pc_jhandlers_j_max_z,
    &pc_jhandlers_j_min_z,
    &pc_jhandlers_j_len_l_a_e_s_b_m_k_d,
    &pc_jhandlers_j_len_n,
    &pc_jhandlers_j_len_z,
    &pc_jhandlers_j_lwb_l_a_b,
    &pc_jhandlers_j_lwb_s_m_k_d,
    &pc_jhandlers_j_lwb_e,
    &pc_jhandlers_j_lwb_n,
    &pc_jhandlers_j_lwb_z,
    &pc_jhandlers_j_upb_l_a_b,
    &pc_jhandlers_j_upb_s_m_k_d,
    &pc_jhandlers_j_upb_e,
    &pc_jhandlers_j_upb_n,
    &pc_jhandlers_j_upb_z,
    &pc_jhandlers_j_bounds_l_a_b_s_m_k_e,
    &pc_jhandlers_j_bounds_n,
    &pc_jhandlers_j_bounds_z,
    &pc_jhandlers_j_minto_i,
    &pc_jhandlers_j_minto_r,
    &pc_jhandlers_j_minto_z,
    &pc_jhandlers_j_maxto_i,
    &pc_jhandlers_j_maxto_r,
    &pc_jhandlers_j_maxto_z,
    &pc_jhandlers_j_neg_i_w,
    &pc_jhandlers_j_neg_r,
    &pc_jhandlers_j_neg_j,
    &pc_jhandlers_j_neg_e,
    &pc_jhandlers_j_neg_z,
    &pc_jhandlers_j_abs_i_w,
    &pc_jhandlers_j_abs_r,
    &pc_jhandlers_j_abs_j,
    &pc_jhandlers_j_abs_z,
    &pc_jhandlers_j_inot_i_w,
    &pc_jhandlers_j_inot_e,
    &pc_jhandlers_j_inot_z,
    &pc_jhandlers_j_istrue_i_w_r,
    &pc_jhandlers_j_istrue_l_a_e_s_b,
    &pc_jhandlers_j_istrue_k_m_h,
    &pc_jhandlers_j_istrue_j,
    &pc_jhandlers_j_istrue_z,
    &pc_jhandlers_j_jumpfalse_i_w_r_v_p_f,
    &pc_jhandlers_j_jumpfalse_s_l_e_a_b,
    &pc_jhandlers_j_jumpfalse_z,
    &pc_jhandlers_j_jumptrue_i_r_w_v_p_f,
    &pc_jhandlers_j_jumptrue_s_l_e_a_b,
    &pc_jhandlers_j_jumptrue_z,
    &pc_jhandlers_j_shl_i_w,
    &pc_jhandlers_j_shl_z,
    &pc_jhandlers_j_shr_i,
    &pc_jhandlers_j_shr_z,
    &pc_jhandlers_j_shr_wi,
    &pc_jhandlers_j_shr_zz,
    &pc_jhandlers_j_idiv_i_w,
    &pc_jhandlers_j_idiv_j,
    &pc_jhandlers_j_idiv_z,
    &pc_oslayer_runproc_m,
    &pc_oslayer_os_getconsize,
    &pc_oslayer_pch_setmesshandler,
    &pc_oslayer_pch_gethostname,
    &pc_oslayer_os_initdllmodules,
    &pc_oslayer_os_loaddllmodule,
    &pc_oslayer_os_initdllfunctions,
    &pc_oslayer_os_loaddllfunction,
    &pc_oslayer_pch_getos,
    &pc_oslayer_pch_gethostsize,
    &pc_oslayer_pch_iswindows,
    &pc_oslayer_os_calldll,
    &pc_oslayer_calldll_mint,
    &pc_oslayer_calldll_mreal,
    &pc_oslayer_calldll_cint,
    &pc_oslayer_calldll_creal,
    &osnosdll_os_calldll_wint,
    &osnosdll_os_calldll_wreal,
    &osnosdll_os_dummycall,
    &pc_host_callhostfunction,
    &pc_host_pch_leftstr,
    &pc_host_pch_rightstr,
    &pc_host_pch_convlc,
    &pc_host_pch_convuc,
    &pc_host_pch_iconvlc,
    &pc_host_pch_iconvuc,
    &pc_host_pch_stop,
    &pc_host_pch_stopx,
    &pc_host_pch_ismain,
    &pc_host_pch_waitkey,
    &pc_host_pch_testkey,
    &pc_host_pch_execwait,
    &pc_host_pch_execcmd,
    &pc_host_pch_makestr,
    &pc_host_pch_makestrslice,
    &pc_host_pch_makeref,
    &pc_host_pch_new,
    &pc_host_pch_newheap,
    &pc_host_pch_heapvar,
    &pc_host_pch_freeheap,
    &pc_host_pch_getcmdparam,
    &pc_host_pch_setpcerror,
    &pc_host_pch_setdebug,
    &pc_host_pch_setfprintf,
    &pc_host_pch_ticks,
    &pc_host_pch_sleep,
    &pc_host_pch_random,
    &pc_host_pch_findmetafunction,
    &pc_host_pch_loadpcl,
    &pc_host_pch_runpcl,
    &pc_host_pch_runtask,
    &pc_host_pch_callext,
    &pc_host_pch_system,
    &pc_host_pch_shellexec,
    &pc_host_pch_gethash,
    &pc_host_pch_test,
    &pc_host_pch_pcldata,
    &pc_host_pch_getcstring,
    &pc_host_pch_getparam,
    &pc_host_pch_clearlist,
    &pc_host_pch_makelink,
    &pc_host_pch_allparams,
    &pc_host_pch_stackvars,
    &pc_host_pch_makeempty,
    &pc_host_pch_readlines,
    &pc_host_pch_dictitems,
    &pc_host_pch_setoverload,
    &pc_host_pch_errorinfo,
    &pc_host_getbounds,
    &pc_host_checkparam,
    &pc_host_leftstring,
    &pc_host_rightstring,
    &pc_host_padstring_right,
    &pc_host_padstring_left,
    &pc_host_pcld_makevint,
    &pc_host_pcld_makelist,
    &pc_host_getproctabledata,
    &pc_host_convert_handler,
    &pc_host_addtoproclist,
    &pc_host_tostr_handler,
    &pc_host_addovrecord,
    &pc_dxfns_dx_iorset,
    &pc_dxfns_dx_iandset,
    &pc_dxfns_dx_ixorset,
    &pc_dxfns_dx_inotset,
    &pc_dxfns_dx_subset,
    &pc_dxfns_inotsetbits,
    &pc_dxfns_iorsetbits,
    &pc_dxfns_iandsetbits,
    &pc_dxfns_ixorsetbits,
    &pc_dxfns_subsetbits,
    &pc_dxfns_iresizeset,
    &pc_dxfns_dx_varinvar,
    &pc_dxfns_dx_mixed,
    &pc_dxfns_resize_stringobj,
    &pc_khandlers_k_zero,
    &pc_khandlers_k_nop,
    &pc_khandlers_k_procstart,
    &pc_khandlers_k_procend,
    &pc_khandlers_k_endmodule,
    &pc_khandlers_k_push_m,
    &pc_khandlers_k_push_f,
    &pc_khandlers_k_push_am,
    &pc_khandlers_k_push_af,
    &pc_khandlers_k_push_ap,
    &pc_khandlers_k_push_al,
    &pc_khandlers_k_push_ci,
    &pc_khandlers_k_push_cw,
    &pc_khandlers_k_push_cr,
    &pc_khandlers_k_push_cn,
    &pc_khandlers_k_push_cs,
    &pc_khandlers_k_push_t,
    &pc_khandlers_k_push_op,
    &pc_khandlers_k_pushz,
    &pc_khandlers_k_pushz_void,
    &pc_khandlers_k_pushz_str,
    &pc_khandlers_k_pushz_list,
    &pc_khandlers_k_pushz_listl,
    &pc_khandlers_k_pushz_set,
    &pc_khandlers_k_pushz_arrayl,
    &pc_khandlers_k_pop_m,
    &pc_khandlers_k_pop_f,
    &pc_khandlers_k_store_m,
    &pc_khandlers_k_store_f,
    &pc_khandlers_k_pushptr,
    &pc_khandlers_k_popptr,
    &pc_khandlers_k_storeptr,
    &pc_khandlers_k_zpop_m,
    &pc_khandlers_k_zpop_f,
    &pc_khandlers_k_zstore_m,
    &pc_khandlers_k_zstore_f,
    &pc_khandlers_k_copy,
    &pc_khandlers_k_swap,
    &pc_khandlers_k_convptr,
    &pc_khandlers_k_jump,
    &pc_khandlers_k_jumpptr,
    &pc_khandlers_k_jumptrue,
    &pc_khandlers_k_jumpfalse,
    &pc_khandlers_k_jumpdef,
    &pc_khandlers_k_jumpvoid,
    &pc_khandlers_k_jumpeq,
    &pc_khandlers_k_jumpne,
    &pc_khandlers_k_jumplt,
    &pc_khandlers_k_jumple,
    &pc_khandlers_k_jumpge,
    &pc_khandlers_k_jumpgt,
    &pc_khandlers_k_jumptesteq,
    &pc_khandlers_k_jumptestne,
    &pc_khandlers_k_jumplabel,
    &pc_khandlers_k_jumpclabel,
    &pc_khandlers_k_switch,
    &pc_khandlers_k_cswitch,
    &pc_khandlers_k_new,
    &pc_khandlers_k_to_f,
    &pc_khandlers_k_for_fci,
    &pc_khandlers_k_for_ff,
    &pc_khandlers_k_ford_fci,
    &pc_khandlers_k_ford_ff,
    &pc_khandlers_k_call,
    &pc_khandlers_k_callptr,
    &pc_khandlers_k_return,
    &pc_khandlers_k_startdll,
    &pc_khandlers_k_pushdll,
    &pc_khandlers_k_calldll,
    &pc_khandlers_k_callhost,
    &pc_khandlers_k_stackframe,
    &pc_khandlers_k_free,
    &pc_khandlers_k_addsp,
    &pc_khandlers_k_stop,
    &pc_khandlers_k_test,
    &pc_khandlers_k_makelist,
    &pc_khandlers_k_makerecord,
    &pc_khandlers_k_makearray,
    &pc_khandlers_k_makestruct,
    &pc_khandlers_k_makeset,
    &pc_khandlers_k_makerange,
    &pc_khandlers_k_makedict,
    &pc_khandlers_k_pushdot,
    &pc_khandlers_k_pushdotref,
    &pc_khandlers_k_softconv,
    &pc_khandlers_k_hardconv,
    &pc_khandlers_k_mixed,
    &pc_khandlers_k_incrptr,
    &pc_khandlers_k_incrto_m,
    &pc_khandlers_k_incrto_f,
    &pc_khandlers_k_loadincr,
    &pc_khandlers_k_incrload,
    &pc_khandlers_k_decrptr,
    &pc_khandlers_k_decrto_m,
    &pc_khandlers_k_decrto_f,
    &pc_khandlers_k_loaddecr,
    &pc_khandlers_k_decrload,
    &pc_khandlers_k_incr,
    &pc_khandlers_k_decr,
    &pc_khandlers_k_neg,
    &pc_khandlers_k_abs,
    &pc_khandlers_k_not,
    &pc_khandlers_k_inot,
    &pc_khandlers_k_istrue,
    &pc_khandlers_k_asc,
    &pc_khandlers_k_chr,
    &pc_khandlers_k_sqrt,
    &pc_khandlers_k_sqr,
    &pc_khandlers_k_cube,
    &pc_khandlers_k_sin,
    &pc_khandlers_k_cos,
    &pc_khandlers_k_tan,
    &pc_khandlers_k_asin,
    &pc_khandlers_k_acos,
    &pc_khandlers_k_atan,
    &pc_khandlers_k_sign,
    &pc_khandlers_k_ln,
    &pc_khandlers_k_log,
    &pc_khandlers_k_lg,
    &pc_khandlers_k_exp,
    &pc_khandlers_k_round,
    &pc_khandlers_k_floor,
    &pc_khandlers_k_ceil,
    &pc_khandlers_k_fract,
    &pc_khandlers_k_negto,
    &pc_khandlers_k_absto,
    &pc_khandlers_k_notto,
    &pc_khandlers_k_inotto,
    &pc_khandlers_k_len,
    &pc_khandlers_k_lwb,
    &pc_khandlers_k_upb,
    &pc_khandlers_k_bounds,
    &pc_khandlers_k_bits,
    &pc_khandlers_k_bytes,
    &pc_khandlers_k_type,
    &pc_khandlers_k_elemtype,
    &pc_khandlers_k_basetype,
    &pc_khandlers_k_minval,
    &pc_khandlers_k_maxval,
    &pc_khandlers_k_isint,
    &pc_khandlers_k_isreal,
    &pc_khandlers_k_isstring,
    &pc_khandlers_k_isrange,
    &pc_khandlers_k_isnumber,
    &pc_khandlers_k_isarray,
    &pc_khandlers_k_isrecord,
    &pc_khandlers_k_ispointer,
    &pc_khandlers_k_ismutable,
    &pc_khandlers_k_isset,
    &pc_khandlers_k_isvoid,
    &pc_khandlers_k_isdef,
    &pc_khandlers_k_tostr,
    &pc_khandlers_k_isequal,
    &pc_khandlers_k_add,
    &pc_khandlers_k_sub,
    &pc_khandlers_k_mul,
    &pc_khandlers_k_div,
    &pc_khandlers_k_idiv,
    &pc_khandlers_k_rem,
    &pc_khandlers_k_divrem,
    &pc_khandlers_k_iand,
    &pc_khandlers_k_ior,
    &pc_khandlers_k_ixor,
    &pc_khandlers_k_shl,
    &pc_khandlers_k_shr,
    &pc_khandlers_k_in,
    &pc_khandlers_k_notin,
    &pc_khandlers_k_inrev,
    &pc_khandlers_k_eq,
    &pc_khandlers_k_ne,
    &pc_khandlers_k_lt,
    &pc_khandlers_k_le,
    &pc_khandlers_k_ge,
    &pc_khandlers_k_gt,
    &pc_khandlers_k_min,
    &pc_khandlers_k_max,
    &pc_khandlers_k_concat,
    &pc_khandlers_k_append,
    &pc_khandlers_k_power,
    &pc_khandlers_k_atan2,
    &pc_khandlers_k_addto,
    &pc_khandlers_k_subto,
    &pc_khandlers_k_multo,
    &pc_khandlers_k_divto,
    &pc_khandlers_k_idivto,
    &pc_khandlers_k_iandto,
    &pc_khandlers_k_iorto,
    &pc_khandlers_k_ixorto,
    &pc_khandlers_k_shlto,
    &pc_khandlers_k_shrto,
    &pc_khandlers_k_minto,
    &pc_khandlers_k_maxto,
    &pc_khandlers_k_concatto,
    &pc_khandlers_k_appendto,
    &pc_khandlers_k_pushix,
    &pc_khandlers_k_pushdotix,
    &pc_khandlers_k_pushkeyix,
    &pc_khandlers_k_pushkeyixd,
    &pc_khandlers_k_pushixref,
    &pc_khandlers_k_pushdotixref,
    &pc_khandlers_k_pushkeyixref,
    &pc_khandlers_k_pushbyteix,
    &pc_khandlers_k_pushbyteixref,
    &pc_khandlers_k_appendset,
    &pc_khandlers_k_pushdotm,
    &pc_khandlers_k_pushdott,
    &pc_khandlers_k_push_ad,
    &pc_khandlers_k_push_try,
    &pc_khandlers_k_raise,
    &pc_khandlers_k_applyop,
    &pc_khandlers_k_makeiter,
    &pc_khandlers_k_forall,
    &pc_khandlers_k_forallx,
    &pc_khandlers_k_foreach,
    &pc_khandlers_k_foreachx,
    &pc_khandlers_k_expandrange,
    &pc_assem_c_fixup_asm,
    &pc_assem_c_asmavailable,
    &pc_assem_c_addcountint,
    &pc_assem_c_addcountext,
    &pc_assem_c_showasmcmd,
    &pc_assem_c_disploop_asm,
    &pc_assem_c_getasmjump,
    &qc_qcompiler,
    &qc_qcstart,
    &qc_do_loadmodules,
    &qc_loadmainmodule,
    &qc_loadmodule,
    &qc_loadimport,
    &qc_readimportlist,
    &qc_initlogfile,
    &qc_closelogfile,
    &qc_initdata,
    &qc_initsearchdirs,
    &qc_getmodulestr,
    &qc_findmodule,
    &qc_checkname,
    &qc_getinputoptions,
    &qc_do_option,
    &qc_do_parse,
    &qc_do_codegen,
    &qc_showast,
    &qc_showstflat,
    &qc_showsttree,
    &qc_showpcl,
    &qc_showgenfields,
    &qc_loaderror,
    &qc_do_showprogdiags_pc,
    &qc_getsyscmdline,
    &qc_showmodules,
    &qc_do_compilemodules,
    &qc_compilemodule,
    &qc_starttiming,
    &qc_showtiming,
    &qc_do_writeqafile,
    &qc_checkkeyword,
    &qc_readinttoken,
    &qc_do_loadqafile,
    &qc_showinttiming,
    &qc_do_writepcfile,
    &qc_writesymbols,
    &qc_showpcsymbol,
    &qc_writepccode2pc,
    &qc_writestructfields,
    &qc_fixup_genfields,
    &qc_showoptions,
    &qc_showoutput,
    &qc_showhelp,
    &qc_nextcmd,
    &qc_writedocs,
    &qc_support_prterror,
    &qc_support_serror,
    &qc_support_gerror,
    &qc_support_nxerror,
    &qc_support_testelem,
    &qc_support_setelem,
    &qc_support_inittypetables,
    &qc_support_nextpoweroftwo,
    &qc_support_initpcdest,
    &qc_support_getpcpos,
    &qc_support_setpcpos,
    &qc_support_writepcdata,
    &qc_support_writezstring,
    &qc_support_writezblock,
    &qc_support_writezint,
    &qc_support_writezint4,
    &qc_support_writezrange,
    &qc_support_writezreal,
    &qc_support_writezeof,
    &qc_support_ipower,
    &qc_support_gs_additem,
    &qc_support_isalphanum,
    &qc_support_gs_copytostr,
    &qc_support_outpcbyte,
    &qc_support_outpcword,
    &qc_support_outpcword16,
    &qc_lex_lexreadtoken,
    &qc_lex_lxreadstring,
    &qc_lex_readnumber,
    &qc_lex_readrealnumber,
    &qc_lex_readexponent,
    &qc_lex_lxerror,
    &qc_lex_printsymbol,
    &qc_lex_stringtonumber,
    &qc_lex_lexsetup,
    &qc_lex_printstrn,
    &qc_lex_scannumber,
    &qc_lex_readrawstring,
    &qc_lex_lookup,
    &qc_lex_gethashvaluez,
    &qc_lex_inithashtable,
    &qc_lex_dolexdirective,
    &qc_lex_lexreadline,
    &qc_lex_startlex,
    &qc_lex_convertzstring,
    &qc_lex_addnamestr,
    &qc_lex_ps1,
    &qc_lex_ps2,
    &qc_lex_ps,
    &qc_lex_lex,
    &qc_lex_showhashtablesize,
    &qc_lex_addmacro,
    &qc_lex_stackmacro,
    &qc_lex_unstackmacro,
    &qc_parse_parsemodule,
    &qc_parse_readmoduledefs,
    &qc_parse_initparser,
    &qc_parse_skipsemi,
    &qc_parse_addalias,
    &qc_parse_makeblock,
    &qc_parse_convertstmtexpr,
    &qc_parse_checkequals,
    &qc_parse_getcurrline,
    &qc_parse_checkbegin,
    &qc_parse_checkbeginend,
    &qc_parse_checkend,
    &qc_parse_addgenfield,
    &qc_parse_readvardef,
    &qc_parse_readconstdef,
    &qc_parse_readexpression,
    &qc_parse_readfactor,
    &qc_parse_readterm,
    &qc_parse_readlbrack,
    &qc_parse_addlistunit,
    &qc_parse_addlistparam,
    &qc_parse_readlsqbrack,
    &qc_parse_readcast,
    &qc_parse_readopc,
    &qc_parse_readsprint,
    &qc_parse_readsread,
    &qc_parse_readcompilervar,
    &qc_parse_readcastx,
    &qc_parse_checksymbol,
    &qc_parse_readtypespec,
    &qc_parse_readhostparams,
    &qc_parse_readslist,
    &qc_parse_readindex,
    &qc_parse_readkeyindex,
    &qc_parse_readdotsuffix,
    &qc_parse_isconstexpr,
    &qc_parse_readconstexpr,
    &qc_parse_readconstexprvalue,
    &qc_parse_readconstint,
    &qc_parse_readprocdef,
    &qc_parse_readprocdecl,
    &qc_parse_readparams,
    &qc_parse_readblock,
    &qc_parse_readexecstmt,
    &qc_parse_readstmtexpr,
    &qc_parse_readcondsuffix,
    &qc_parse_readif,
    &qc_parse_readgoto,
    &qc_parse_readunless,
    &qc_parse_readswitchcase,
    &qc_parse_readstop,
    &qc_parse_readreturn,
    &qc_parse_readdo,
    &qc_parse_readto,
    &qc_parse_readwhile,
    &qc_parse_readrepeat,
    &qc_parse_readloopcontrol,
    &qc_parse_readprint,
    &qc_parse_readread,
    &qc_parse_readtry,
    &qc_parse_readraise,
    &qc_parse_readfor,
    &qc_parse_readforall,
    &qc_parse_readtypedef,
    &qc_parse_readstructdef,
    &qc_parse_readstructfields,
    &qc_parse_readtabledef,
    &qc_parse_readclassdef,
    &qc_parse_readclassbody,
    &qc_parse_readenumtype,
    &qc_parse_duplfield,
    &qc_parse_readrecordfields,
    &qc_parse_readimportmodule,
    &qc_parse_readimportbody,
    &qc_parse_createlabel,
    &qc_parse_createprocdef,
    &qc_parse_createproccall,
    &qc_parse_readequivfield,
    &qc_parse_testconstruct,
    &qc_parse_readapplyop,
    &qc_lib_newstrec,
    &qc_lib_initqclib,
    &qc_lib_getduplnameptr,
    &qc_lib_adddef,
    &qc_lib_adddef_nodupl,
    &qc_lib_printst,
    &qc_lib_printstrec,
    &qc_lib_printstflat,
    &qc_lib_newunitrec,
    &qc_lib_createname,
    &qc_lib_createunit0,
    &qc_lib_createunit1,
    &qc_lib_createunit2,
    &qc_lib_createunit3,
    &qc_lib_createconstunit,
    &qc_lib_createstringconstunit,
    &qc_lib_getoptocode,
    &qc_lib_checkpackedtype,
    &qc_lib_checkunpackedtype,
    &qc_lib_checkdlltype,
    &qc_lib_createtype,
    &qc_lib_createusertype,
    &qc_lib_createusertypefromstr,
    &qc_lib_getconstvalue,
    &qc_lib_getrangelwb,
    &qc_lib_getrangeupb,
    &qc_lib_getrangelwbunit,
    &qc_lib_getrangeupbunit,
    &qc_lib_createarraymode,
    &qc_lib_nextautotype,
    &qc_lib_createstringmode,
    &qc_lib_createrefpackmode,
    &qc_lib_getscope,
    &qc_lib_setnameptr,
    &qc_lib_printcode_all,
    &qc_lib_printcode,
    &qc_lib_printunit,
    &qc_lib_printunitlist,
    &qc_lib_getprefix,
    &qc_lib_getdottedname,
    &qc_lib_getlineinfok,
    &qc_lib_getavname,
    &qc_lib_unionstr_clear,
    &qc_lib_unionstr_append,
    &qc_lib_unionstr_concat,
    &qc_lib_unionstr_last,
    &qc_lib_unionstr_copy,
    &qc_lib_unionstr_print,
    &qc_lib_createrecordmode,
    &qc_lib_createenummode,
    &qc_lib_convertstring,
    &qc_lib_strexpr,
    &qc_lib_jeval,
    &qc_lib_getopcjname,
    &qc_lib_strmode,
    &qc_lib_istrmode,
    &qc_lib_countunits,
    &qc_lib_finddefstr,
    &qc_lib_purgesymbol,
    &qc_lib_purgesymbollist,
    &qc_lib_purgeprocs,
    &qc_lib_purgeproc,
    &qc_lib_printmodelist,
    &qc_lib_printgenfieldtable,
    &qc_lib_addtoproclist,
    &qc_parselib_px_typecheck,
    &qc_parselib_resolvetopname,
    &qc_parselib_px_name,
    &qc_parselib_evalbinop,
    &qc_parselib_evalbinop_real,
    &qc_parselib_makenewconst,
    &qc_parselib_finddupl,
    &qc_parselib_px_dot,
    &qc_parselib_evalmonop,
    &qc_parselib_checkdict,
    &qc_parselib_checkconstlist,
    &qc_pclgen_do_tag,
    &qc_pclgen_codegen,
    &qc_pclgen_convertalltypes,
    &qc_pclgen_scanidata,
    &qc_pclgen_genidata,
    &qc_pclgen_initgenpcl,
    &qc_pclgen_doprogramstartup,
    &qc_pclgen_do_block,
    &qc_pclgen_do_print,
    &qc_pclgen_do_fprint,
    &qc_pclgen_do_read,
    &qc_pclgen_do_assign,
    &qc_pclgen_do_to,
    &qc_pclgen_do_while,
    &qc_pclgen_do_repeat,
    &qc_pclgen_do_forstep,
    &qc_pclgen_do_forall,
    &qc_pclgen_do_do,
    &qc_pclgen_do_cfor,
    &qc_pclgen_do_if,
    &qc_pclgen_do_longif,
    &qc_pclgen_do_callproc,
    &qc_pclgen_do_callhostproc,
    &qc_pclgen_do_return,
    &qc_pclgen_genstartproc,
    &qc_pclgen_do_procdef,
    &qc_pclgen_genprocentry,
    &qc_pclgen_genprocexit,
    &qc_pclgen_do_preincr,
    &qc_pclgen_do_exit,
    &qc_pclgen_do_goto,
    &qc_pclgen_do_switch,
    &qc_pclgen_do_simpleswitch,
    &qc_pclgen_do_case,
    &qc_pclgen_do_try,
    &qc_pclgen_do_applyop,
    &qc_pclgen_evalref,
    &qc_pclgen_getpclop,
    &qc_pclgen_genjumpl,
    &qc_pclgen_definelabel,
    &qc_pclgen_createfwdlabel,
    &qc_pclgen_definefwdlabel,
    &qc_pclgen_stacklooplabels,
    &qc_pclgen_unstacklooplabels,
    &qc_pclgen_findlooplabel,
    &qc_pclgen_issimpleparam,
    &qc_pclgen_genjumpcond,
    &qc_pclgen_gcomparejump,
    &qc_pclgen_reversecond,
    &qc_pclgen_do_convert,
    &qc_pclgen_do_selectx,
    &qc_pclgen_do_calldll,
    &qc_pclgen_islogical,
    &qc_pclgen_do_and,
    &qc_pclgen_do_or,
    &qc_pclgen_do_callptr,
    &qc_pclgen_do_callmproc,
    &qc_pclgen_checkblockreturn,
    &qc_pclgen_genfree,
    &qc_pclgen_do_clamp,
    &qc_pclgen_do_applyopx,
    &qc_pclgen_do_calldllvar,
    &qc_pclgen_callhostfn,
    &qc_pclgen_extractparams,
    &qc_pclgen_unitstoarray,
    &qc_pclgen_do_idiv,
    &qc_pclgen_ispoweroftwo,
    &qc_pclgen_genpushint,
    &qc_pclgen_checkeqeq,
    &qc_pcllib_initpcl,
    &qc_pcllib_initpcldata,
    &qc_pcllib_initpclgen,
    &qc_pcllib_writepcl3,
    &qc_pcllib_writepclopnd3,
    &qc_pcllib_writepccode,
    &qc_pcllib_genpc,
    &qc_pcllib_genopnd_int,
    &qc_pcllib_genopnd_s,
    &qc_pcllib_genpc_int,
    &qc_pcllib_genpc_int2,
    &qc_pcllib_genpc_int4,
    &qc_pcllib_genpc_s,
    &qc_pcllib_genpc_str,
    &qc_pcllib_genopnd_str,
    &qc_pcllib_genpc_lab,
    &qc_pcllib_isframe_s,
    &qc_pcllib_converttype,
    &qc_pcllib_scanstruct,
    &qc_pcllib_scanrecord,
    &qc_pcllib_shiftflagsleft,
    &qc_pcllib_gstest,
    &qc_pcllib_addstringtotable,
    &q_libs_getintlib,
0};
static byte *  msysc__fnnames[]= {
    (byte*)"start",
    (byte*)"initlogfile",
    (byte*)"closelogfile",
    (byte*)"initdata",
    (byte*)"getinputfile",
    (byte*)"showpcl",
    (byte*)"showgenfields",
    (byte*)"do_showprogdiags_pc",
    (byte*)"runcode",
    (byte*)"initbytecode",
    (byte*)"disploop",
    (byte*)"pclinit",
    (byte*)"fixup_all_pc",
    (byte*)"fixup_module_pc",
    (byte*)"disploop_fn",
    (byte*)"disploop_deb",
    (byte*)"getsyscmdline",
    (byte*)"showmodules",
    (byte*)"starttiming",
    (byte*)"showtiming",
    (byte*)"runproc",
    (byte*)"showinttiming",
    (byte*)"allocatestrings",
    (byte*)"loadprogram",
    (byte*)"loadpcfile",
    (byte*)"initpcldata",
    (byte*)"createstentry",
    (byte*)"findnewestfile",
    (byte*)"showcaption",
    (byte*)"getprocaddr",
    (byte*)"getfileint",
    (byte*)"checkpackfile",
    (byte*)"pcl_initusertypes",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_getnprocs",
    (byte*)"m_getprocaddr",
    (byte*)"m_getprocname",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"pcm_alloc",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_copymem4",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_array",
    (byte*)"pcm_printfreelist",
    (byte*)"pcm_diags",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"addtomemalloc",
    (byte*)"removefrommemalloc",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"alloctable",
    (byte*)"zalloctable",
    (byte*)"checkfreelists",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword",
    (byte*)"outword64",
    (byte*)"myeof",
    (byte*)"pcm_smallallocz",
    (byte*)"pcm_smallalloc",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparam",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_flushkeys",
    (byte*)"os_getconsolein",
    (byte*)"os_getconsoleout",
    (byte*)"os_proginstance",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_getoscode",
    (byte*)"os_iswindows",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_gethostsize",
    (byte*)"os_getmpath",
    (byte*)"os_exitprocess",
    (byte*)"os_gettimestamp",
    (byte*)"os_gettickcount",
    (byte*)"os_clock",
    (byte*)"os_getclockspersec",
    (byte*)"os_setmesshandler",
    (byte*)"os_filelastwritetime",
    (byte*)"os_hpcounter",
    (byte*)"os_hpfrequency",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"prterror",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"pcustype_def",
    (byte*)"pcustype",
    (byte*)"pcustypet",
    (byte*)"pcmxtypes_def",
    (byte*)"pcmxtypes",
    (byte*)"pcmxtypestt",
    (byte*)"gettypename",
    (byte*)"inittypetables",
    (byte*)"pcerror",
    (byte*)"vxunimpl",
    (byte*)"pclunimpl",
    (byte*)"convcstring",
    (byte*)"getintvalue",
    (byte*)"nextpoweroftwo",
    (byte*)"showlinenumber",
    (byte*)"printlinenumber",
    (byte*)"findlinenumber",
    (byte*)"findpcindex",
    (byte*)"showlinetable",
    (byte*)"writezstring",
    (byte*)"writezint",
    (byte*)"writezint4",
    (byte*)"writezrange",
    (byte*)"writezreal",
    (byte*)"writezeof",
    (byte*)"zerror",
    (byte*)"readzvalue",
    (byte*)"readzint",
    (byte*)"readzdint",
    (byte*)"readzreal",
    (byte*)"readzstring",
    (byte*)"readzblock",
    (byte*)"checkmt",
    (byte*)"ipower",
    (byte*)"loaderror",
    (byte*)"gettypesig",
    (byte*)"getfnname",
    (byte*)"junimpl",
    (byte*)"raiseexception",
    (byte*)"raise_error",
    (byte*)"default_exception",
    (byte*)"pc_ufree",
    (byte*)"pc_cfree",
    (byte*)"pc_ufreex",
    (byte*)"pc_freeref",
    (byte*)"pc_cshare",
    (byte*)"pc_ushare",
    (byte*)"pc_dupl",
    (byte*)"j_free_s",
    (byte*)"j_free_l_m_d",
    (byte*)"j_free_k",
    (byte*)"j_free_a_j",
    (byte*)"j_free_b_e",
    (byte*)"j_dupl_s",
    (byte*)"j_dupl_l_m_d",
    (byte*)"j_dupl_a_j",
    (byte*)"j_dupl_b",
    (byte*)"j_dupl_e",
    (byte*)"j_dupl_k",
    (byte*)"pc_makelist",
    (byte*)"pc_makerecord",
    (byte*)"pc_makearray",
    (byte*)"pc_makerange",
    (byte*)"pc_makeset",
    (byte*)"pc_makestruct",
    (byte*)"pc_makedict",
    (byte*)"pc_storepacked",
    (byte*)"adddictitem",
    (byte*)"finddictitem",
    (byte*)"expanddict",
    (byte*)"setfslength",
    (byte*)"getfslength",
    (byte*)"gethashvalue",
    (byte*)"pc_storeptr",
    (byte*)"pc_storebit",
    (byte*)"pc_popptrlist",
    (byte*)"pc_loadpacked",
    (byte*)"pc_loadbit",
    (byte*)"pc_loadptr",
    (byte*)"pc_storestring",
    (byte*)"pc_iconvert",
    (byte*)"pc_iconvcase",
    (byte*)"pc_eqstring_nf",
    (byte*)"pc_equal_nf",
    (byte*)"comparebytes",
    (byte*)"pc_compare_nf",
    (byte*)"cmpstringlen",
    (byte*)"pc_eqstring",
    (byte*)"pc_equal",
    (byte*)"pc_compare",
    (byte*)"u8inarray",
    (byte*)"u16inarray",
    (byte*)"u32inarray",
    (byte*)"u64inarray",
    (byte*)"bitinbits",
    (byte*)"pc_strinstr",
    (byte*)"getbitoffset",
    (byte*)"pc_iappendlist",
    (byte*)"pc_iappendarray",
    (byte*)"pc_mul_listi",
    (byte*)"pc_mul_stri",
    (byte*)"pc_duplvar",
    (byte*)"pc_iconcatlist",
    (byte*)"pc_iappendbits",
    (byte*)"pc_makestring",
    (byte*)"pc_makestringx",
    (byte*)"pc_makestringn",
    (byte*)"pc_emptystring",
    (byte*)"pc_makechar",
    (byte*)"newobject",
    (byte*)"freeobject",
    (byte*)"addref_obj",
    (byte*)"makezobjects",
    (byte*)"make_listdata",
    (byte*)"free_listdata",
    (byte*)"make_arraydata",
    (byte*)"free_arraydata",
    (byte*)"make_bitdata",
    (byte*)"free_bitdata",
    (byte*)"make_listobj",
    (byte*)"make_arrayobj",
    (byte*)"make_setobj",
    (byte*)"make_bitsobj",
    (byte*)"resize_listobj",
    (byte*)"resize_arrayobj",
    (byte*)"resize_bitsobj",
    (byte*)"make_strslicexobj",
    (byte*)"copyonwrite",
    (byte*)"get_objbytes",
    (byte*)"bn_makestr",
    (byte*)"bn_makeint",
    (byte*)"bn_makeu",
    (byte*)"bn_makeu_base",
    (byte*)"strvaln",
    (byte*)"makebigint",
    (byte*)"freebigint",
    (byte*)"bn_neg",
    (byte*)"bn_abs",
    (byte*)"bn_add",
    (byte*)"bn_addu",
    (byte*)"bn_sub",
    (byte*)"bn_subu",
    (byte*)"bn_mul",
    (byte*)"muldigit",
    (byte*)"bn_zero",
    (byte*)"bn_mulu",
    (byte*)"bn_div",
    (byte*)"bn_divu",
    (byte*)"bn_equal",
    (byte*)"bn_cmp",
    (byte*)"bn_int",
    (byte*)"bn_digits",
    (byte*)"bn_power",
    (byte*)"bn_reduce",
    (byte*)"pch_print",
    (byte*)"pch_println",
    (byte*)"pch_startprintcon",
    (byte*)"pch_startprint",
    (byte*)"pch_endprint",
    (byte*)"pch_strstartprint",
    (byte*)"pch_strendprint",
    (byte*)"pch_setformat",
    (byte*)"pch_setformat2",
    (byte*)"pch_dprint",
    (byte*)"pch_printnogap",
    (byte*)"initfmtcode",
    (byte*)"i64mintostr",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"strtostrfmt",
    (byte*)"expandstr",
    (byte*)"pc_strtofmt",
    (byte*)"printstrz",
    (byte*)"printstr_n",
    (byte*)"printerror",
    (byte*)"addstring",
    (byte*)"j_tostr_i",
    (byte*)"j_tostr_r",
    (byte*)"j_tostr_w",
    (byte*)"j_tostr_n",
    (byte*)"j_tostr_s",
    (byte*)"j_tostr_l",
    (byte*)"j_tostr_a",
    (byte*)"j_tostr_b",
    (byte*)"j_tostr_e",
    (byte*)"j_tostr_k",
    (byte*)"j_tostr_j",
    (byte*)"j_tostr_d",
    (byte*)"j_tostr_z",
    (byte*)"printnextfmtchars",
    (byte*)"getreadfmtcode",
    (byte*)"pch_sreadln",
    (byte*)"pch_strtoval",
    (byte*)"pch_reread",
    (byte*)"pch_rereadln",
    (byte*)"readname",
    (byte*)"readstring",
    (byte*)"readint",
    (byte*)"readhex",
    (byte*)"readbin",
    (byte*)"readreal",
    (byte*)"pch_readln",
    (byte*)"stepkbpos",
    (byte*)"pch_sread",
    (byte*)"domultichar",
    (byte*)"pch_tostr",
    (byte*)"pc_getfmt",
    (byte*)"pc_readlinen",
    (byte*)"readitem",
    (byte*)"readany",
    (byte*)"strtoreal",
    (byte*)"strtoint",
    (byte*)"calltostrtable",
    (byte*)"printbn",
    (byte*)"initcalltables",
    (byte*)"initjhandler",
    (byte*)"add_stable_entry",
    (byte*)"add_dtable_entry",
    (byte*)"def_handler",
    (byte*)"ddef_handler",
    (byte*)"j_add_i_w",
    (byte*)"j_add_r",
    (byte*)"j_add_s",
    (byte*)"j_add_j",
    (byte*)"j_add_e",
    (byte*)"j_add_z",
    (byte*)"j_add_iw_wi",
    (byte*)"j_add_zz",
    (byte*)"j_sub_i_w",
    (byte*)"j_sub_r",
    (byte*)"j_sub_p",
    (byte*)"j_sub_j",
    (byte*)"j_sub_e",
    (byte*)"j_sub_z",
    (byte*)"j_sub_zz",
    (byte*)"j_mixed_iw_wi",
    (byte*)"j_mixed_ir",
    (byte*)"j_mixed_ri",
    (byte*)"j_mixed_ij",
    (byte*)"j_mixed_ji",
    (byte*)"j_mul_i_w",
    (byte*)"j_mul_r",
    (byte*)"j_mul_j",
    (byte*)"j_mul_z",
    (byte*)"j_mul_li",
    (byte*)"j_mul_si",
    (byte*)"j_mul_e",
    (byte*)"j_mul_zz",
    (byte*)"j_div_i",
    (byte*)"j_div_r",
    (byte*)"j_div_z",
    (byte*)"j_jumple_i",
    (byte*)"j_jumple_r",
    (byte*)"j_jumple_s",
    (byte*)"j_jumple_z",
    (byte*)"j_jumpeq_i_r_t_o",
    (byte*)"j_jumpeq_v_p_f_g",
    (byte*)"j_jumpeq_s",
    (byte*)"j_jumpeq_z",
    (byte*)"j_jumpeq_zz",
    (byte*)"j_jumpne_i_r_t_o",
    (byte*)"j_jumpne_v_p_f_g",
    (byte*)"j_jumpne_s",
    (byte*)"j_jumpne_z",
    (byte*)"j_jumpne_zz",
    (byte*)"j_jumpge_i",
    (byte*)"j_jumpge_w",
    (byte*)"j_jumpge_r",
    (byte*)"j_jumpge_z",
    (byte*)"j_jumpgt_i",
    (byte*)"j_jumpgt_w",
    (byte*)"j_jumpgt_r",
    (byte*)"j_jumpgt_z",
    (byte*)"j_jumplt_i",
    (byte*)"j_jumplt_v_p",
    (byte*)"j_jumplt_r",
    (byte*)"j_jumplt_z",
    (byte*)"j_pushix_li_mi",
    (byte*)"j_pushix_vi",
    (byte*)"j_pushix_ln",
    (byte*)"j_pushix_ll",
    (byte*)"j_pushix_le",
    (byte*)"j_pushix_ai",
    (byte*)"j_pushix_bi_ei",
    (byte*)"j_pushix_an",
    (byte*)"j_pushix_si",
    (byte*)"j_pushix_sn",
    (byte*)"j_pushix_bn",
    (byte*)"j_pushix_di",
    (byte*)"j_pushix_zz",
    (byte*)"j_pushixref_li",
    (byte*)"j_pushixref_ln",
    (byte*)"j_pushixref_ai",
    (byte*)"j_pushixref_si",
    (byte*)"j_pushixref_bi_ei",
    (byte*)"j_pushixref_zz",
    (byte*)"j_pushdotix_si",
    (byte*)"j_pushdotix_sn",
    (byte*)"j_pushdotix_ii",
    (byte*)"j_pushdotix_in",
    (byte*)"j_pushdotix_ei",
    (byte*)"j_pushdotix_mi",
    (byte*)"j_pushdotix_zz",
    (byte*)"j_pushdotixref_si",
    (byte*)"j_pushdotixref_sn",
    (byte*)"j_pushdotixref_ii",
    (byte*)"j_pushdotixref_ei",
    (byte*)"j_pushdotixref_zz",
    (byte*)"j_addto_i",
    (byte*)"j_addto_r",
    (byte*)"j_addto_s",
    (byte*)"j_addto_p",
    (byte*)"j_addto_z",
    (byte*)"j_addto_si",
    (byte*)"j_addto_ir",
    (byte*)"j_addto_ri",
    (byte*)"j_addto_zz",
    (byte*)"j_subto_i",
    (byte*)"j_subto_r",
    (byte*)"j_subto_z",
    (byte*)"j_multo_i_w",
    (byte*)"j_multo_r",
    (byte*)"j_multo_z",
    (byte*)"j_divto_i_w",
    (byte*)"j_divto_r",
    (byte*)"j_divto_z",
    (byte*)"j_idivto_i",
    (byte*)"j_idivto_z",
    (byte*)"j_iand_i_w",
    (byte*)"j_iand_e",
    (byte*)"j_iand_z",
    (byte*)"j_ior_i_w",
    (byte*)"j_ior_e",
    (byte*)"j_ior_z",
    (byte*)"j_ixor_i_w",
    (byte*)"j_ixor_e",
    (byte*)"j_ixor_z",
    (byte*)"j_iandto_i_w",
    (byte*)"j_iandto_z",
    (byte*)"j_iorto_i_w",
    (byte*)"j_iorto_z",
    (byte*)"j_ixorto_i_w",
    (byte*)"j_ixorto_z",
    (byte*)"j_shlto_i",
    (byte*)"j_shlto_z",
    (byte*)"j_shrto_i",
    (byte*)"j_shrto_z",
    (byte*)"j_concat_s",
    (byte*)"j_concat_l",
    (byte*)"j_concat_z",
    (byte*)"j_concatto_s",
    (byte*)"j_concatto_l",
    (byte*)"j_concatto_z",
    (byte*)"j_append_s",
    (byte*)"j_append_l",
    (byte*)"j_append_a",
    (byte*)"j_append_b",
    (byte*)"j_append_z",
    (byte*)"j_appendto_s",
    (byte*)"j_appendto_l",
    (byte*)"j_appendto_a",
    (byte*)"j_appendto_b_e",
    (byte*)"j_appendto_z",
    (byte*)"j_max_i",
    (byte*)"j_max_r",
    (byte*)"j_max_z",
    (byte*)"j_min_z",
    (byte*)"j_len_l_a_e_s_b_m_k_d",
    (byte*)"j_len_n",
    (byte*)"j_len_z",
    (byte*)"j_lwb_l_a_b",
    (byte*)"j_lwb_s_m_k_d",
    (byte*)"j_lwb_e",
    (byte*)"j_lwb_n",
    (byte*)"j_lwb_z",
    (byte*)"j_upb_l_a_b",
    (byte*)"j_upb_s_m_k_d",
    (byte*)"j_upb_e",
    (byte*)"j_upb_n",
    (byte*)"j_upb_z",
    (byte*)"j_bounds_l_a_b_s_m_k_e",
    (byte*)"j_bounds_n",
    (byte*)"j_bounds_z",
    (byte*)"j_minto_i",
    (byte*)"j_minto_r",
    (byte*)"j_minto_z",
    (byte*)"j_maxto_i",
    (byte*)"j_maxto_r",
    (byte*)"j_maxto_z",
    (byte*)"j_neg_i_w",
    (byte*)"j_neg_r",
    (byte*)"j_neg_j",
    (byte*)"j_neg_e",
    (byte*)"j_neg_z",
    (byte*)"j_abs_i_w",
    (byte*)"j_abs_r",
    (byte*)"j_abs_j",
    (byte*)"j_abs_z",
    (byte*)"j_inot_i_w",
    (byte*)"j_inot_e",
    (byte*)"j_inot_z",
    (byte*)"j_istrue_i_w_r",
    (byte*)"j_istrue_l_a_e_s_b",
    (byte*)"j_istrue_k_m_h",
    (byte*)"j_istrue_j",
    (byte*)"j_istrue_z",
    (byte*)"j_jumpfalse_i_w_r_v_p_f",
    (byte*)"j_jumpfalse_s_l_e_a_b",
    (byte*)"j_jumpfalse_z",
    (byte*)"j_jumptrue_i_r_w_v_p_f",
    (byte*)"j_jumptrue_s_l_e_a_b",
    (byte*)"j_jumptrue_z",
    (byte*)"j_shl_i_w",
    (byte*)"j_shl_z",
    (byte*)"j_shr_i",
    (byte*)"j_shr_z",
    (byte*)"j_shr_wi",
    (byte*)"j_shr_zz",
    (byte*)"j_idiv_i_w",
    (byte*)"j_idiv_j",
    (byte*)"j_idiv_z",
    (byte*)"runproc_m",
    (byte*)"os_getconsize",
    (byte*)"pch_setmesshandler",
    (byte*)"pch_gethostname",
    (byte*)"os_initdllmodules",
    (byte*)"os_loaddllmodule",
    (byte*)"os_initdllfunctions",
    (byte*)"os_loaddllfunction",
    (byte*)"pch_getos",
    (byte*)"pch_gethostsize",
    (byte*)"pch_iswindows",
    (byte*)"os_calldll",
    (byte*)"calldll_mint",
    (byte*)"calldll_mreal",
    (byte*)"calldll_cint",
    (byte*)"calldll_creal",
    (byte*)"os_calldll_wint",
    (byte*)"os_calldll_wreal",
    (byte*)"os_dummycall",
    (byte*)"callhostfunction",
    (byte*)"pch_leftstr",
    (byte*)"pch_rightstr",
    (byte*)"pch_convlc",
    (byte*)"pch_convuc",
    (byte*)"pch_iconvlc",
    (byte*)"pch_iconvuc",
    (byte*)"pch_stop",
    (byte*)"pch_stopx",
    (byte*)"pch_ismain",
    (byte*)"pch_waitkey",
    (byte*)"pch_testkey",
    (byte*)"pch_execwait",
    (byte*)"pch_execcmd",
    (byte*)"pch_makestr",
    (byte*)"pch_makestrslice",
    (byte*)"pch_makeref",
    (byte*)"pch_new",
    (byte*)"pch_newheap",
    (byte*)"pch_heapvar",
    (byte*)"pch_freeheap",
    (byte*)"pch_getcmdparam",
    (byte*)"pch_setpcerror",
    (byte*)"pch_setdebug",
    (byte*)"pch_setfprintf",
    (byte*)"pch_ticks",
    (byte*)"pch_sleep",
    (byte*)"pch_random",
    (byte*)"pch_findmetafunction",
    (byte*)"pch_loadpcl",
    (byte*)"pch_runpcl",
    (byte*)"pch_runtask",
    (byte*)"pch_callext",
    (byte*)"pch_system",
    (byte*)"pch_shellexec",
    (byte*)"pch_gethash",
    (byte*)"pch_test",
    (byte*)"pch_pcldata",
    (byte*)"pch_getcstring",
    (byte*)"pch_getparam",
    (byte*)"pch_clearlist",
    (byte*)"pch_makelink",
    (byte*)"pch_allparams",
    (byte*)"pch_stackvars",
    (byte*)"pch_makeempty",
    (byte*)"pch_readlines",
    (byte*)"pch_dictitems",
    (byte*)"pch_setoverload",
    (byte*)"pch_errorinfo",
    (byte*)"getbounds",
    (byte*)"checkparam",
    (byte*)"leftstring",
    (byte*)"rightstring",
    (byte*)"padstring_right",
    (byte*)"padstring_left",
    (byte*)"pcld_makevint",
    (byte*)"pcld_makelist",
    (byte*)"getproctabledata",
    (byte*)"convert_handler",
    (byte*)"addtoproclist",
    (byte*)"tostr_handler",
    (byte*)"addovrecord",
    (byte*)"dx_iorset",
    (byte*)"dx_iandset",
    (byte*)"dx_ixorset",
    (byte*)"dx_inotset",
    (byte*)"dx_subset",
    (byte*)"inotsetbits",
    (byte*)"iorsetbits",
    (byte*)"iandsetbits",
    (byte*)"ixorsetbits",
    (byte*)"subsetbits",
    (byte*)"iresizeset",
    (byte*)"dx_varinvar",
    (byte*)"dx_mixed",
    (byte*)"resize_stringobj",
    (byte*)"k_zero",
    (byte*)"k_nop",
    (byte*)"k_procstart",
    (byte*)"k_procend",
    (byte*)"k_endmodule",
    (byte*)"k_push_m",
    (byte*)"k_push_f",
    (byte*)"k_push_am",
    (byte*)"k_push_af",
    (byte*)"k_push_ap",
    (byte*)"k_push_al",
    (byte*)"k_push_ci",
    (byte*)"k_push_cw",
    (byte*)"k_push_cr",
    (byte*)"k_push_cn",
    (byte*)"k_push_cs",
    (byte*)"k_push_t",
    (byte*)"k_push_op",
    (byte*)"k_pushz",
    (byte*)"k_pushz_void",
    (byte*)"k_pushz_str",
    (byte*)"k_pushz_list",
    (byte*)"k_pushz_listl",
    (byte*)"k_pushz_set",
    (byte*)"k_pushz_arrayl",
    (byte*)"k_pop_m",
    (byte*)"k_pop_f",
    (byte*)"k_store_m",
    (byte*)"k_store_f",
    (byte*)"k_pushptr",
    (byte*)"k_popptr",
    (byte*)"k_storeptr",
    (byte*)"k_zpop_m",
    (byte*)"k_zpop_f",
    (byte*)"k_zstore_m",
    (byte*)"k_zstore_f",
    (byte*)"k_copy",
    (byte*)"k_swap",
    (byte*)"k_convptr",
    (byte*)"k_jump",
    (byte*)"k_jumpptr",
    (byte*)"k_jumptrue",
    (byte*)"k_jumpfalse",
    (byte*)"k_jumpdef",
    (byte*)"k_jumpvoid",
    (byte*)"k_jumpeq",
    (byte*)"k_jumpne",
    (byte*)"k_jumplt",
    (byte*)"k_jumple",
    (byte*)"k_jumpge",
    (byte*)"k_jumpgt",
    (byte*)"k_jumptesteq",
    (byte*)"k_jumptestne",
    (byte*)"k_jumplabel",
    (byte*)"k_jumpclabel",
    (byte*)"k_switch",
    (byte*)"k_cswitch",
    (byte*)"k_new",
    (byte*)"k_to_f",
    (byte*)"k_for_fci",
    (byte*)"k_for_ff",
    (byte*)"k_ford_fci",
    (byte*)"k_ford_ff",
    (byte*)"k_call",
    (byte*)"k_callptr",
    (byte*)"k_return",
    (byte*)"k_startdll",
    (byte*)"k_pushdll",
    (byte*)"k_calldll",
    (byte*)"k_callhost",
    (byte*)"k_stackframe",
    (byte*)"k_free",
    (byte*)"k_addsp",
    (byte*)"k_stop",
    (byte*)"k_test",
    (byte*)"k_makelist",
    (byte*)"k_makerecord",
    (byte*)"k_makearray",
    (byte*)"k_makestruct",
    (byte*)"k_makeset",
    (byte*)"k_makerange",
    (byte*)"k_makedict",
    (byte*)"k_pushdot",
    (byte*)"k_pushdotref",
    (byte*)"k_softconv",
    (byte*)"k_hardconv",
    (byte*)"k_mixed",
    (byte*)"k_incrptr",
    (byte*)"k_incrto_m",
    (byte*)"k_incrto_f",
    (byte*)"k_loadincr",
    (byte*)"k_incrload",
    (byte*)"k_decrptr",
    (byte*)"k_decrto_m",
    (byte*)"k_decrto_f",
    (byte*)"k_loaddecr",
    (byte*)"k_decrload",
    (byte*)"k_incr",
    (byte*)"k_decr",
    (byte*)"k_neg",
    (byte*)"k_abs",
    (byte*)"k_not",
    (byte*)"k_inot",
    (byte*)"k_istrue",
    (byte*)"k_asc",
    (byte*)"k_chr",
    (byte*)"k_sqrt",
    (byte*)"k_sqr",
    (byte*)"k_cube",
    (byte*)"k_sin",
    (byte*)"k_cos",
    (byte*)"k_tan",
    (byte*)"k_asin",
    (byte*)"k_acos",
    (byte*)"k_atan",
    (byte*)"k_sign",
    (byte*)"k_ln",
    (byte*)"k_log",
    (byte*)"k_lg",
    (byte*)"k_exp",
    (byte*)"k_round",
    (byte*)"k_floor",
    (byte*)"k_ceil",
    (byte*)"k_fract",
    (byte*)"k_negto",
    (byte*)"k_absto",
    (byte*)"k_notto",
    (byte*)"k_inotto",
    (byte*)"k_len",
    (byte*)"k_lwb",
    (byte*)"k_upb",
    (byte*)"k_bounds",
    (byte*)"k_bits",
    (byte*)"k_bytes",
    (byte*)"k_type",
    (byte*)"k_elemtype",
    (byte*)"k_basetype",
    (byte*)"k_minval",
    (byte*)"k_maxval",
    (byte*)"k_isint",
    (byte*)"k_isreal",
    (byte*)"k_isstring",
    (byte*)"k_isrange",
    (byte*)"k_isnumber",
    (byte*)"k_isarray",
    (byte*)"k_isrecord",
    (byte*)"k_ispointer",
    (byte*)"k_ismutable",
    (byte*)"k_isset",
    (byte*)"k_isvoid",
    (byte*)"k_isdef",
    (byte*)"k_tostr",
    (byte*)"k_isequal",
    (byte*)"k_add",
    (byte*)"k_sub",
    (byte*)"k_mul",
    (byte*)"k_div",
    (byte*)"k_idiv",
    (byte*)"k_rem",
    (byte*)"k_divrem",
    (byte*)"k_iand",
    (byte*)"k_ior",
    (byte*)"k_ixor",
    (byte*)"k_shl",
    (byte*)"k_shr",
    (byte*)"k_in",
    (byte*)"k_notin",
    (byte*)"k_inrev",
    (byte*)"k_eq",
    (byte*)"k_ne",
    (byte*)"k_lt",
    (byte*)"k_le",
    (byte*)"k_ge",
    (byte*)"k_gt",
    (byte*)"k_min",
    (byte*)"k_max",
    (byte*)"k_concat",
    (byte*)"k_append",
    (byte*)"k_power",
    (byte*)"k_atan2",
    (byte*)"k_addto",
    (byte*)"k_subto",
    (byte*)"k_multo",
    (byte*)"k_divto",
    (byte*)"k_idivto",
    (byte*)"k_iandto",
    (byte*)"k_iorto",
    (byte*)"k_ixorto",
    (byte*)"k_shlto",
    (byte*)"k_shrto",
    (byte*)"k_minto",
    (byte*)"k_maxto",
    (byte*)"k_concatto",
    (byte*)"k_appendto",
    (byte*)"k_pushix",
    (byte*)"k_pushdotix",
    (byte*)"k_pushkeyix",
    (byte*)"k_pushkeyixd",
    (byte*)"k_pushixref",
    (byte*)"k_pushdotixref",
    (byte*)"k_pushkeyixref",
    (byte*)"k_pushbyteix",
    (byte*)"k_pushbyteixref",
    (byte*)"k_appendset",
    (byte*)"k_pushdotm",
    (byte*)"k_pushdott",
    (byte*)"k_push_ad",
    (byte*)"k_push_try",
    (byte*)"k_raise",
    (byte*)"k_applyop",
    (byte*)"k_makeiter",
    (byte*)"k_forall",
    (byte*)"k_forallx",
    (byte*)"k_foreach",
    (byte*)"k_foreachx",
    (byte*)"k_expandrange",
    (byte*)"fixup_asm",
    (byte*)"asmavailable",
    (byte*)"addcountint",
    (byte*)"addcountext",
    (byte*)"showasmcmd",
    (byte*)"disploop_asm",
    (byte*)"getasmjump",
    (byte*)"qcompiler",
    (byte*)"qcstart",
    (byte*)"do_loadmodules",
    (byte*)"loadmainmodule",
    (byte*)"loadmodule",
    (byte*)"loadimport",
    (byte*)"readimportlist",
    (byte*)"initlogfile",
    (byte*)"closelogfile",
    (byte*)"initdata",
    (byte*)"initsearchdirs",
    (byte*)"getmodulestr",
    (byte*)"findmodule",
    (byte*)"checkname",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"do_parse",
    (byte*)"do_codegen",
    (byte*)"showast",
    (byte*)"showstflat",
    (byte*)"showsttree",
    (byte*)"showpcl",
    (byte*)"showgenfields",
    (byte*)"loaderror",
    (byte*)"do_showprogdiags_pc",
    (byte*)"getsyscmdline",
    (byte*)"showmodules",
    (byte*)"do_compilemodules",
    (byte*)"compilemodule",
    (byte*)"starttiming",
    (byte*)"showtiming",
    (byte*)"do_writeqafile",
    (byte*)"checkkeyword",
    (byte*)"readinttoken",
    (byte*)"do_loadqafile",
    (byte*)"showinttiming",
    (byte*)"do_writepcfile",
    (byte*)"writesymbols",
    (byte*)"showpcsymbol",
    (byte*)"writepccode2pc",
    (byte*)"writestructfields",
    (byte*)"fixup_genfields",
    (byte*)"showoptions",
    (byte*)"showoutput",
    (byte*)"showhelp",
    (byte*)"nextcmd",
    (byte*)"writedocs",
    (byte*)"prterror",
    (byte*)"serror",
    (byte*)"gerror",
    (byte*)"nxerror",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"inittypetables",
    (byte*)"nextpoweroftwo",
    (byte*)"initpcdest",
    (byte*)"getpcpos",
    (byte*)"setpcpos",
    (byte*)"writepcdata",
    (byte*)"writezstring",
    (byte*)"writezblock",
    (byte*)"writezint",
    (byte*)"writezint4",
    (byte*)"writezrange",
    (byte*)"writezreal",
    (byte*)"writezeof",
    (byte*)"ipower",
    (byte*)"gs_additem",
    (byte*)"isalphanum",
    (byte*)"gs_copytostr",
    (byte*)"outpcbyte",
    (byte*)"outpcword",
    (byte*)"outpcword16",
    (byte*)"lexreadtoken",
    (byte*)"lxreadstring",
    (byte*)"readnumber",
    (byte*)"readrealnumber",
    (byte*)"readexponent",
    (byte*)"lxerror",
    (byte*)"printsymbol",
    (byte*)"stringtonumber",
    (byte*)"lexsetup",
    (byte*)"printstrn",
    (byte*)"scannumber",
    (byte*)"readrawstring",
    (byte*)"lookup",
    (byte*)"gethashvaluez",
    (byte*)"inithashtable",
    (byte*)"dolexdirective",
    (byte*)"lexreadline",
    (byte*)"startlex",
    (byte*)"convertzstring",
    (byte*)"addnamestr",
    (byte*)"ps1",
    (byte*)"ps2",
    (byte*)"ps",
    (byte*)"lex",
    (byte*)"showhashtablesize",
    (byte*)"addmacro",
    (byte*)"stackmacro",
    (byte*)"unstackmacro",
    (byte*)"parsemodule",
    (byte*)"readmoduledefs",
    (byte*)"initparser",
    (byte*)"skipsemi",
    (byte*)"addalias",
    (byte*)"makeblock",
    (byte*)"convertstmtexpr",
    (byte*)"checkequals",
    (byte*)"getcurrline",
    (byte*)"checkbegin",
    (byte*)"checkbeginend",
    (byte*)"checkend",
    (byte*)"addgenfield",
    (byte*)"readvardef",
    (byte*)"readconstdef",
    (byte*)"readexpression",
    (byte*)"readfactor",
    (byte*)"readterm",
    (byte*)"readlbrack",
    (byte*)"addlistunit",
    (byte*)"addlistparam",
    (byte*)"readlsqbrack",
    (byte*)"readcast",
    (byte*)"readopc",
    (byte*)"readsprint",
    (byte*)"readsread",
    (byte*)"readcompilervar",
    (byte*)"readcastx",
    (byte*)"checksymbol",
    (byte*)"readtypespec",
    (byte*)"readhostparams",
    (byte*)"readslist",
    (byte*)"readindex",
    (byte*)"readkeyindex",
    (byte*)"readdotsuffix",
    (byte*)"isconstexpr",
    (byte*)"readconstexpr",
    (byte*)"readconstexprvalue",
    (byte*)"readconstint",
    (byte*)"readprocdef",
    (byte*)"readprocdecl",
    (byte*)"readparams",
    (byte*)"readblock",
    (byte*)"readexecstmt",
    (byte*)"readstmtexpr",
    (byte*)"readcondsuffix",
    (byte*)"readif",
    (byte*)"readgoto",
    (byte*)"readunless",
    (byte*)"readswitchcase",
    (byte*)"readstop",
    (byte*)"readreturn",
    (byte*)"readdo",
    (byte*)"readto",
    (byte*)"readwhile",
    (byte*)"readrepeat",
    (byte*)"readloopcontrol",
    (byte*)"readprint",
    (byte*)"readread",
    (byte*)"readtry",
    (byte*)"readraise",
    (byte*)"readfor",
    (byte*)"readforall",
    (byte*)"readtypedef",
    (byte*)"readstructdef",
    (byte*)"readstructfields",
    (byte*)"readtabledef",
    (byte*)"readclassdef",
    (byte*)"readclassbody",
    (byte*)"readenumtype",
    (byte*)"duplfield",
    (byte*)"readrecordfields",
    (byte*)"readimportmodule",
    (byte*)"readimportbody",
    (byte*)"createlabel",
    (byte*)"createprocdef",
    (byte*)"createproccall",
    (byte*)"readequivfield",
    (byte*)"testconstruct",
    (byte*)"readapplyop",
    (byte*)"newstrec",
    (byte*)"initqclib",
    (byte*)"getduplnameptr",
    (byte*)"adddef",
    (byte*)"adddef_nodupl",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"printstflat",
    (byte*)"newunitrec",
    (byte*)"createname",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createunit3",
    (byte*)"createconstunit",
    (byte*)"createstringconstunit",
    (byte*)"getoptocode",
    (byte*)"checkpackedtype",
    (byte*)"checkunpackedtype",
    (byte*)"checkdlltype",
    (byte*)"createtype",
    (byte*)"createusertype",
    (byte*)"createusertypefromstr",
    (byte*)"getconstvalue",
    (byte*)"getrangelwb",
    (byte*)"getrangeupb",
    (byte*)"getrangelwbunit",
    (byte*)"getrangeupbunit",
    (byte*)"createarraymode",
    (byte*)"nextautotype",
    (byte*)"createstringmode",
    (byte*)"createrefpackmode",
    (byte*)"getscope",
    (byte*)"setnameptr",
    (byte*)"printcode_all",
    (byte*)"printcode",
    (byte*)"printunit",
    (byte*)"printunitlist",
    (byte*)"getprefix",
    (byte*)"getdottedname",
    (byte*)"getlineinfok",
    (byte*)"getavname",
    (byte*)"unionstr_clear",
    (byte*)"unionstr_append",
    (byte*)"unionstr_concat",
    (byte*)"unionstr_last",
    (byte*)"unionstr_copy",
    (byte*)"unionstr_print",
    (byte*)"createrecordmode",
    (byte*)"createenummode",
    (byte*)"convertstring",
    (byte*)"strexpr",
    (byte*)"jeval",
    (byte*)"getopcjname",
    (byte*)"strmode",
    (byte*)"istrmode",
    (byte*)"countunits",
    (byte*)"finddefstr",
    (byte*)"purgesymbol",
    (byte*)"purgesymbollist",
    (byte*)"purgeprocs",
    (byte*)"purgeproc",
    (byte*)"printmodelist",
    (byte*)"printgenfieldtable",
    (byte*)"addtoproclist",
    (byte*)"px_typecheck",
    (byte*)"resolvetopname",
    (byte*)"px_name",
    (byte*)"evalbinop",
    (byte*)"evalbinop_real",
    (byte*)"makenewconst",
    (byte*)"finddupl",
    (byte*)"px_dot",
    (byte*)"evalmonop",
    (byte*)"checkdict",
    (byte*)"checkconstlist",
    (byte*)"do_tag",
    (byte*)"codegen",
    (byte*)"convertalltypes",
    (byte*)"scanidata",
    (byte*)"genidata",
    (byte*)"initgenpcl",
    (byte*)"doprogramstartup",
    (byte*)"do_block",
    (byte*)"do_print",
    (byte*)"do_fprint",
    (byte*)"do_read",
    (byte*)"do_assign",
    (byte*)"do_to",
    (byte*)"do_while",
    (byte*)"do_repeat",
    (byte*)"do_forstep",
    (byte*)"do_forall",
    (byte*)"do_do",
    (byte*)"do_cfor",
    (byte*)"do_if",
    (byte*)"do_longif",
    (byte*)"do_callproc",
    (byte*)"do_callhostproc",
    (byte*)"do_return",
    (byte*)"genstartproc",
    (byte*)"do_procdef",
    (byte*)"genprocentry",
    (byte*)"genprocexit",
    (byte*)"do_preincr",
    (byte*)"do_exit",
    (byte*)"do_goto",
    (byte*)"do_switch",
    (byte*)"do_simpleswitch",
    (byte*)"do_case",
    (byte*)"do_try",
    (byte*)"do_applyop",
    (byte*)"evalref",
    (byte*)"getpclop",
    (byte*)"genjumpl",
    (byte*)"definelabel",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"stacklooplabels",
    (byte*)"unstacklooplabels",
    (byte*)"findlooplabel",
    (byte*)"issimpleparam",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"reversecond",
    (byte*)"do_convert",
    (byte*)"do_selectx",
    (byte*)"do_calldll",
    (byte*)"islogical",
    (byte*)"do_and",
    (byte*)"do_or",
    (byte*)"do_callptr",
    (byte*)"do_callmproc",
    (byte*)"checkblockreturn",
    (byte*)"genfree",
    (byte*)"do_clamp",
    (byte*)"do_applyopx",
    (byte*)"do_calldllvar",
    (byte*)"callhostfn",
    (byte*)"extractparams",
    (byte*)"unitstoarray",
    (byte*)"do_idiv",
    (byte*)"ispoweroftwo",
    (byte*)"genpushint",
    (byte*)"checkeqeq",
    (byte*)"initpcl",
    (byte*)"initpcldata",
    (byte*)"initpclgen",
    (byte*)"writepcl3",
    (byte*)"writepclopnd3",
    (byte*)"writepccode",
    (byte*)"genpc",
    (byte*)"genopnd_int",
    (byte*)"genopnd_s",
    (byte*)"genpc_int",
    (byte*)"genpc_int2",
    (byte*)"genpc_int4",
    (byte*)"genpc_s",
    (byte*)"genpc_str",
    (byte*)"genopnd_str",
    (byte*)"genpc_lab",
    (byte*)"isframe_s",
    (byte*)"converttype",
    (byte*)"scanstruct",
    (byte*)"scanrecord",
    (byte*)"shiftflagsleft",
    (byte*)"gstest",
    (byte*)"addstringtotable",
    (byte*)"getintlib",
""};
static int64 msysc__fnnprocs=1243;
static int64 msysc_needgap = (int64)0;
static int64 msysc_b_outdev = (int64)1;
static void *  msysc_b_outchan = 0;
static void *  msysc_iochanstack[10];
static int64 msysc_iodevstack[10];
static int64 msysc_niostack = (int64)0;
int64 msysc_nsysparams;
byte *  msysc_sysparams[128];
static uint64 msysc_callbackstack[9][8];
static int64 msysc_ncallbacks = (int64)0;
uint64 mlib_allocupper[301];
int64 mlib_alloccode;
int64 mlib_allocbytes;
int64 mlib_fdebug = (int64)0;
int64 mlib_rfsize;
static uint64 mlib_maxmemory;
static int64 mlib_maxalloccode;
static byte mlib_pcm_setup = (uint8)0u;
static int64 mlib_show = (int64)0;
int64 mlib_memtotal = (int64)0;
int64 mlib_smallmemtotal = (int64)0;
int64 mlib_smallmemobjs = (int64)0;
int64 mlib_maxmemtotal = (int64)0;
static int32 *  mlib_memalloctable[100001];
static int32 mlib_memallocsize[100001];
static byte *  mlib_pcheapstart;
static byte *  mlib_pcheapend;
static byte *  mlib_pcheapptr;
static byte mlib_sizeindextable[2049];
uint64 *  mlib_freelist[9];
byte *  mlib_pmnames[6] = {(byte*)"pm_end",(byte*)"pm_option",(byte*)"pm_sourcefile",(byte*)"pm_libfile",(byte*)"pm_colon",(byte*)"pm_extra"};
static int64 osnos_init_flag = (int64)0;
byte *  pc_types_stdtypenames[54] =     {
    (byte*)"tvoid",
    (byte*)"tint",
    (byte*)"tword",
    (byte*)"treal",
    (byte*)"trange",
    (byte*)"tstring",
    (byte*)"twstring",
    (byte*)"tlongint",
    (byte*)"trational",
    (byte*)"tset",
    (byte*)"tdict",
    (byte*)"tword128",
    (byte*)"tenum",
    (byte*)"ttype",
    (byte*)"toperator",
    (byte*)"tsymbol",
    (byte*)"tretaddr",
    (byte*)"texception",
    (byte*)"trefproc",
    (byte*)"trefdllproc",
    (byte*)"treflabel",
    (byte*)"tstringz",
    (byte*)"trefvar",
    (byte*)"trefpacked",
    (byte*)"trefbit",
    (byte*)"trecordlink",
    (byte*)"treflist",
    (byte*)"trefarray",
    (byte*)"trefbits",
    (byte*)"tlist",
    (byte*)"tarray",
    (byte*)"tbits",
    (byte*)"trecord",
    (byte*)"tstruct",
    (byte*)"tuser",
    (byte*)"tvariant",
    (byte*)"tc8",
    (byte*)"ti8",
    (byte*)"ti16",
    (byte*)"ti32",
    (byte*)"ti64",
    (byte*)"tbit",
    (byte*)"tbit2",
    (byte*)"tbit4",
    (byte*)"tu8",
    (byte*)"tu16",
    (byte*)"tu32",
    (byte*)"tu64",
    (byte*)"tr32",
    (byte*)"tr64",
    (byte*)"tintm",
    (byte*)"twordm",
    (byte*)"trefm",
    (byte*)"tlast"
};
int64 pc_types_stdtypewidths[54] =     {
    (int64)128,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)0,
    (int64)0,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)128,
    (int64)8,
    (int64)8,
    (int64)16,
    (int64)32,
    (int64)64,
    (int64)1,
    (int64)2,
    (int64)4,
    (int64)8,
    (int64)16,
    (int64)32,
    (int64)64,
    (int64)32,
    (int64)64,
    (int64)32,
    (int64)32,
    (int64)64,
    (int64)0
};
byte *  pc_decls_usercatnames[3] = {(byte*)"std_cat",(byte*)"anon_cat",(byte*)"user_cat"};
int64 pc_decls_ntypes;
int32 pc_decls_ttmodule[300];
struct pc_decls_strec *  pc_decls_ttnamedef[300];
int32 pc_decls_ttbasetype[300];
byte *  pc_decls_ttname[300];
int32 pc_decls_ttbitwidth[300];
int64 pc_decls_ttsize[300];
int32 pc_decls_ttlower[300];
uint32 pc_decls_ttlength[300];
int32 pc_decls_ttstartfield[300];
int32 pc_decls_ttstructfields[300];
int32 pc_decls_tttarget[300];
byte pc_decls_ttusercat[300];
byte pc_decls_typestarterset[300];
byte *  pc_decls_objtypenames[3] = {(byte*)"normal_obj",(byte*)"slice_obj",(byte*)"extslice_obj"};
struct pc_decls_objrec *  pc_decls_chrtable[256];
struct pc_decls_modulerec pc_decls_moduletable[51];
int64 pc_decls_nmodules;
byte *  pc_decls_pendingmodules[50];
int64 pc_decls_npendingmodules;
int64 pc_decls_currmoduleno;
struct pc_decls_modulerec *  pc_decls_currmodule;
byte *  pc_decls_searchdirs[6];
int64 pc_decls_nsearchdirs = (int64)0;
struct pc_decls_strec *  pc_decls_stprogram;
void *  pc_decls_logdev;
int64 pc_decls_optflag = (int64)0;
struct pc_decls_genfieldnamerec pc_decls_genfieldnames[1000];
struct pc_decls_genfielddatarec pc_decls_genfielddata[1000];
uint64 *  pc_decls_genfieldpcaddress[1000];
int64 pc_decls_ngenfieldnames;
int64 pc_decls_ngenfielddata;
byte *  pc_decls_libpaths[10];
int64 pc_decls_nlibpaths;
int64 pc_decls_fverbose = (int64)0;
int64 pc_decls_ftrace = (int64)0;
int64 pc_decls_fdtrace = (int64)0;
int64 pc_decls_foptimise = (int64)0;
int64 pc_decls_mlineno = (int64)0;
int64 pc_decls_tlex = (int64)0;
int64 pc_decls_exportsprepass = (int64)0;
int64 pc_decls_debug = (int64)0;
int64 pc_decls_nnames;
int64 pc_decls_nchecks;
int64 pc_decls_forcheck;
int64 pc_decls_nclashes;
int64 pc_decls_nlookups;
int64 pc_decls_allnames;
int64 pc_decls_allfoundnames;
int64 pc_decls_allnotfoundnames;
struct pc_decls_varrec pc_decls_ttdeststrv;
struct pc_decls_varrec *  pc_decls_ttdeststr = &pc_decls_ttdeststrv;
int64 pc_decls_totalstrings = (int64)0;
byte *  pc_decls_dispatchnames[5] = {(byte*)"-lab",(byte*)"-fn",(byte*)"-sw",(byte*)"-deb",(byte*)"-asm"};
struct pc_decls_varrec *  pc_decls_sptr;
byte *  pc_decls_frameptr;
uint64 *  pc_decls_pcptr;
struct pc_decls_varrec (*pc_decls_varstack)[];
struct pc_decls_objrec (*pc_decls_stringobjtable)[];
int64 pc_decls_dllindex;
int64 pc_decls_dllcallindex;
int64 pc_decls_dllparams[30];
int64 pc_decls_dllcallstack[30];
int64 pc_decls_ndlltable;
int64 pc_decls_ndllproctable;
byte *  pc_decls_dlltable[50];
uint64 pc_decls_dllinsttable[50];
struct pc_decls_dllprocrec pc_decls_dllproctable[500];
void (*pc_decls_fprintf_ptr)(void);
void (*pc_decls_fgets_ptr)(void);
void (*pc_decls_pcl_callbackfn)(void) = 0;
byte *  pc_decls_pcerror_mess = 0;
struct pc_decls_varrec pc_decls_emptystringvar;
int64 pc_decls_ncmdparams;
byte *  pc_decls_cmdparamtable[33];
struct pc_decls_procrec *  pc_decls_proclist;
int64 pc_decls_nproclist;
int64 pc_decls_nstrings = (int64)0;
int64 pc_decls_nsymbols = (int64)0;
int64 pc_decls_nstructfields = (int64)0;
byte * (*pc_decls_stringtable)[];
int64 (*pc_decls_stringlentable)[];
struct pc_decls_strec (*pc_decls_pcsymboltable)[];
struct pc_decls_fieldrec (*pc_decls_pcfieldtable)[];
int64 pc_decls_runfrompc = (int64)0;
byte *  pc_decls_extrafiles[10];
byte *  pc_decls_extratext[10];
int64 pc_decls_extrasizes[10];
int64 pc_decls_nextra;
byte *  pc_decls_err_message;
struct pc_decls_varrec pc_decls_err_var1;
struct pc_decls_varrec pc_decls_err_var2;
uint64 *  pc_decls_err_pcptr;
uint64 *  pc_decls_stopseq;
uint64 *  pc_decls_raiseseq;
uint64 (*pc_decls_pccode)[];
int64 pc_decls_npccode = (int64)0;
int64 pc_decls_pcindex;
uint16 (*pc_decls_linetable)[];
int64 pc_decls_cmdnopnds[217];
int64 pc_decls_lastticks = (int64)0;
int64 pc_decls_ncalls;
uint64 * (*pc_decls_neg_table[301])(void);
uint64 * (*pc_decls_abs_table[301])(void);
uint64 * (*pc_decls_inot_table[301])(void);
uint64 * (*pc_decls_istrue_table[301])(void);
uint64 * (*pc_decls_jumpf_table[301])(void);
uint64 * (*pc_decls_jumpt_table[301])(void);
uint64 * (*pc_decls_len_table[301])(void);
uint64 * (*pc_decls_lwb_table[301])(void);
uint64 * (*pc_decls_upb_table[301])(void);
uint64 * (*pc_decls_bounds_table[301])(void);
uint64 * (*pc_decls_incr_table[301])(void);
uint64 * (*pc_decls_decr_table[301])(void);
uint64 * (*pc_decls_add_table[301])(void);
uint64 * (*pc_decls_sub_table[301])(void);
uint64 * (*pc_decls_mul_table[301])(void);
uint64 * (*pc_decls_div_table[301])(void);
uint64 * (*pc_decls_idiv_table[301])(void);
uint64 * (*pc_decls_rem_table[301])(void);
uint64 * (*pc_decls_iand_table[301])(void);
uint64 * (*pc_decls_ior_table[301])(void);
uint64 * (*pc_decls_ixor_table[301])(void);
uint64 * (*pc_decls_shl_table[301])(void);
uint64 * (*pc_decls_shr_table[301])(void);
uint64 * (*pc_decls_min_table[301])(void);
uint64 * (*pc_decls_max_table[301])(void);
uint64 * (*pc_decls_jumpeq_table[301])(void);
uint64 * (*pc_decls_jumpne_table[301])(void);
uint64 * (*pc_decls_jumplt_table[301])(void);
uint64 * (*pc_decls_jumpgt_table[301])(void);
uint64 * (*pc_decls_jumple_table[301])(void);
uint64 * (*pc_decls_jumpge_table[301])(void);
uint64 * (*pc_decls_jumptesteq_table[301])(void);
uint64 * (*pc_decls_jumptestne_table[301])(void);
uint64 * (*pc_decls_jumpfalse_table[301])(void);
uint64 * (*pc_decls_jumptrue_table[301])(void);
uint64 * (*pc_decls_eq_table[301])(void);
uint64 * (*pc_decls_lt_table[301])(void);
uint64 * (*pc_decls_le_table[301])(void);
uint64 * (*pc_decls_concat_table[301])(void);
uint64 * (*pc_decls_append_table[301])(void);
uint64 * (*pc_decls_addto_table[301])(void);
uint64 * (*pc_decls_subto_table[301])(void);
uint64 * (*pc_decls_multo_table[301])(void);
uint64 * (*pc_decls_divto_table[301])(void);
uint64 * (*pc_decls_idivto_table[301])(void);
uint64 * (*pc_decls_iandto_table[301])(void);
uint64 * (*pc_decls_iorto_table[301])(void);
uint64 * (*pc_decls_ixorto_table[301])(void);
uint64 * (*pc_decls_shlto_table[301])(void);
uint64 * (*pc_decls_shrto_table[301])(void);
uint64 * (*pc_decls_minto_table[301])(void);
uint64 * (*pc_decls_maxto_table[301])(void);
uint64 * (*pc_decls_concatto_table[301])(void);
uint64 * (*pc_decls_appendto_table[301])(void);
uint64 * (*(*pc_decls_opc_tableptr)[301])(void);
void (*pc_decls_new_table[301])(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *);
void (*pc_decls_free_table[301])(struct pc_decls_varrec *);
void (*pc_decls_dupl_table[301])(struct pc_decls_varrec *);
void (*pc_decls_tostr_table[301])(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_fmtrec *,struct pc_decls_objrec *);
uint64 * (*pc_decls_in_dtable[301])(int64);
uint64 * (*pc_decls_inrev_dtable[301])(int64);
uint64 * (*pc_decls_pushix_dtable[301])(void);
uint64 * (*pc_decls_pushixref_dtable[301])(void);
uint64 * (*pc_decls_pushdotix_dtable[301])(void);
uint64 * (*pc_decls_pushdotixref_dtable[301])(void);
uint64 * (*pc_decls_mixed_dtable[301])(void);
uint64 * (*pc_decls_convert_dtable[301])(int64);
uint64 * (*pc_decls_mulx_dtable[301])(void);
uint64 * (*pc_decls_add_dtable[301])(void);
uint64 * (*pc_decls_sub_dtable[301])(void);
uint64 * (*pc_decls_mul_dtable[301])(void);
uint64 * (*pc_decls_div_dtable[301])(void);
uint64 * (*pc_decls_idiv_dtable[301])(void);
uint64 * (*pc_decls_rem_dtable[301])(void);
uint64 * (*pc_decls_iand_dtable[301])(void);
uint64 * (*pc_decls_ior_dtable[301])(void);
uint64 * (*pc_decls_ixor_dtable[301])(void);
uint64 * (*pc_decls_shl_dtable[301])(void);
uint64 * (*pc_decls_shr_dtable[301])(void);
uint64 * (*pc_decls_min_dtable[301])(void);
uint64 * (*pc_decls_max_dtable[301])(void);
uint64 * (*pc_decls_jumpeq_dtable[301])(void);
uint64 * (*pc_decls_jumpne_dtable[301])(void);
uint64 * (*pc_decls_jumplt_dtable[301])(void);
uint64 * (*pc_decls_jumple_dtable[301])(void);
uint64 * (*pc_decls_jumpge_dtable[301])(void);
uint64 * (*pc_decls_jumpgt_dtable[301])(void);
uint64 * (*pc_decls_addto_dtable[301])(void);
uint64 * (*pc_decls_subto_dtable[301])(void);
uint64 * (*pc_decls_multo_dtable[301])(void);
uint64 * (*pc_decls_divto_dtable[301])(void);
uint64 * (*pc_decls_idivto_dtable[301])(void);
uint64 * (*pc_decls_iandto_dtable[301])(void);
uint64 * (*pc_decls_iorto_dtable[301])(void);
uint64 * (*pc_decls_ixorto_dtable[301])(void);
uint64 * (*pc_decls_shlto_dtable[301])(void);
uint64 * (*pc_decls_shrto_dtable[301])(void);
uint64 * (*pc_decls_minto_dtable[301])(void);
uint64 * (*pc_decls_maxto_dtable[301])(void);
int64 pc_decls_nexttypesig = (int64)0;
byte pc_decls_sigmap[256][256];
int64 pc_decls_overloadtype = (int64)0;
byte *  pq_common_opndnames[18] =     {
    (byte*)"cnone",
    (byte*)"cmemory",
    (byte*)"cframe",
    (byte*)"cproc",
    (byte*)"cdllproc",
    (byte*)"cdllvar",
    (byte*)"cfield",
    (byte*)"cgenfield",
    (byte*)"clabel",
    (byte*)"cint32",
    (byte*)"cint",
    (byte*)"cword",
    (byte*)"creal",
    (byte*)"crange",
    (byte*)"cstring",
    (byte*)"ctype",
    (byte*)"coperator",
    (byte*)"?"
};
byte *  pq_common_cmdnames[217] =     {
    (byte*)"kzero",
    (byte*)"knop",
    (byte*)"kprocstart",
    (byte*)"kprocend",
    (byte*)"kendmodule",
    (byte*)"kpush_m",
    (byte*)"kpush_f",
    (byte*)"kpush_am",
    (byte*)"kpush_af",
    (byte*)"kpush_ap",
    (byte*)"kpush_al",
    (byte*)"kpush_ci",
    (byte*)"kpush_cw",
    (byte*)"kpush_cr",
    (byte*)"kpush_cn",
    (byte*)"kpush_cs",
    (byte*)"kpush_t",
    (byte*)"kpush_op",
    (byte*)"kpushz",
    (byte*)"kpushz_void",
    (byte*)"kpushz_str",
    (byte*)"kpushz_list",
    (byte*)"kpushz_listl",
    (byte*)"kpushz_set",
    (byte*)"kpushz_arrayl",
    (byte*)"kpop_m",
    (byte*)"kpop_f",
    (byte*)"kstore_m",
    (byte*)"kstore_f",
    (byte*)"kpushptr",
    (byte*)"kpopptr",
    (byte*)"kstoreptr",
    (byte*)"kzpop_m",
    (byte*)"kzpop_f",
    (byte*)"kzstore_m",
    (byte*)"kzstore_f",
    (byte*)"kcopy",
    (byte*)"kswap",
    (byte*)"kconvptr",
    (byte*)"kjump",
    (byte*)"kjumpptr",
    (byte*)"kjumptrue",
    (byte*)"kjumpfalse",
    (byte*)"kjumpdef",
    (byte*)"kjumpvoid",
    (byte*)"kjumpeq",
    (byte*)"kjumpne",
    (byte*)"kjumplt",
    (byte*)"kjumple",
    (byte*)"kjumpge",
    (byte*)"kjumpgt",
    (byte*)"kjumptesteq",
    (byte*)"kjumptestne",
    (byte*)"kjumplabel",
    (byte*)"kjumpclabel",
    (byte*)"kswitch",
    (byte*)"kcswitch",
    (byte*)"knew",
    (byte*)"kto_f",
    (byte*)"kfor_fci",
    (byte*)"kfor_ff",
    (byte*)"kford_fci",
    (byte*)"kford_ff",
    (byte*)"kcall",
    (byte*)"kcallptr",
    (byte*)"kreturn",
    (byte*)"kstartdll",
    (byte*)"kpushdll",
    (byte*)"kcalldll",
    (byte*)"kcallhost",
    (byte*)"kstackframe",
    (byte*)"kfree",
    (byte*)"kaddsp",
    (byte*)"kstop",
    (byte*)"ktest",
    (byte*)"kmakelist",
    (byte*)"kmakerecord",
    (byte*)"kmakearray",
    (byte*)"kmakestruct",
    (byte*)"kmakeset",
    (byte*)"kmakerange",
    (byte*)"kmakedict",
    (byte*)"kpushdot",
    (byte*)"kpushdotref",
    (byte*)"ksoftconv",
    (byte*)"khardconv",
    (byte*)"kmixed",
    (byte*)"kincrptr",
    (byte*)"kincrto_m",
    (byte*)"kincrto_f",
    (byte*)"kloadincr",
    (byte*)"kincrload",
    (byte*)"kdecrptr",
    (byte*)"kdecrto_m",
    (byte*)"kdecrto_f",
    (byte*)"kloaddecr",
    (byte*)"kdecrload",
    (byte*)"kincr",
    (byte*)"kdecr",
    (byte*)"kneg",
    (byte*)"kabs",
    (byte*)"knot",
    (byte*)"kinot",
    (byte*)"kistrue",
    (byte*)"kasc",
    (byte*)"kchr",
    (byte*)"ksqrt",
    (byte*)"ksqr",
    (byte*)"kcube",
    (byte*)"ksin",
    (byte*)"kcos",
    (byte*)"ktan",
    (byte*)"kasin",
    (byte*)"kacos",
    (byte*)"katan",
    (byte*)"ksign",
    (byte*)"kln",
    (byte*)"klog",
    (byte*)"klg",
    (byte*)"kexp",
    (byte*)"kround",
    (byte*)"kfloor",
    (byte*)"kceil",
    (byte*)"kfract",
    (byte*)"knegto",
    (byte*)"kabsto",
    (byte*)"knotto",
    (byte*)"kinotto",
    (byte*)"klen",
    (byte*)"klwb",
    (byte*)"kupb",
    (byte*)"kbounds",
    (byte*)"kbits",
    (byte*)"kbytes",
    (byte*)"ktype",
    (byte*)"kelemtype",
    (byte*)"kbasetype",
    (byte*)"kminval",
    (byte*)"kmaxval",
    (byte*)"kisint",
    (byte*)"kisreal",
    (byte*)"kisstring",
    (byte*)"kisrange",
    (byte*)"kisnumber",
    (byte*)"kisarray",
    (byte*)"kisrecord",
    (byte*)"kispointer",
    (byte*)"kismutable",
    (byte*)"kisset",
    (byte*)"kisvoid",
    (byte*)"kisdef",
    (byte*)"ktostr",
    (byte*)"kisequal",
    (byte*)"kadd",
    (byte*)"ksub",
    (byte*)"kmul",
    (byte*)"kdiv",
    (byte*)"kidiv",
    (byte*)"krem",
    (byte*)"kdivrem",
    (byte*)"kiand",
    (byte*)"kior",
    (byte*)"kixor",
    (byte*)"kshl",
    (byte*)"kshr",
    (byte*)"kin",
    (byte*)"knotin",
    (byte*)"kinrev",
    (byte*)"keq",
    (byte*)"kne",
    (byte*)"klt",
    (byte*)"kle",
    (byte*)"kge",
    (byte*)"kgt",
    (byte*)"kmin",
    (byte*)"kmax",
    (byte*)"kconcat",
    (byte*)"kappend",
    (byte*)"kpower",
    (byte*)"katan2",
    (byte*)"kaddto",
    (byte*)"ksubto",
    (byte*)"kmulto",
    (byte*)"kdivto",
    (byte*)"kidivto",
    (byte*)"kiandto",
    (byte*)"kiorto",
    (byte*)"kixorto",
    (byte*)"kshlto",
    (byte*)"kshrto",
    (byte*)"kminto",
    (byte*)"kmaxto",
    (byte*)"kconcatto",
    (byte*)"kappendto",
    (byte*)"kpushix",
    (byte*)"kpushdotix",
    (byte*)"kpushkeyix",
    (byte*)"kpushkeyixd",
    (byte*)"kpushixref",
    (byte*)"kpushdotixref",
    (byte*)"kpushkeyixref",
    (byte*)"kpushbyteix",
    (byte*)"kpushbyteixref",
    (byte*)"kappendset",
    (byte*)"kpushdotm",
    (byte*)"kpushdott",
    (byte*)"kpush_ad",
    (byte*)"kpush_try",
    (byte*)"kraise",
    (byte*)"kapplyop",
    (byte*)"kmakeiter",
    (byte*)"kforall",
    (byte*)"kforallx",
    (byte*)"kforeach",
    (byte*)"kforeachx",
    (byte*)"kexpandrange",
    (byte*)"klastcmd"
};
byte pq_common_cmdfmt[217][4] =     {
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)3u,(uint8)9u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)1u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)2u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)1u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)2u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)3u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)10u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)11u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)12u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)13u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)14u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)16u,(uint8)9u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)9u,(uint8)0u,(uint8)0u},
    {(uint8)1u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)2u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)1u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)2u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)1u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)2u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)1u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)2u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)9u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)9u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)9u,(uint8)9u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)2u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)2u,(uint8)9u,(uint8)0u},
    {(uint8)8u,(uint8)2u,(uint8)2u,(uint8)0u},
    {(uint8)8u,(uint8)2u,(uint8)9u,(uint8)0u},
    {(uint8)8u,(uint8)2u,(uint8)2u,(uint8)0u},
    {(uint8)3u,(uint8)9u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)9u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)4u,(uint8)9u,(uint8)15u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)9u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)15u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)9u,(uint8)15u,(uint8)15u},
    {(uint8)9u,(uint8)15u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)7u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)7u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)1u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)2u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)1u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)2u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)3u,(uint8)0u,(uint8)0u},
    {(uint8)15u,(uint8)15u,(uint8)0u,(uint8)0u},
    {(uint8)4u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)9u,(uint8)9u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)9u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)8u,(uint8)2u,(uint8)2u,(uint8)0u},
    {(uint8)8u,(uint8)2u,(uint8)2u,(uint8)2u},
    {(uint8)8u,(uint8)2u,(uint8)2u,(uint8)0u},
    {(uint8)8u,(uint8)2u,(uint8)2u,(uint8)2u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u},
    {(uint8)0u,(uint8)0u,(uint8)0u,(uint8)0u}
};
void *  pq_common_cmdmap[217];
byte *  pq_common_bcdirnames[13] =     {
    (byte*)"kkpclversion",
    (byte*)"kkmoduletable",
    (byte*)"kkdlltable",
    (byte*)"kkdllproctable",
    (byte*)"kksymboltable",
    (byte*)"kktypetable",
    (byte*)"kkgenfieldnames",
    (byte*)"kkgenfielddata",
    (byte*)"kkstringtable",
    (byte*)"kkstructtable",
    (byte*)"kkpccode",
    (byte*)"kkend",
    (byte*)"kknewstringtable"
};
byte *  pq_common_hostfnnames[72] =     {
    (byte*)"host_dummy",
    (byte*)"host_startprint",
    (byte*)"host_startprintcon",
    (byte*)"host_strstartprint",
    (byte*)"host_setformat",
    (byte*)"host_endprint",
    (byte*)"host_strendprint",
    (byte*)"host_print",
    (byte*)"host_dprint",
    (byte*)"host_println",
    (byte*)"host_printnogap",
    (byte*)"host_readln",
    (byte*)"host_sreadln",
    (byte*)"host_sread",
    (byte*)"host_rereadln",
    (byte*)"host_reread",
    (byte*)"host_strtoval",
    (byte*)"host_tostr",
    (byte*)"host_leftstr",
    (byte*)"host_rightstr",
    (byte*)"host_convlc",
    (byte*)"host_convuc",
    (byte*)"host_iconvlc",
    (byte*)"host_iconvuc",
    (byte*)"host_stop",
    (byte*)"host_stopx",
    (byte*)"host_ismain",
    (byte*)"host_waitkey",
    (byte*)"host_testkey",
    (byte*)"host_execwait",
    (byte*)"host_execcmd",
    (byte*)"host_shellexec",
    (byte*)"host_system",
    (byte*)"host_makestr",
    (byte*)"host_makestrslice",
    (byte*)"host_makeref",
    (byte*)"host_new",
    (byte*)"host_newheap",
    (byte*)"host_readlines",
    (byte*)"host_heapvar",
    (byte*)"host_dictitems",
    (byte*)"host_freeheap",
    (byte*)"host_setoverload",
    (byte*)"host_getcmdparam",
    (byte*)"host_gethostname",
    (byte*)"host_setpcerror",
    (byte*)"host_setdebug",
    (byte*)"host_test",
    (byte*)"host_ticks",
    (byte*)"host_sleep",
    (byte*)"host_random",
    (byte*)"host_findmetafunction",
    (byte*)"host_gethash",
    (byte*)"host_getos",
    (byte*)"host_gethostsize",
    (byte*)"host_iswindows",
    (byte*)"host_setmesshandler",
    (byte*)"host_setfprintf",
    (byte*)"host_loadpcl",
    (byte*)"host_runpcl",
    (byte*)"host_runtask",
    (byte*)"host_callext",
    (byte*)"host_pcldata",
    (byte*)"host_getcstring",
    (byte*)"host_getparam",
    (byte*)"host_clearlist",
    (byte*)"host_makelink",
    (byte*)"host_allparams",
    (byte*)"host_stackvars",
    (byte*)"host_makeempty",
    (byte*)"host_errorinfo",
    (byte*)"host_last"
};
int64 pq_common_hostnparams[72] =     {
    (int64)0,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)2,
    (int64)2,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)2,
    (int64)2,
    (int64)3,
    (int64)3,
    (int64)2,
    (int64)2,
    (int64)2,
    (int64)2,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)3,
    (int64)3,
    (int64)2,
    (int64)1,
    (int64)2,
    (int64)2,
    (int64)2,
    (int64)4,
    (int64)4,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)3,
    (int64)1,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)2,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)2,
    (int64)2,
    (int64)2,
    (int64)2,
    (int64)3,
    (int64)2,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)0
};
int64 pq_common_hostisfn[72] =     {
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)1,
    (int64)0
};
byte *  pq_common_namenames[20] =     {
    (byte*)"nullid",
    (byte*)"programid",
    (byte*)"moduleid",
    (byte*)"extmoduleid",
    (byte*)"dllmoduleid",
    (byte*)"typeid",
    (byte*)"procid",
    (byte*)"dllprocid",
    (byte*)"dllvarid",
    (byte*)"constid",
    (byte*)"staticid",
    (byte*)"frameid",
    (byte*)"paramid",
    (byte*)"fieldid",
    (byte*)"genfieldid",
    (byte*)"enumid",
    (byte*)"labelid",
    (byte*)"blockid",
    (byte*)"aliasid",
    (byte*)"linkid"
};
byte *  pq_common_errornames[7] = {(byte*)"pc_error",(byte*)"user_error",(byte*)"type_error",(byte*)"mixedtype_error",(byte*)"divide_error",(byte*)"stopmodule_error",(byte*)"bounds_error"};
byte pc_support_bytemasks[8] = {(uint8)1u,(uint8)2u,(uint8)4u,(uint8)8u,(uint8)16u,(uint8)32u,(uint8)64u,(uint8)128u};
struct pc_decls_objrec *  pc_objects_emptylist = 0;
struct pc_decls_objrec *  pc_objects_emptyset = 0;
static struct pc_decls_objrec pc_objects_zeroobj;
static struct pc_decls_objrec pc_objects_deflistobj;
int64 pc_print_mindev;
int64 pc_print_moutdev;
int64 *  pc_print_minchan;
void *  pc_print_moutchan;
struct pc_decls_varrec pc_print_minvar;
struct pc_decls_varrec pc_print_moutvar;
byte *  pc_print_mfmtstr;
byte *  pc_print_mfmtcurr;
struct pc_decls_fmtrec pc_print_defaultfmt =     {
    (uint8)0u,
    (int8)0,
    (uint8)10u,
    (uint8)0u,
    (uint8)32u,
    (uint8)102u,
    (uint8)0u,
    (uint8)0u,
    (uint8)0u,
    (uint8)82u,
    (uint8)0u,
    (uint8)0u,
    (uint8)0u,
    (uint8)0u,
    {(uint8)0u,(uint8)0u}
};
void *  pc_print_testfilech;
static int32 pc_print_moutdevstack[6];
static void *  pc_print_moutchanstack[6];
static struct pc_decls_varrec pc_print_moutvarstack[6];
static byte pc_print_mgapstack[6];
static byte *  pc_print_mfmtstrstack[6];
static byte *  pc_print_mfmtcurrstack[6];
static int64 pc_print_noclevels;
static byte pc_print_mgapneeded;
static int64 pc_print_listdepth = (int64)0;
static byte pc_print_digits[16] =     {
    (uint8)48u,
    (uint8)49u,
    (uint8)50u,
    (uint8)51u,
    (uint8)52u,
    (uint8)53u,
    (uint8)54u,
    (uint8)55u,
    (uint8)56u,
    (uint8)57u,
    (uint8)65u,
    (uint8)66u,
    (uint8)67u,
    (uint8)68u,
    (uint8)69u,
    (uint8)70u
};
static byte *  pc_print_kb_start;
static byte *  pc_print_kb_pos;
static byte *  pc_print_kb_lastpos;
static int64 pc_print_kb_size;
static int64 pc_print_kb_linelength;
static int64 pc_print_kb_length;
static int64 pc_print_kb_lastlength;
static byte pc_print_termchar;
static int64 pc_print_itemerror;
static int32 pc_jhandlers_typemap[26] =     {
    (int32)30,
    (int32)31,
    (int32)0,
    (int32)10,
    (int32)9,
    (int32)18,
    (int32)19,
    (int32)25,
    (int32)1,
    (int32)7,
    (int32)33,
    (int32)29,
    (int32)32,
    (int32)4,
    (int32)14,
    (int32)23,
    (int32)0,
    (int32)3,
    (int32)5,
    (int32)13,
    (int32)0,
    (int32)22,
    (int32)2,
    (int32)0,
    (int32)0,
    (int32)35
};
static byte *  pc_jhandlers_tabnames[66] =     {
    (byte*)"add",
    (byte*)"sub",
    (byte*)"mul",
    (byte*)"div",
    (byte*)"idiv",
    (byte*)"rem",
    (byte*)"iand",
    (byte*)"ior",
    (byte*)"ixor",
    (byte*)"shl",
    (byte*)"shr",
    (byte*)"min",
    (byte*)"max",
    (byte*)"jumpeq",
    (byte*)"jumpne",
    (byte*)"jumplt",
    (byte*)"jumple",
    (byte*)"jumpge",
    (byte*)"jumpgt",
    (byte*)"jumptesteq",
    (byte*)"jumptestne",
    (byte*)"jumpfalse",
    (byte*)"jumptrue",
    (byte*)"eq",
    (byte*)"lt",
    (byte*)"le",
    (byte*)"concat",
    (byte*)"append",
    (byte*)"addto",
    (byte*)"subto",
    (byte*)"multo",
    (byte*)"divto",
    (byte*)"idivto",
    (byte*)"iandto",
    (byte*)"iorto",
    (byte*)"ixorto",
    (byte*)"shlto",
    (byte*)"shrto",
    (byte*)"minto",
    (byte*)"maxto",
    (byte*)"concatto",
    (byte*)"appendto",
    (byte*)"neg",
    (byte*)"abs",
    (byte*)"inot",
    (byte*)"istrue",
    (byte*)"jumpf",
    (byte*)"jumpt",
    (byte*)"len",
    (byte*)"lwb",
    (byte*)"upb",
    (byte*)"bounds",
    (byte*)"incr",
    (byte*)"decr",
    (byte*)"decr",
    (byte*)"free",
    (byte*)"dupl",
    (byte*)"tostr",
    (byte*)"in",
    (byte*)"inrev",
    (byte*)"pushix",
    (byte*)"pushixref",
    (byte*)"pushdotix",
    (byte*)"pushdotixref",
    (byte*)"convert",
    (byte*)"mixed"
};
static void *  pc_jhandlers_singletable[66] =     {
    (void *)(&pc_decls_add_table),
    (void *)(&pc_decls_sub_table),
    (void *)(&pc_decls_mul_table),
    (void *)(&pc_decls_div_table),
    (void *)(&pc_decls_idiv_table),
    (void *)(&pc_decls_rem_table),
    (void *)(&pc_decls_iand_table),
    (void *)(&pc_decls_ior_table),
    (void *)(&pc_decls_ixor_table),
    (void *)(&pc_decls_shl_table),
    (void *)(&pc_decls_shr_table),
    (void *)(&pc_decls_min_table),
    (void *)(&pc_decls_max_table),
    (void *)(&pc_decls_jumpeq_table),
    (void *)(&pc_decls_jumpne_table),
    (void *)(&pc_decls_jumplt_table),
    (void *)(&pc_decls_jumple_table),
    (void *)(&pc_decls_jumpge_table),
    (void *)(&pc_decls_jumpgt_table),
    (void *)(&pc_decls_jumptesteq_table),
    (void *)(&pc_decls_jumptestne_table),
    (void *)(&pc_decls_jumpfalse_table),
    (void *)(&pc_decls_jumptrue_table),
    (void *)(&pc_decls_eq_table),
    (void *)(&pc_decls_lt_table),
    (void *)(&pc_decls_le_table),
    (void *)(&pc_decls_concat_table),
    (void *)(&pc_decls_append_table),
    (void *)(&pc_decls_addto_table),
    (void *)(&pc_decls_subto_table),
    (void *)(&pc_decls_multo_table),
    (void *)(&pc_decls_divto_table),
    (void *)(&pc_decls_idivto_table),
    (void *)(&pc_decls_iandto_table),
    (void *)(&pc_decls_iorto_table),
    (void *)(&pc_decls_ixorto_table),
    (void *)(&pc_decls_shlto_table),
    (void *)(&pc_decls_shrto_table),
    (void *)(&pc_decls_minto_table),
    (void *)(&pc_decls_maxto_table),
    (void *)(&pc_decls_concatto_table),
    (void *)(&pc_decls_appendto_table),
    (void *)(&pc_decls_neg_table),
    (void *)(&pc_decls_abs_table),
    (void *)(&pc_decls_inot_table),
    (void *)(&pc_decls_istrue_table),
    (void *)(&pc_decls_jumpf_table),
    (void *)(&pc_decls_jumpt_table),
    (void *)(&pc_decls_len_table),
    (void *)(&pc_decls_lwb_table),
    (void *)(&pc_decls_upb_table),
    (void *)(&pc_decls_bounds_table),
    (void *)(&pc_decls_incr_table),
    (void *)(&pc_decls_decr_table),
    (void *)(&pc_decls_decr_table),
    (void *)(&pc_decls_free_table),
    (void *)(&pc_decls_dupl_table),
    (void *)(&pc_decls_tostr_table),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
static void *  pc_jhandlers_doubletable[66] =     {
    (void *)(&pc_decls_add_dtable),
    (void *)(&pc_decls_sub_dtable),
    (void *)(&pc_decls_mul_dtable),
    (void *)(&pc_decls_div_dtable),
    (void *)(&pc_decls_idiv_dtable),
    (void *)(&pc_decls_rem_dtable),
    (void *)(&pc_decls_iand_dtable),
    (void *)(&pc_decls_ior_dtable),
    (void *)(&pc_decls_ixor_dtable),
    (void *)(&pc_decls_shl_dtable),
    (void *)(&pc_decls_shr_dtable),
    (void *)(&pc_decls_min_dtable),
    (void *)(&pc_decls_max_dtable),
    (void *)(&pc_decls_jumpeq_dtable),
    (void *)(&pc_decls_jumpne_dtable),
    (void *)(&pc_decls_jumplt_dtable),
    (void *)(&pc_decls_jumple_dtable),
    (void *)(&pc_decls_jumpge_dtable),
    (void *)(&pc_decls_jumpgt_dtable),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    (void *)(&pc_decls_addto_dtable),
    (void *)(&pc_decls_subto_dtable),
    (void *)(&pc_decls_multo_dtable),
    (void *)(&pc_decls_divto_dtable),
    (void *)(&pc_decls_idivto_dtable),
    (void *)(&pc_decls_iandto_dtable),
    (void *)(&pc_decls_iorto_dtable),
    (void *)(&pc_decls_ixorto_dtable),
    (void *)(&pc_decls_shlto_dtable),
    (void *)(&pc_decls_shrto_dtable),
    (void *)(&pc_decls_minto_dtable),
    (void *)(&pc_decls_maxto_dtable),
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    (void *)(&pc_decls_in_dtable),
    (void *)(&pc_decls_inrev_dtable),
    (void *)(&pc_decls_pushix_dtable),
    (void *)(&pc_decls_pushixref_dtable),
    (void *)(&pc_decls_pushdotix_dtable),
    (void *)(&pc_decls_pushdotixref_dtable),
    (void *)(&pc_decls_convert_dtable),
    (void *)(&pc_decls_mixed_dtable)
};
static byte (*pc_jhandlers_mixedmap)[];
static struct pc_host_overloadrec *  pc_host_tostr_list;
static struct pc_host_overloadrec *  pc_host_convert_list;
static struct pc_decls_procrec *  pc_host_proclistptr;
static void *  pc_host_hosttable[70] =     {
    (void *)(&pc_print_pch_startprint),
    (void *)(&pc_print_pch_startprintcon),
    (void *)(&pc_print_pch_strstartprint),
    (void *)(&pc_print_pch_setformat),
    (void *)(&pc_print_pch_endprint),
    (void *)(&pc_print_pch_strendprint),
    (void *)(&pc_print_pch_print),
    (void *)(&pc_print_pch_dprint),
    (void *)(&pc_print_pch_println),
    (void *)(&pc_print_pch_printnogap),
    (void *)(&pc_print_pch_readln),
    (void *)(&pc_print_pch_sreadln),
    (void *)(&pc_print_pch_sread),
    (void *)(&pc_print_pch_rereadln),
    (void *)(&pc_print_pch_reread),
    (void *)(&pc_print_pch_strtoval),
    (void *)(&pc_print_pch_tostr),
    (void *)(&pc_host_pch_leftstr),
    (void *)(&pc_host_pch_rightstr),
    (void *)(&pc_host_pch_convlc),
    (void *)(&pc_host_pch_convuc),
    (void *)(&pc_host_pch_iconvlc),
    (void *)(&pc_host_pch_iconvuc),
    (void *)(&pc_host_pch_stop),
    (void *)(&pc_host_pch_stopx),
    (void *)(&pc_host_pch_ismain),
    (void *)(&pc_host_pch_waitkey),
    (void *)(&pc_host_pch_testkey),
    (void *)(&pc_host_pch_execwait),
    (void *)(&pc_host_pch_execcmd),
    (void *)(&pc_host_pch_shellexec),
    (void *)(&pc_host_pch_system),
    (void *)(&pc_host_pch_makestr),
    (void *)(&pc_host_pch_makestrslice),
    (void *)(&pc_host_pch_makeref),
    (void *)(&pc_host_pch_new),
    (void *)(&pc_host_pch_newheap),
    (void *)(&pc_host_pch_readlines),
    (void *)(&pc_host_pch_heapvar),
    (void *)(&pc_host_pch_dictitems),
    (void *)(&pc_host_pch_freeheap),
    (void *)(&pc_host_pch_setoverload),
    (void *)(&pc_host_pch_getcmdparam),
    (void *)(&pc_oslayer_pch_gethostname),
    (void *)(&pc_host_pch_setpcerror),
    (void *)(&pc_host_pch_setdebug),
    (void *)(&pc_host_pch_test),
    (void *)(&pc_host_pch_ticks),
    (void *)(&pc_host_pch_sleep),
    (void *)(&pc_host_pch_random),
    (void *)(&pc_host_pch_findmetafunction),
    (void *)(&pc_host_pch_gethash),
    (void *)(&pc_oslayer_pch_getos),
    (void *)(&pc_oslayer_pch_gethostsize),
    (void *)(&pc_oslayer_pch_iswindows),
    (void *)(&pc_oslayer_pch_setmesshandler),
    (void *)(&pc_host_pch_setfprintf),
    (void *)(&pc_host_pch_loadpcl),
    (void *)(&pc_host_pch_runpcl),
    (void *)(&pc_host_pch_runtask),
    (void *)(&pc_host_pch_callext),
    (void *)(&pc_host_pch_pcldata),
    (void *)(&pc_host_pch_getcstring),
    (void *)(&pc_host_pch_getparam),
    (void *)(&pc_host_pch_clearlist),
    (void *)(&pc_host_pch_makelink),
    (void *)(&pc_host_pch_allparams),
    (void *)(&pc_host_pch_stackvars),
    (void *)(&pc_host_pch_makeempty),
    (void *)(&pc_host_pch_errorinfo)
};
struct pc_decls_objrec *  pc_khandlers_zerostringobj;
byte pc_khandlers_stopped;
static int64 qc_passes = (int64)0;
static byte qc_fshowoptions;
static byte qc_fshowmodules;
static byte qc_fshowfiles;
static byte qc_fshowtokens;
static byte qc_fshowast;
static byte qc_fshowst;
static byte qc_fshowstflat;
static byte qc_fshowtypes;
static byte qc_fshowfields;
static byte qc_fshowpcl;
static byte qc_fshowdis;
static byte qc_fshowtiming;
static byte qc_fshowpaths;
static byte qc_fdocs;
static byte qc_fshowlog;
static byte qc_fgenpc;
static byte qc_fgenqa;
static byte *  qc_optionnames[27] =     {
    (byte*)"load",
    (byte*)"lex",
    (byte*)"qa",
    (byte*)"parse",
    (byte*)"gen",
    (byte*)"pc",
    (byte*)"c",
    (byte*)"options",
    (byte*)"modules",
    (byte*)"files",
    (byte*)"ast",
    (byte*)"st",
    (byte*)"stflat",
    (byte*)"dis",
    (byte*)"paths",
    (byte*)"types",
    (byte*)"fields",
    (byte*)"pcl",
    (byte*)"s",
    (byte*)"d",
    (byte*)"time",
    (byte*)"v",
    (byte*)"v2",
    (byte*)"h",
    (byte*)"help",
    (byte*)"docs",
    (byte*)"ext"
};
static byte *  qc_infile;
static int64 qc_logdest = (int64)0;
static int64 qc_dopause = (int64)0;
static int64 qc_totalpclopcodes = (int64)0;
static int64 qc_totallines = (int64)0;
static int64 qc_nstringobjects = (int64)0;
static byte qc_loadstatus;
static byte qc_parsestatus;
static byte qc_namestatus;
static byte qc_genstatus;
static byte qc_compilestatus;
static int64 qc_clockstart;
static int64 qc_modulelevel;
static byte *  qc_outfile;
byte *  var_types_stdtypenames[54] =     {
    (byte*)"tvoid",
    (byte*)"tint",
    (byte*)"tword",
    (byte*)"treal",
    (byte*)"trange",
    (byte*)"tstring",
    (byte*)"twstring",
    (byte*)"tlongint",
    (byte*)"trational",
    (byte*)"tset",
    (byte*)"tdict",
    (byte*)"tword128",
    (byte*)"tenum",
    (byte*)"ttype",
    (byte*)"toperator",
    (byte*)"tsymbol",
    (byte*)"tretaddr",
    (byte*)"texception",
    (byte*)"trefproc",
    (byte*)"trefdllproc",
    (byte*)"treflabel",
    (byte*)"tstringz",
    (byte*)"trefvar",
    (byte*)"trefpacked",
    (byte*)"trefbit",
    (byte*)"trecordlink",
    (byte*)"treflist",
    (byte*)"trefarray",
    (byte*)"trefbits",
    (byte*)"tlist",
    (byte*)"tarray",
    (byte*)"tbits",
    (byte*)"trecord",
    (byte*)"tstruct",
    (byte*)"tuser",
    (byte*)"tvariant",
    (byte*)"tc8",
    (byte*)"ti8",
    (byte*)"ti16",
    (byte*)"ti32",
    (byte*)"ti64",
    (byte*)"tbit",
    (byte*)"tbit2",
    (byte*)"tbit4",
    (byte*)"tu8",
    (byte*)"tu16",
    (byte*)"tu32",
    (byte*)"tu64",
    (byte*)"tr32",
    (byte*)"tr64",
    (byte*)"tintm",
    (byte*)"twordm",
    (byte*)"trefm",
    (byte*)"tlast"
};
int64 var_types_stdtypewidths[54] =     {
    (int64)128,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)0,
    (int64)0,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)64,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)128,
    (int64)8,
    (int64)8,
    (int64)16,
    (int64)32,
    (int64)64,
    (int64)1,
    (int64)2,
    (int64)4,
    (int64)8,
    (int64)16,
    (int64)32,
    (int64)64,
    (int64)32,
    (int64)64,
    (int64)32,
    (int64)32,
    (int64)64,
    (int64)0
};
byte *  var_decls_usercatnames[3] = {(byte*)"std_cat",(byte*)"anon_cat",(byte*)"user_cat"};
int64 var_decls_ntypes;
int32 var_decls_ttmodule[300];
struct var_decls_strec *  var_decls_ttnamedef[300];
int32 var_decls_ttbasetype[300];
byte *  var_decls_ttname[300];
int32 var_decls_ttbitwidth[300];
int32 var_decls_ttsize[300];
int32 var_decls_ttlower[300];
int32 var_decls_ttlength[300];
int32 var_decls_ttstartfield[300];
int32 var_decls_ttstructfields[300];
int32 var_decls_tttarget[300];
byte var_decls_ttusercat[300];
byte var_decls_typestarterset[300];
byte *  var_decls_objtypenames[3] = {(byte*)"normal_obj",(byte*)"slice_obj",(byte*)"extslice_obj"};
byte var_decls_exprstarterset[132];
struct var_decls_modulerec var_decls_moduletable[51];
int64 var_decls_nmodules;
byte *  var_decls_pendingmodules[50];
int64 var_decls_npendingmodules;
int64 var_decls_currmoduleno;
struct var_decls_modulerec *  var_decls_currmodule;
byte *  var_decls_inputfiles[51];
int64 var_decls_ninputfiles;
byte *  var_decls_searchdirs[6];
int64 var_decls_nsearchdirs = (int64)0;
struct var_decls_strec *  var_decls_stprogram;
struct var_decls_strec *  var_decls_stmodule;
struct var_decls_strec *  var_decls_stsysmodule;
struct var_decls_strec *  var_decls_alldeflist;
void *  var_decls_logdev;
int64 var_decls_optflag = (int64)0;
struct var_decls_genfieldnamerec var_decls_genfieldnames[1000];
struct var_decls_genfielddatarec var_decls_genfielddata[1000];
int64 var_decls_ngenfieldnames;
int64 var_decls_ngenfielddata;
struct var_decls_unitrec *  var_decls_nullunit;
byte *  var_decls_libpaths[10];
int64 var_decls_nlibpaths;
int64 var_decls_fverbose = (int64)0;
int64 var_decls_ftrace = (int64)0;
int64 var_decls_fdtrace = (int64)0;
int64 var_decls_foptimise = (int64)0;
int64 var_decls_mlineno = (int64)0;
int64 var_decls_tlex = (int64)0;
int64 var_decls_exportsprepass = (int64)0;
int64 var_decls_debug = (int64)0;
int64 var_decls_nnames;
int64 var_decls_nchecks;
int64 var_decls_forcheck;
int64 var_decls_nclashes;
int64 var_decls_nlookups;
int64 var_decls_allnames;
int64 var_decls_allfoundnames;
int64 var_decls_allnotfoundnames;
int64 var_decls_nfors;
int64 var_decls_nforalls;
int64 var_decls_nwhiles;
int64 var_decls_nrepeats;
int64 var_decls_ndos;
int64 var_decls_ntos;
int64 var_decls_totalstrings = (int64)0;
byte *  var_decls_dispatchnames[4] = {(byte*)"-LAB",(byte*)"-FN",(byte*)"-DEB",(byte*)"-ASM"};
int64 var_decls_ndlltable;
int64 var_decls_ndllproctable;
byte *  var_decls_dlltable[50];
uint64 var_decls_dllinsttable[50];
struct var_decls_dllprocrec var_decls_dllproctable[500];
void (*var_decls_fprintf_ptr)(void);
void (*var_decls_fgets_ptr)(void);
void (*var_decls_pcl_callbackfn)(void) = 0;
byte *  var_decls_pcerror_mess = 0;
int64 var_decls_ncmdparams;
byte *  var_decls_cmdparamtable[33];
struct var_decls_procrec *  var_decls_proclist;
int64 var_decls_nproclist;
int64 var_decls_nstrings = (int64)0;
int64 var_decls_nsymbols = (int64)0;
int64 var_decls_nstructfields = (int64)0;
byte * (*var_decls_stringtable)[];
int64 (*var_decls_stringlentable)[];
struct var_decls_fieldrec (*var_decls_pcfieldtable)[];
int64 var_decls_runfrompc = (int64)0;
byte *  var_decls_extrafiles[10];
byte *  var_decls_extratext[10];
int64 var_decls_extrasizes[10];
int64 var_decls_nextra;
byte *  var_decls_err_message;
int64 *  var_decls_stopseq;
int64 *  var_decls_raiseseq;
int64 var_decls_nstringeq = (int64)0;
int64 var_decls_nstringcmp = (int64)0;
byte *  var_decls_ppp;
int64 var_decls_progstart;
int64 var_decls_progend;
int64 var_decls_loadstart;
int64 var_decls_loadend;
int64 var_decls_parsestart;
int64 var_decls_parseend;
int64 var_decls_namesstart;
int64 var_decls_namesend;
int64 var_decls_genstart;
int64 var_decls_genend;
static struct mlib_strbuffer var_decls_docstrx;
struct mlib_strbuffer *  var_decls_docstring = &var_decls_docstrx;
byte *  qc_tables_jtagnames[248] =     {
    (byte*)"j_none",
    (byte*)"j_const",
    (byte*)"j_null",
    (byte*)"j_name",
    (byte*)"j_block",
    (byte*)"j_codeblock",
    (byte*)"j_blockdef",
    (byte*)"j_doblock",
    (byte*)"j_typeval",
    (byte*)"j_longint",
    (byte*)"j_whenthen",
    (byte*)"j_elsif",
    (byte*)"j_fmtitem",
    (byte*)"j_nogap",
    (byte*)"j_callproc",
    (byte*)"j_callmproc",
    (byte*)"j_return",
    (byte*)"j_assign",
    (byte*)"j_shallowcopy",
    (byte*)"j_deepcopy",
    (byte*)"j_to",
    (byte*)"j_if",
    (byte*)"j_longif",
    (byte*)"j_forup",
    (byte*)"j_fordown",
    (byte*)"j_forstep",
    (byte*)"j_forall",
    (byte*)"j_forallrev",
    (byte*)"j_foreach",
    (byte*)"j_foreachrev",
    (byte*)"j_cfor",
    (byte*)"j_while",
    (byte*)"j_repeat",
    (byte*)"j_goto",
    (byte*)"j_gotoblock",
    (byte*)"j_labeldef",
    (byte*)"j_restart",
    (byte*)"j_redo",
    (byte*)"j_next",
    (byte*)"j_exit",
    (byte*)"j_break",
    (byte*)"j_do",
    (byte*)"j_case",
    (byte*)"j_docase",
    (byte*)"j_switch",
    (byte*)"j_doswitch",
    (byte*)"j_swap",
    (byte*)"j_select",
    (byte*)"j_print",
    (byte*)"j_println",
    (byte*)"j_fprint",
    (byte*)"j_fprintln",
    (byte*)"j_cprint",
    (byte*)"j_cprintln",
    (byte*)"j_sprint",
    (byte*)"j_sfprint",
    (byte*)"j_scprint",
    (byte*)"j_read",
    (byte*)"j_readln",
    (byte*)"j_sread",
    (byte*)"j_sreadln",
    (byte*)"j_stop",
    (byte*)"j_try",
    (byte*)"j_except",
    (byte*)"j_yield",
    (byte*)"j_raise",
    (byte*)"j_callhostproc",
    (byte*)"j_eval",
    (byte*)"j_listcomp",
    (byte*)"j_appendlc",
    (byte*)"j_startiter",
    (byte*)"j_nextiter",
    (byte*)"j_andl",
    (byte*)"j_orl",
    (byte*)"j_xorl",
    (byte*)"j_notl",
    (byte*)"j_istruel",
    (byte*)"j_makelist",
    (byte*)"j_makeconstr",
    (byte*)"j_makesetlist",
    (byte*)"j_makerange",
    (byte*)"j_makedict",
    (byte*)"j_exprlist",
    (byte*)"j_multexpr",
    (byte*)"j_keyword",
    (byte*)"j_keyvalue",
    (byte*)"j_assignx",
    (byte*)"j_deepcopyx",
    (byte*)"j_callfn",
    (byte*)"j_callmfn",
    (byte*)"j_ifx",
    (byte*)"j_selectx",
    (byte*)"j_callhostfn",
    (byte*)"j_applyop",
    (byte*)"j_applyopx",
    (byte*)"j_andand",
    (byte*)"j_eq",
    (byte*)"j_ne",
    (byte*)"j_lt",
    (byte*)"j_le",
    (byte*)"j_gt",
    (byte*)"j_ge",
    (byte*)"j_isequal",
    (byte*)"j_add",
    (byte*)"j_sub",
    (byte*)"j_mul",
    (byte*)"j_div",
    (byte*)"j_idiv",
    (byte*)"j_fdiv",
    (byte*)"j_ddiv",
    (byte*)"j_rem",
    (byte*)"j_divrem",
    (byte*)"j_iand",
    (byte*)"j_ior",
    (byte*)"j_ixor",
    (byte*)"j_shl",
    (byte*)"j_shr",
    (byte*)"j_in",
    (byte*)"j_notin",
    (byte*)"j_inrev",
    (byte*)"j_min",
    (byte*)"j_max",
    (byte*)"j_addptr",
    (byte*)"j_subptr",
    (byte*)"j_concat",
    (byte*)"j_append",
    (byte*)"j_clamp",
    (byte*)"j_index",
    (byte*)"j_indexref",
    (byte*)"j_slice",
    (byte*)"j_keyindex",
    (byte*)"j_dotindex",
    (byte*)"j_dotleft",
    (byte*)"j_dotright",
    (byte*)"j_dotslice",
    (byte*)"j_dotkeyindex",
    (byte*)"j_anddotindex",
    (byte*)"j_anddotslice",
    (byte*)"j_byteindex",
    (byte*)"j_dot",
    (byte*)"j_dotref",
    (byte*)"j_dotattr",
    (byte*)"j_atan2",
    (byte*)"j_power",
    (byte*)"j_ptr",
    (byte*)"j_ptrto",
    (byte*)"j_addrof",
    (byte*)"j_convert",
    (byte*)"j_typepun",
    (byte*)"j_typeconst",
    (byte*)"j_operator",
    (byte*)"j_packtypeconst",
    (byte*)"j_classconst",
    (byte*)"j_upper",
    (byte*)"j_neg",
    (byte*)"j_abs",
    (byte*)"j_inot",
    (byte*)"j_chr",
    (byte*)"j_asc",
    (byte*)"j_sqrt",
    (byte*)"j_sqr",
    (byte*)"j_cube",
    (byte*)"j_sign",
    (byte*)"j_sin",
    (byte*)"j_cos",
    (byte*)"j_tan",
    (byte*)"j_asin",
    (byte*)"j_acos",
    (byte*)"j_atan",
    (byte*)"j_ln",
    (byte*)"j_lg",
    (byte*)"j_log",
    (byte*)"j_exp",
    (byte*)"j_round",
    (byte*)"j_floor",
    (byte*)"j_ceil",
    (byte*)"j_fract",
    (byte*)"j_fmod",
    (byte*)"j_lwb",
    (byte*)"j_upb",
    (byte*)"j_len",
    (byte*)"j_bounds",
    (byte*)"j_bitwidth",
    (byte*)"j_bytesize",
    (byte*)"j_dictitems",
    (byte*)"j_gettype",
    (byte*)"j_getbasetype",
    (byte*)"j_getelemtype",
    (byte*)"j_isvoid",
    (byte*)"j_isnone",
    (byte*)"j_isdef",
    (byte*)"j_isint",
    (byte*)"j_isreal",
    (byte*)"j_isstring",
    (byte*)"j_isrange",
    (byte*)"j_islist",
    (byte*)"j_isrecord",
    (byte*)"j_isclass",
    (byte*)"j_isarray",
    (byte*)"j_isset",
    (byte*)"j_istype",
    (byte*)"j_ispointer",
    (byte*)"j_ismutable",
    (byte*)"j_minvalue",
    (byte*)"j_maxvalue",
    (byte*)"j_min1",
    (byte*)"j_max1",
    (byte*)"j_preincrx",
    (byte*)"j_predecrx",
    (byte*)"j_postincrx",
    (byte*)"j_postdecrx",
    (byte*)"j_addto",
    (byte*)"j_subto",
    (byte*)"j_multo",
    (byte*)"j_divto",
    (byte*)"j_idivto",
    (byte*)"j_fdivto",
    (byte*)"j_iandto",
    (byte*)"j_iorto",
    (byte*)"j_ixorto",
    (byte*)"j_shlto",
    (byte*)"j_shrto",
    (byte*)"j_minto",
    (byte*)"j_maxto",
    (byte*)"j_concatto",
    (byte*)"j_appendto",
    (byte*)"j_negto",
    (byte*)"j_absto",
    (byte*)"j_inotto",
    (byte*)"j_preincr",
    (byte*)"j_predecr",
    (byte*)"j_postincr",
    (byte*)"j_postdecr",
    (byte*)"j_cvlineno",
    (byte*)"j_cvstrlineno",
    (byte*)"j_cvmodulename",
    (byte*)"j_cvfilename",
    (byte*)"j_cvfunction",
    (byte*)"j_cvdate",
    (byte*)"j_cvtime",
    (byte*)"j_cvversion",
    (byte*)"j_cvpclversion",
    (byte*)"j_new",
    (byte*)"j_mixed",
    (byte*)"j_tostr",
    (byte*)"j_free",
    (byte*)"j_dupl",
    (byte*)"j_dummy"
};
byte *  qc_tables_scopenames[4] = {(byte*)"noscope",(byte*)"localscope",(byte*)"importscope",(byte*)"exportscope"};
byte *  qc_tables_fflangnames[5] = {(byte*)"windowsff",(byte*)"clangff",(byte*)"qlangff",(byte*)"mlangff",(byte*)"dummyff"};
byte *  qc_tables_symbolnames[132] =     {
    (byte*)"errorsym",
    (byte*)"dotsym",
    (byte*)"lexdotsym",
    (byte*)"anddotsym",
    (byte*)"commasym",
    (byte*)"semisym",
    (byte*)"colonsym",
    (byte*)"dcolonsym",
    (byte*)"assignsym",
    (byte*)"deepcopysym",
    (byte*)"sendtosym",
    (byte*)"lbracksym",
    (byte*)"rbracksym",
    (byte*)"lsqsym",
    (byte*)"rsqsym",
    (byte*)"lcurlysym",
    (byte*)"rcurlysym",
    (byte*)"ptrsym",
    (byte*)"barsym",
    (byte*)"dbarsym",
    (byte*)"atsym",
    (byte*)"datsym",
    (byte*)"questionsym",
    (byte*)"addrsym",
    (byte*)"daddrsym",
    (byte*)"poundsym",
    (byte*)"curlsym",
    (byte*)"gatesym",
    (byte*)"rangesym",
    (byte*)"ellipsissym",
    (byte*)"opsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"rawnamesym",
    (byte*)"docstringsym",
    (byte*)"incrsym",
    (byte*)"intconstsym",
    (byte*)"longintconstsym",
    (byte*)"realconstsym",
    (byte*)"charconstsym",
    (byte*)"wcharconstsym",
    (byte*)"stringconstsym",
    (byte*)"wstringconstsym",
    (byte*)"unitnamesym",
    (byte*)"namesym",
    (byte*)"ksourcedirsym",
    (byte*)"lexmacronamesym",
    (byte*)"stdtypesym",
    (byte*)"packtypesym",
    (byte*)"kifsym",
    (byte*)"kthensym",
    (byte*)"kelsifsym",
    (byte*)"kelsesym",
    (byte*)"kelsecasesym",
    (byte*)"kelseswitchsym",
    (byte*)"kelseselectsym",
    (byte*)"kendsym",
    (byte*)"kunlesssym",
    (byte*)"kcasesym",
    (byte*)"kdocasesym",
    (byte*)"kwhensym",
    (byte*)"kforsym",
    (byte*)"kforallsym",
    (byte*)"ktosym",
    (byte*)"kbysym",
    (byte*)"kdosym",
    (byte*)"kwhilesym",
    (byte*)"krepeatsym",
    (byte*)"kuntilsym",
    (byte*)"kreturnsym",
    (byte*)"kstopsym",
    (byte*)"kloopsym",
    (byte*)"kbreaksym",
    (byte*)"kgotosym",
    (byte*)"kswitchsym",
    (byte*)"kdoswitchsym",
    (byte*)"kprintsym",
    (byte*)"ksprintsym",
    (byte*)"kreadsym",
    (byte*)"ksreadsym",
    (byte*)"ksreadlnsym",
    (byte*)"khostfnsym",
    (byte*)"kprocsym",
    (byte*)"kfunctionsym",
    (byte*)"kmethodsym",
    (byte*)"krecordsym",
    (byte*)"kstructsym",
    (byte*)"kunionsym",
    (byte*)"kimportsym",
    (byte*)"kimportmodulesym",
    (byte*)"kmodulesym",
    (byte*)"ktypesym",
    (byte*)"ktypeattrsym",
    (byte*)"krefsym",
    (byte*)"kmacrosym",
    (byte*)"kconstsym",
    (byte*)"kvarsym",
    (byte*)"klocalssym",
    (byte*)"klabelsym",
    (byte*)"kenumsym",
    (byte*)"knewsym",
    (byte*)"kclasssym",
    (byte*)"kdoblocksym",
    (byte*)"kblockdefsym",
    (byte*)"kdirectivesym",
    (byte*)"kfflangsym",
    (byte*)"kglobalsym",
    (byte*)"kstaticsym",
    (byte*)"kbeginsym",
    (byte*)"ktrysym",
    (byte*)"kexceptsym",
    (byte*)"kfinallysym",
    (byte*)"kraisesym",
    (byte*)"kyieldsym",
    (byte*)"kextendsym",
    (byte*)"kblocksym",
    (byte*)"kcastsym",
    (byte*)"ktypeconstsym",
    (byte*)"compilervarsym",
    (byte*)"dollarsym",
    (byte*)"kevalsym",
    (byte*)"ktabledatasym",
    (byte*)"kmapsym",
    (byte*)"kapplyopsym",
    (byte*)"kstacksym",
    (byte*)"kforwardsym",
    (byte*)"kclampsym",
    (byte*)"kswapsym",
    (byte*)"kcondcompsym",
    (byte*)"kerrorsym",
    (byte*)"sysconstsym",
    (byte*)"kdummysym"
};
byte *  qc_tables_sourcedirnames[19] =     {
    (byte*)"definedir",
    (byte*)"emitdir",
    (byte*)"ifdir",
    (byte*)"elsifdir",
    (byte*)"elsedir",
    (byte*)"endifdir",
    (byte*)"debuglinedir",
    (byte*)"includedir",
    (byte*)"endincludedir",
    (byte*)"exportdir",
    (byte*)"endexportdir",
    (byte*)"commentdir",
    (byte*)"endcommentdir",
    (byte*)"strincludedir",
    (byte*)"modulenamedir",
    (byte*)"targetlangdir",
    (byte*)"cincludedir",
    (byte*)"pyimportdir",
    (byte*)"enddir"
};
byte *  qc_tables_stnames[323] =     {
    (byte*)"if",
    (byte*)"then",
    (byte*)"elsif",
    (byte*)"else",
    (byte*)"elsecase",
    (byte*)"elseswitch",
    (byte*)"case",
    (byte*)"docase",
    (byte*)"when",
    (byte*)"for",
    (byte*)"forall",
    (byte*)"foreach",
    (byte*)"to",
    (byte*)"downto",
    (byte*)"by",
    (byte*)"do",
    (byte*)"end",
    (byte*)"while",
    (byte*)"repeat",
    (byte*)"until",
    (byte*)"always",
    (byte*)"return",
    (byte*)"yield",
    (byte*)"stop",
    (byte*)"restart",
    (byte*)"redo",
    (byte*)"loop",
    (byte*)"next",
    (byte*)"exit",
    (byte*)"break",
    (byte*)"goto",
    (byte*)"go",
    (byte*)"switch",
    (byte*)"doswitch",
    (byte*)"tabledata",
    (byte*)"map",
    (byte*)"mapl",
    (byte*)"mapr",
    (byte*)"maplr",
    (byte*)"applyop",
    (byte*)"clamp",
    (byte*)"eval",
    (byte*)"$windows",
    (byte*)"$linux",
    (byte*)"print",
    (byte*)"println",
    (byte*)"fprint",
    (byte*)"fprintln",
    (byte*)"cprint",
    (byte*)"cprintln",
    (byte*)"sprint",
    (byte*)"sfprint",
    (byte*)"scprint",
    (byte*)"cp",
    (byte*)"cpl",
    (byte*)"read",
    (byte*)"readln",
    (byte*)"cast",
    (byte*)"typeconst",
    (byte*)"proc",
    (byte*)"function",
    (byte*)"method",
    (byte*)"type",
    (byte*)"class",
    (byte*)"doblock",
    (byte*)"blockdef",
    (byte*)"record",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"ref",
    (byte*)"module",
    (byte*)"cinclude",
    (byte*)"pyimport",
    (byte*)"include",
    (byte*)"strinclude",
    (byte*)"define",
    (byte*)"macro",
    (byte*)"export",
    (byte*)"endexport",
    (byte*)"static",
    (byte*)"const",
    (byte*)"var",
    (byte*)"variant",
    (byte*)"enum",
    (byte*)"importdll",
    (byte*)"import",
    (byte*)"begin",
    (byte*)"unless",
    (byte*)"try",
    (byte*)"except",
    (byte*)"finally",
    (byte*)"raise",
    (byte*)"global",
    (byte*)"qlang",
    (byte*)"clang",
    (byte*)"mlang",
    (byte*)"windows",
    (byte*)"swap",
    (byte*)"void",
    (byte*)"int",
    (byte*)"word",
    (byte*)"real",
    (byte*)"refvar",
    (byte*)"pointer",
    (byte*)"range",
    (byte*)"longint",
    (byte*)"string",
    (byte*)"set",
    (byte*)"list",
    (byte*)"dict",
    (byte*)"array",
    (byte*)"bits",
    (byte*)"recordtype",
    (byte*)"structtype",
    (byte*)"int8",
    (byte*)"int16",
    (byte*)"int32",
    (byte*)"int64",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"i64",
    (byte*)"real32",
    (byte*)"real64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"sreal",
    (byte*)"bit",
    (byte*)"bit2",
    (byte*)"bit4",
    (byte*)"byte",
    (byte*)"u8",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"u64",
    (byte*)"word8",
    (byte*)"word16",
    (byte*)"word32",
    (byte*)"word64",
    (byte*)"stringz",
    (byte*)"intm",
    (byte*)"wordm",
    (byte*)"refm",
    (byte*)"million",
    (byte*)"billion",
    (byte*)"thousand",
    (byte*)"$lineno",
    (byte*)"$strlineno",
    (byte*)"$filename",
    (byte*)"$modulename",
    (byte*)"$function",
    (byte*)"$date",
    (byte*)"$time",
    (byte*)"$version",
    (byte*)"$pclversion",
    (byte*)"$",
    (byte*)"and",
    (byte*)"or",
    (byte*)"xor",
    (byte*)"iand",
    (byte*)"ior",
    (byte*)"ixor",
    (byte*)"in",
    (byte*)"notin",
    (byte*)"inrev",
    (byte*)"rem",
    (byte*)"divrem",
    (byte*)"min",
    (byte*)"max",
    (byte*)"not",
    (byte*)"inot",
    (byte*)"istrue",
    (byte*)"abs",
    (byte*)"$neg",
    (byte*)"asc",
    (byte*)"chr",
    (byte*)"sqrt",
    (byte*)"sqr",
    (byte*)"cube",
    (byte*)"cos",
    (byte*)"sin",
    (byte*)"tan",
    (byte*)"asin",
    (byte*)"acos",
    (byte*)"atan",
    (byte*)"atan2",
    (byte*)"sign",
    (byte*)"ln",
    (byte*)"log",
    (byte*)"lg",
    (byte*)"exp",
    (byte*)"round",
    (byte*)"floor",
    (byte*)"ceil",
    (byte*)"fract",
    (byte*)"fmod",
    (byte*)"len",
    (byte*)"lwb",
    (byte*)"upb",
    (byte*)"bounds",
    (byte*)"bitwidth",
    (byte*)"bytes",
    (byte*)"basetype",
    (byte*)"dictitems",
    (byte*)"elemtype",
    (byte*)"defined",
    (byte*)"isdef",
    (byte*)"isvoid",
    (byte*)"isnone",
    (byte*)"isint",
    (byte*)"isreal",
    (byte*)"isarray",
    (byte*)"isset",
    (byte*)"islist",
    (byte*)"isrecord",
    (byte*)"isrange",
    (byte*)"isstring",
    (byte*)"ispointer",
    (byte*)"ismutable",
    (byte*)"minvalue",
    (byte*)"maxvalue",
    (byte*)"concat",
    (byte*)"append",
    (byte*)"$free",
    (byte*)"$dupl",
    (byte*)"$mixed",
    (byte*)"$index",
    (byte*)"$dotindex",
    (byte*)"$convert",
    (byte*)"$new",
    (byte*)"$tostr",
    (byte*)"$dot",
    (byte*)"$dotref",
    (byte*)"endif",
    (byte*)"fi",
    (byte*)"endcase",
    (byte*)"esac",
    (byte*)"enddocase",
    (byte*)"endswitch",
    (byte*)"enddoswitch",
    (byte*)"endfor",
    (byte*)"endforall",
    (byte*)"od",
    (byte*)"endproc",
    (byte*)"endfunction",
    (byte*)"endmethod",
    (byte*)"endwhile",
    (byte*)"endto",
    (byte*)"enddo",
    (byte*)"endunless",
    (byte*)"endmodule",
    (byte*)"endimportmodule",
    (byte*)"endtry",
    (byte*)"endrecord",
    (byte*)"endclass",
    (byte*)"endblock",
    (byte*)"nil",
    (byte*)"con",
    (byte*)"tab",
    (byte*)"pi",
    (byte*)"sreadln",
    (byte*)"sread",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"strtoval",
    (byte*)"tostr",
    (byte*)"leftstr",
    (byte*)"rightstr",
    (byte*)"convlc",
    (byte*)"convuc",
    (byte*)"iconvlc",
    (byte*)"iconvuc",
    (byte*)"ismain",
    (byte*)"waitkey",
    (byte*)"testkey",
    (byte*)"execwait",
    (byte*)"execcmd",
    (byte*)"shellexec",
    (byte*)"system",
    (byte*)"makestr",
    (byte*)"makestrslice",
    (byte*)"makeref",
    (byte*)"new",
    (byte*)"newheap",
    (byte*)"readlines",
    (byte*)"heapvar",
    (byte*)"freeheap",
    (byte*)"getcmdparam",
    (byte*)"gethostname",
    (byte*)"$setpcerror",
    (byte*)"$setdebug",
    (byte*)"$test",
    (byte*)"ticks",
    (byte*)"sleep",
    (byte*)"random",
    (byte*)"findmetafunction",
    (byte*)"gethash",
    (byte*)"getos",
    (byte*)"gethostsize",
    (byte*)"iswindows",
    (byte*)"setmesshandler",
    (byte*)"$setfprintf",
    (byte*)"clearlist",
    (byte*)"loadpcl",
    (byte*)"runpcl",
    (byte*)"runtask",
    (byte*)"callext",
    (byte*)"$pcldata",
    (byte*)"getcstring",
    (byte*)"$getparam",
    (byte*)"makelink",
    (byte*)"allparams",
    (byte*)"stackvars",
    (byte*)"makeempty",
    (byte*)"$errorinfo",
    (byte*)"$setoverload",
    (byte*)"pc_error",
    (byte*)"user_error",
    (byte*)"type_error",
    (byte*)"mixedtype_error",
    (byte*)"divide_error",
    (byte*)"stopmodule_error",
    (byte*)"bounds_error"
};
int64 qc_tables_stsymbols[323] =     {
    (int64)50,
    (int64)51,
    (int64)52,
    (int64)53,
    (int64)54,
    (int64)55,
    (int64)59,
    (int64)60,
    (int64)61,
    (int64)62,
    (int64)63,
    (int64)63,
    (int64)64,
    (int64)64,
    (int64)65,
    (int64)66,
    (int64)57,
    (int64)67,
    (int64)68,
    (int64)69,
    (int64)69,
    (int64)70,
    (int64)114,
    (int64)71,
    (int64)72,
    (int64)72,
    (int64)72,
    (int64)72,
    (int64)72,
    (int64)73,
    (int64)74,
    (int64)74,
    (int64)75,
    (int64)76,
    (int64)122,
    (int64)123,
    (int64)123,
    (int64)123,
    (int64)123,
    (int64)124,
    (int64)127,
    (int64)121,
    (int64)129,
    (int64)129,
    (int64)77,
    (int64)77,
    (int64)77,
    (int64)77,
    (int64)77,
    (int64)77,
    (int64)78,
    (int64)78,
    (int64)78,
    (int64)77,
    (int64)77,
    (int64)79,
    (int64)79,
    (int64)117,
    (int64)118,
    (int64)83,
    (int64)84,
    (int64)85,
    (int64)92,
    (int64)102,
    (int64)103,
    (int64)104,
    (int64)86,
    (int64)87,
    (int64)88,
    (int64)94,
    (int64)105,
    (int64)105,
    (int64)105,
    (int64)46,
    (int64)46,
    (int64)46,
    (int64)46,
    (int64)46,
    (int64)46,
    (int64)108,
    (int64)96,
    (int64)97,
    (int64)97,
    (int64)100,
    (int64)90,
    (int64)89,
    (int64)109,
    (int64)58,
    (int64)110,
    (int64)111,
    (int64)112,
    (int64)113,
    (int64)107,
    (int64)106,
    (int64)106,
    (int64)106,
    (int64)106,
    (int64)128,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)48,
    (int64)44,
    (int64)44,
    (int64)44,
    (int64)119,
    (int64)119,
    (int64)119,
    (int64)119,
    (int64)119,
    (int64)119,
    (int64)119,
    (int64)119,
    (int64)119,
    (int64)120,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)31,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)57,
    (int64)131,
    (int64)131,
    (int64)131,
    (int64)131,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)82,
    (int64)130,
    (int64)130,
    (int64)130,
    (int64)130,
    (int64)130,
    (int64)130,
    (int64)130
};
int64 qc_tables_stsubcodes[323] =     {
    (int64)21,
    (int64)0,
    (int64)21,
    (int64)0,
    (int64)42,
    (int64)44,
    (int64)42,
    (int64)43,
    (int64)0,
    (int64)0,
    (int64)26,
    (int64)28,
    (int64)0,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)36,
    (int64)37,
    (int64)38,
    (int64)38,
    (int64)39,
    (int64)40,
    (int64)0,
    (int64)1,
    (int64)44,
    (int64)45,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)2,
    (int64)3,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)2,
    (int64)48,
    (int64)49,
    (int64)50,
    (int64)51,
    (int64)52,
    (int64)53,
    (int64)54,
    (int64)55,
    (int64)56,
    (int64)48,
    (int64)49,
    (int64)57,
    (int64)58,
    (int64)147,
    (int64)149,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)32,
    (int64)33,
    (int64)0,
    (int64)0,
    (int64)15,
    (int64)17,
    (int64)18,
    (int64)8,
    (int64)14,
    (int64)1,
    (int64)1,
    (int64)10,
    (int64)11,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)0,
    (int64)3,
    (int64)2,
    (int64)4,
    (int64)1,
    (int64)0,
    (int64)0,
    (int64)1,
    (int64)2,
    (int64)3,
    (int64)22,
    (int64)22,
    (int64)4,
    (int64)7,
    (int64)5,
    (int64)9,
    (int64)29,
    (int64)10,
    (int64)30,
    (int64)31,
    (int64)32,
    (int64)33,
    (int64)37,
    (int64)38,
    (int64)39,
    (int64)40,
    (int64)37,
    (int64)38,
    (int64)39,
    (int64)40,
    (int64)48,
    (int64)49,
    (int64)48,
    (int64)49,
    (int64)48,
    (int64)41,
    (int64)42,
    (int64)43,
    (int64)44,
    (int64)44,
    (int64)45,
    (int64)46,
    (int64)47,
    (int64)44,
    (int64)45,
    (int64)46,
    (int64)47,
    (int64)21,
    (int64)50,
    (int64)51,
    (int64)52,
    (int64)2,
    (int64)3,
    (int64)1,
    (int64)233,
    (int64)234,
    (int64)236,
    (int64)235,
    (int64)237,
    (int64)238,
    (int64)239,
    (int64)240,
    (int64)241,
    (int64)0,
    (int64)72,
    (int64)73,
    (int64)74,
    (int64)112,
    (int64)113,
    (int64)114,
    (int64)117,
    (int64)118,
    (int64)119,
    (int64)110,
    (int64)111,
    (int64)120,
    (int64)121,
    (int64)75,
    (int64)156,
    (int64)76,
    (int64)155,
    (int64)154,
    (int64)158,
    (int64)157,
    (int64)159,
    (int64)160,
    (int64)161,
    (int64)164,
    (int64)163,
    (int64)165,
    (int64)166,
    (int64)167,
    (int64)168,
    (int64)142,
    (int64)162,
    (int64)169,
    (int64)171,
    (int64)170,
    (int64)172,
    (int64)173,
    (int64)174,
    (int64)175,
    (int64)176,
    (int64)177,
    (int64)180,
    (int64)178,
    (int64)179,
    (int64)181,
    (int64)182,
    (int64)183,
    (int64)186,
    (int64)184,
    (int64)187,
    (int64)190,
    (int64)190,
    (int64)188,
    (int64)189,
    (int64)191,
    (int64)192,
    (int64)198,
    (int64)199,
    (int64)198,
    (int64)196,
    (int64)194,
    (int64)193,
    (int64)201,
    (int64)202,
    (int64)203,
    (int64)204,
    (int64)124,
    (int64)125,
    (int64)245,
    (int64)246,
    (int64)243,
    (int64)127,
    (int64)131,
    (int64)147,
    (int64)242,
    (int64)244,
    (int64)139,
    (int64)140,
    (int64)50,
    (int64)50,
    (int64)59,
    (int64)59,
    (int64)60,
    (int64)75,
    (int64)76,
    (int64)62,
    (int64)63,
    (int64)66,
    (int64)83,
    (int64)84,
    (int64)85,
    (int64)67,
    (int64)64,
    (int64)66,
    (int64)58,
    (int64)91,
    (int64)90,
    (int64)110,
    (int64)86,
    (int64)102,
    (int64)116,
    (int64)1,
    (int64)4,
    (int64)3,
    (int64)2,
    (int64)12,
    (int64)13,
    (int64)14,
    (int64)15,
    (int64)16,
    (int64)17,
    (int64)18,
    (int64)19,
    (int64)20,
    (int64)21,
    (int64)22,
    (int64)23,
    (int64)26,
    (int64)27,
    (int64)28,
    (int64)29,
    (int64)30,
    (int64)31,
    (int64)32,
    (int64)33,
    (int64)34,
    (int64)35,
    (int64)36,
    (int64)37,
    (int64)38,
    (int64)39,
    (int64)41,
    (int64)43,
    (int64)44,
    (int64)45,
    (int64)46,
    (int64)47,
    (int64)48,
    (int64)49,
    (int64)50,
    (int64)51,
    (int64)52,
    (int64)53,
    (int64)54,
    (int64)55,
    (int64)56,
    (int64)57,
    (int64)65,
    (int64)58,
    (int64)59,
    (int64)60,
    (int64)61,
    (int64)62,
    (int64)63,
    (int64)64,
    (int64)66,
    (int64)67,
    (int64)68,
    (int64)69,
    (int64)70,
    (int64)42,
    (int64)1,
    (int64)2,
    (int64)3,
    (int64)4,
    (int64)5,
    (int64)6,
    (int64)7
};
int64 qc_tables_oplist[36] =     {
    (int64)103,
    (int64)104,
    (int64)105,
    (int64)106,
    (int64)107,
    (int64)110,
    (int64)111,
    (int64)72,
    (int64)73,
    (int64)74,
    (int64)112,
    (int64)113,
    (int64)114,
    (int64)115,
    (int64)116,
    (int64)117,
    (int64)118,
    (int64)119,
    (int64)96,
    (int64)97,
    (int64)98,
    (int64)101,
    (int64)99,
    (int64)100,
    (int64)102,
    (int64)120,
    (int64)121,
    (int64)143,
    (int64)142,
    (int64)122,
    (int64)123,
    (int64)124,
    (int64)125,
    (int64)86,
    (int64)87,
    (int64)80
};
int64 qc_tables_oppriolist[36] =     {
    (int64)4,
    (int64)4,
    (int64)3,
    (int64)3,
    (int64)3,
    (int64)3,
    (int64)3,
    (int64)7,
    (int64)8,
    (int64)6,
    (int64)4,
    (int64)4,
    (int64)4,
    (int64)3,
    (int64)3,
    (int64)6,
    (int64)6,
    (int64)6,
    (int64)6,
    (int64)6,
    (int64)6,
    (int64)6,
    (int64)6,
    (int64)6,
    (int64)6,
    (int64)4,
    (int64)4,
    (int64)2,
    (int64)3,
    (int64)4,
    (int64)4,
    (int64)4,
    (int64)4,
    (int64)1,
    (int64)1,
    (int64)5
};
byte qc_tables_jtagpriotable[248];
int64 qc_tables_d_exprstarterset[23] =     {
    (int64)12,
    (int64)14,
    (int64)18,
    (int64)24,
    (int64)31,
    (int64)45,
    (int64)36,
    (int64)37,
    (int64)38,
    (int64)39,
    (int64)40,
    (int64)42,
    (int64)48,
    (int64)78,
    (int64)80,
    (int64)81,
    (int64)101,
    (int64)120,
    (int64)119,
    (int64)127,
    (int64)82,
    (int64)124,
    (int64)130
};
int64 qc_tables_d_typestarterset[6] = {(int64)48,(int64)14,(int64)97,(int64)94,(int64)100,(int64)86};
byte qc_tables_hostlvset[72];
byte qc_tables_condopset[248];
byte qc_support_bytemasks[8] = {(uint8)1u,(uint8)2u,(uint8)4u,(uint8)8u,(uint8)16u,(uint8)32u,(uint8)64u,(uint8)128u};
static byte *  qc_support_pcstart;
static byte *  qc_support_pcdest;
static byte *  qc_support_pcend;
static int64 qc_support_pcalloc;
struct qc_lex_lexrec qc_lex_lx;
struct qc_lex_lexrec qc_lex_nextlx;
static byte *  qc_lex_macrostack[10];
static int64 qc_lex_macrolevel = (int64)0;
static byte *  qc_lex_lxstart;
static byte *  qc_lex_lxsptr;
static struct var_decls_strec *  qc_lex_lxsymptr;
struct var_decls_strec qc_lex_hashtable[131072];
static byte *  qc_lex_maxnumlist[16] =     {
    (byte*)"",
    (byte*)"1111111111111111111111111111111111111111111111111111111111111111",
    (byte*)"11112220022122120101211020120210210211220",
    (byte*)"33333333333333333333333333333333",
    (byte*)"2214220303114400424121122430",
    (byte*)"3520522010102100444244423",
    (byte*)"45012021522523134134601",
    (byte*)"1777777777777777777777",
    (byte*)"145808576354216723756",
    (byte*)"18446744073709551615",
    (byte*)"335500516A429071284",
    (byte*)"839365134A2A240713",
    (byte*)"219505A9511A867B72",
    (byte*)"8681049ADB03DB171",
    (byte*)"2C1D56B648C6CD110",
    (byte*)"FFFFFFFFFFFFFFFF"
};
static int64 qc_lex_maxnumlen[16];
static int64 qc_parse_nprocs;
static int64 qc_parse_intabledata = (int64)0;
static int64 qc_parse_inreadprint = (int64)0;
static int64 qc_parse_inparamlist = (int64)0;
static int64 qc_parse_inrecordbody = (int64)0;
static int64 qc_parse_inimportmodule = (int64)0;
static int64 qc_parse_labelseen = (int64)0;
static byte *  qc_parse_tabledataname = 0;
static struct var_decls_uflagsrec qc_parse_unionstring;
static struct var_decls_uflagsrec qc_parse_unionpend;
static struct var_decls_strec *  qc_parse_unionlastvar = 0;
static struct var_decls_strec *  qc_parse_currproc;
static int64 qc_parse_try_level = (int64)0;
static int64 qc_parse_varattribs = (int64)0;
static struct var_decls_unitrec *  qc_parse_dollarstack[10];
static int64 qc_parse_ndollar = (int64)0;
static int64 qc_parse_inmultexpr = (int64)0;
static int64 qc_lib_autotypeno = (int64)0;
static int64 qc_lib_currlineno;
int64 qc_lib_nextavindex = (int64)0;
static int64 qc_lib_nextsvindex = (int64)0;
static struct mlib_strbuffer qc_lib_exprstrvar;
static struct mlib_strbuffer *  qc_lib_exprstr = &qc_lib_exprstrvar;
static int64 qc_lib_opc_codes[35] =     {
    (int64)103,
    (int64)104,
    (int64)105,
    (int64)106,
    (int64)107,
    (int64)154,
    (int64)96,
    (int64)97,
    (int64)98,
    (int64)99,
    (int64)100,
    (int64)101,
    (int64)112,
    (int64)113,
    (int64)114,
    (int64)156,
    (int64)115,
    (int64)116,
    (int64)72,
    (int64)73,
    (int64)75,
    (int64)205,
    (int64)206,
    (int64)211,
    (int64)212,
    (int64)213,
    (int64)214,
    (int64)226,
    (int64)220,
    (int64)221,
    (int64)207,
    (int64)209,
    (int64)208,
    (int64)210,
    (int64)0
};
static byte *  qc_lib_opc_names[35] =     {
    (byte*)"+",
    (byte*)"-",
    (byte*)"*",
    (byte*)"/",
    (byte*)"%",
    (byte*)"-",
    (byte*)"=",
    (byte*)"<>",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">",
    (byte*)">=",
    (byte*)"iand",
    (byte*)"ior",
    (byte*)"ixor",
    (byte*)"inot",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"and",
    (byte*)"or",
    (byte*)"not",
    (byte*)"min",
    (byte*)"max",
    (byte*)"+:=",
    (byte*)"-:=",
    (byte*)"*:=",
    (byte*)"/:=",
    (byte*)"-:=",
    (byte*)"<<:=",
    (byte*)">>:=",
    (byte*)"++",
    (byte*)"++",
    (byte*)"--",
    (byte*)"--",
    (byte*)""
};
static int64 qc_parselib_typeallowed = (int64)0;
static int64 qc_pclgen_nprocframevars;
static struct var_decls_strec *  qc_pclgen_stretval;
static int64 qc_pclgen_retindex;
static int64 qc_pclgen_nprocparamvars;
static int64 *  qc_pclgen_loopstack[20][4];
static int64 qc_pclgen_trylevelstack[20];
static int64 qc_pclgen_loopindex = (int64)0;
static int64 qc_pclgen_looptrylevel;
static int64 qc_pclgen_trylevel = (int64)0;
static struct var_decls_strec *  qc_pclgen_st_startproc;
static int64 qc_pclgen_pcl_jcodes[100] =     {
    (int64)103,
    (int64)104,
    (int64)105,
    (int64)106,
    (int64)107,
    (int64)110,
    (int64)111,
    (int64)96,
    (int64)97,
    (int64)98,
    (int64)99,
    (int64)100,
    (int64)101,
    (int64)102,
    (int64)112,
    (int64)113,
    (int64)114,
    (int64)156,
    (int64)115,
    (int64)116,
    (int64)117,
    (int64)118,
    (int64)119,
    (int64)120,
    (int64)121,
    (int64)143,
    (int64)142,
    (int64)124,
    (int64)125,
    (int64)154,
    (int64)155,
    (int64)75,
    (int64)76,
    (int64)178,
    (int64)179,
    (int64)180,
    (int64)181,
    (int64)188,
    (int64)190,
    (int64)191,
    (int64)192,
    (int64)198,
    (int64)194,
    (int64)193,
    (int64)196,
    (int64)199,
    (int64)201,
    (int64)202,
    (int64)185,
    (int64)186,
    (int64)187,
    (int64)182,
    (int64)183,
    (int64)203,
    (int64)204,
    (int64)157,
    (int64)158,
    (int64)160,
    (int64)161,
    (int64)159,
    (int64)162,
    (int64)163,
    (int64)164,
    (int64)165,
    (int64)166,
    (int64)167,
    (int64)168,
    (int64)169,
    (int64)170,
    (int64)171,
    (int64)172,
    (int64)173,
    (int64)175,
    (int64)176,
    (int64)174,
    (int64)211,
    (int64)212,
    (int64)213,
    (int64)214,
    (int64)226,
    (int64)217,
    (int64)218,
    (int64)219,
    (int64)220,
    (int64)221,
    (int64)222,
    (int64)223,
    (int64)224,
    (int64)225,
    (int64)207,
    (int64)209,
    (int64)208,
    (int64)210,
    (int64)244,
    (int64)243,
    (int64)242,
    (int64)147,
    (int64)127,
    (int64)131,
    (int64)0
};
static byte qc_pclgen_pcl_nopnds[100] =     {
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)2u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)1u,
    (uint8)2u,
    (uint8)2u,
    (uint8)0u
};
static int64 qc_pclgen_pcl_kcodes[100] =     {
    (int64)153,
    (int64)154,
    (int64)155,
    (int64)156,
    (int64)157,
    (int64)158,
    (int64)159,
    (int64)168,
    (int64)169,
    (int64)170,
    (int64)171,
    (int64)173,
    (int64)172,
    (int64)152,
    (int64)160,
    (int64)161,
    (int64)162,
    (int64)102,
    (int64)163,
    (int64)164,
    (int64)165,
    (int64)166,
    (int64)167,
    (int64)174,
    (int64)175,
    (int64)178,
    (int64)179,
    (int64)176,
    (int64)177,
    (int64)99,
    (int64)100,
    (int64)101,
    (int64)103,
    (int64)129,
    (int64)130,
    (int64)128,
    (int64)131,
    (int64)149,
    (int64)150,
    (int64)139,
    (int64)140,
    (int64)144,
    (int64)142,
    (int64)141,
    (int64)145,
    (int64)148,
    (int64)146,
    (int64)147,
    (int64)134,
    (int64)136,
    (int64)135,
    (int64)132,
    (int64)133,
    (int64)137,
    (int64)138,
    (int64)105,
    (int64)104,
    (int64)107,
    (int64)108,
    (int64)106,
    (int64)115,
    (int64)109,
    (int64)110,
    (int64)111,
    (int64)112,
    (int64)113,
    (int64)114,
    (int64)116,
    (int64)118,
    (int64)117,
    (int64)119,
    (int64)120,
    (int64)122,
    (int64)123,
    (int64)121,
    (int64)180,
    (int64)181,
    (int64)182,
    (int64)183,
    (int64)124,
    (int64)185,
    (int64)186,
    (int64)187,
    (int64)188,
    (int64)189,
    (int64)190,
    (int64)191,
    (int64)192,
    (int64)193,
    (int64)91,
    (int64)90,
    (int64)96,
    (int64)95,
    (int64)151,
    (int64)86,
    (int64)57,
    (int64)85,
    (int64)194,
    (int64)195,
    (int64)0
};
static int64 qc_pclgen_noperands;
static int64 qc_pclgen_dummyop = (int64)0;
int64 (*qc_pcllib_pccode)[];
int64 qc_pcllib_npccode = (int64)0;
int64 qc_pcllib_pcindex;
uint16 (*qc_pcllib_linetable)[];
static byte (*qc_pcllib_labelmap)[];
int64 *  qc_pcllib_lastopc;
int32 qc_pcllib_cmdnopnds[217];
int32 qc_pcllib_labeltable[1000];
int64 qc_pcllib_nextfreelabel;
static int64 qc_pcllib_nfields;
static int64 qc_pcllib_nallfields;
int64 qc_pcllib_nconvertedtypes = (int64)52;
struct var_decls_strec *  qc_pcllib_stcurrproc;
static struct mlib_strbuffer qc_pcllib_pclv;
struct mlib_strbuffer *  qc_pcllib_pcl = &qc_pcllib_pclv;

/* PROCDEFS */
void start(void) {
    int64 i;
    int64 status;
    int64 t;
    int64 n;
    int64 tx;
    int64 stopcode;
    byte *  file;
    int64 filetype;
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  ss = &v;
    struct pc_decls_strec s;
    struct pc_decls_modulerec m;
    if ((pc_dispatch_type == (int64)5)) {
        pc_dispatch_type = (int64)2;
    }
    if (((msysc_nsysparams >= (int64)2) && !!(mlib_eqstring(msysc_sysparams[((int64)2)-1],(byte*)"-c")))) {
        qc_qcstart();
        exit(0);
    }
    pc_initdata();
    file = pc_getinputfile(&filetype);
    if (!!(pc_decls_fverbose)) {
        pc_showcaption();
    }
    if ((file == 0)) {
        exit((int64)1);
    }
    if (!!(pc_fshowtimes)) {
        pc_starttiming();
    }
    pc_initlogfile();
    t = (int64)(clock());
    pc_decls_runfrompc = (int64)1;
    status = pc_loadprogram(file,&filetype);
    if (!(!!(status))) {
        pc_support_loaderror((byte*)"Couldn't load:",file);
    }
    if (!!(pc_decls_fverbose)) {
        printf("%s %s\n",(char*)((byte*)"Loaded"),(char*)(file));
    }
    if (!!(pc_floadpc)) {
        pc_showmodules();
        exit((int64)1);
    }
    stopcode = (int64)0;
    stopcode = pc_runcode(pc_floadpc);
    exit(stopcode);
}

int main(int nargs, char** args) {
int i;
	msysc_nsysparams=nargs;
	if (msysc_nsysparams>nargs) {puts("Too many params"); exit(1);}
	for (i=1; i<=nargs; ++i) msysc_sysparams[i-1]=args[i-1];
	start();
	return 0;
}

static void pc_initlogfile(void) {
    if (!(!!(pc_fshowlog))) {
        return;
    }
    if ((pc_logdest==(int64)2)) {
        remove((byte*)"rr.log");
        pc_decls_logdev = fopen((byte*)"rr.log",(byte*)"w");
    } else if ((pc_logdest==(int64)0) || (pc_logdest==(int64)1)) {
        pc_decls_logdev = 0;
    }
    pc_last_tx = (int64)0;
}

static void pc_closelogfile(void) {
    byte str[100];
    int64 pos;
    printf("%s\n",(char*)((byte*)"CLOSELOGFILE"));
    if ((pc_logdest == (int64)2)    ) {
        fclose(pc_decls_logdev);
        pos = pc_last_tx;
        if (!!((*pc_txpos))) {
            pos = (*pc_txpos);
        }
        sprintf(str,(byte*)"\\m\\ed.bat  %s",(byte*)"rr.log");
        osnos_os_execwait(str,(int64)1,(byte *)(0));
    }
    else if ((!!(pc_dopause) && (pc_logdest != (int64)0))) {
        printf("%s",(char*)((byte*)"PrEss key..."));
        osnos_os_getch();
puts("");
    }
}

static void pc_initdata(void) {
    mlib_pcm_init();
    pc_support_inittypetables();
    pc_objects_makezobjects();
    pc_initpcldata();
    pc_jhandlers_initcalltables();
}

static byte * pc_getinputfile(int64 * filetype) {
    int64 i;
    int64 j;
    int64 k;
    int64 status;
    byte swstr[50];
    byte filename[300];
    int64 filetime;
    byte *  sw;
    byte *  file;
    byte *  fileext;
    byte *  file2;
    static int64 loadsw = (int64)0;
    static int64 fnsw = (int64)0;
    static int64 labsw = (int64)0;
    static int64 asmsw = (int64)0;
    static int64 debsw = (int64)0;
    static int64 tracesw = (int64)0;
    static int64 dtracesw = (int64)0;
    static int64 dsw = (int64)0;
    static int64 ssw = (int64)0;
    static int64 pcl2sw = (int64)0;
    static int64 vsw = (int64)0;
    static int64 v2sw = (int64)0;
    static int64 timesw = (int64)0;
    static int64 swsw = (int64)0;
    static int64 showhelp = (int64)0;
    int64 fileseen;
    static struct pc_getinputfile_switchrec switchtable[15] =     {
    {(byte*)"load",&loadsw},
    {(byte*)"fn",&fnsw},
    {(byte*)"sw",&swsw},
    {(byte*)"lab",&labsw},
    {(byte*)"asm",&asmsw},
    {(byte*)"deb",&debsw},
    {(byte*)"trace",&tracesw},
    {(byte*)"dtrace",&dtracesw},
    {(byte*)"d",&dsw},
    {(byte*)"s",&ssw},
    {(byte*)"pcl2",&pcl2sw},
    {(byte*)"v",&vsw},
    {(byte*)"v2",&v2sw},
    {(byte*)"time",&timesw},
    {(byte*)"help",&showhelp}
};
    int64 av_1;
    j = (int64)0;
    file = (byte *)(0);
    fileseen = (int64)0;
L1:;
    for (i=(int64)1;i<=msysc_nsysparams;++i) {
L2:;
        sw = msysc_sysparams[(i)-1];
        if ((!(!!(fileseen)) && ((int64)((*sw)) == (int64)45))) {
            strcpy(&swstr[((int64)1)-1],(sw + (int64)1));
            mlib_convlcstring(&swstr[((int64)1)-1]);
L5:;
            for (k=(int64)1;k<=(int64)15;++k) {
L6:;
                if (!!(mlib_eqstring(switchtable[(k)-1].switchname,&swstr[((int64)1)-1]))) {
                    (*switchtable[(k)-1].switchaddr) = (int64)1;
                    goto L8;
                }
L7:;
            }
            pc_support_loaderror((byte*)"Unknownswitch:",&swstr[((int64)1)-1]);
L8:;
        }
        else {
//storesw:
L9:;
            ++j;
            if ((i != j)) {
                msysc_sysparams[(j)-1] = msysc_sysparams[(i)-1];
            }
            if ((i > (int64)1)) {
                fileseen = (int64)1;
            }
        }
L3:;
    }
L4:;
    msysc_nsysparams = j;
    if (!!(showhelp)) {
        printf("%s\n",(char*)((byte*)"General usage:"));
        printf("%s%s %s\n",(char*)((byte*)"\t"),(char*)(msysc_sysparams[((int64)1)-1]),(char*)((byte*)" [options] filename[.pc/.q]\n"));
        printf("%s\n",(char*)((byte*)"Selected Options:"));
        printf("%s\n",(char*)((byte*)"\t-load         Load only, show module list"));
        printf("%s\n",(char*)((byte*)"\t-s            Show tables, don't run"));
        printf("%s\n",(char*)((byte*)"\t-d            Show tables to log file, don't run"));
        printf("%s\n",(char*)((byte*)"\t-v            Verbose"));
        printf("%s\n",(char*)((byte*)"\t-v2           More verbose"));
        printf("%s\n",(char*)((byte*)"\t-time         Execution time"));
        printf("%s\n",(char*)((byte*)"\t-fn           Function table dispatcher (default)"));
        printf("%s\n",(char*)((byte*)"\t-lab          (Label table dispatcher; not available this version)"));
        printf("%s\n",(char*)((byte*)"\t-asm          Fast ASM dispatcher; non-C version only"));
        printf("%s\n",(char*)((byte*)"\t-deb [-trace] Debugging dispatcher [with trace on every byte-code]"));
        return (byte *)(0);
    }
    if ((msysc_nsysparams >= (int64)2)) {
        file = &filename[((int64)1)-1];
        strcpy(file,msysc_sysparams[((int64)2)-1]);
    }
    else {
        pc_checkpackfile();
        if (!!(pc_packfileptr)) {
            file = pc_packfilename;
        }
        else {
            pc_showcaption();
            printf("%s\n",(char*)((byte*)"Usage:"));
            printf("%s%s %s\n",(char*)((byte*)"\t"),(char*)(msysc_sysparams[((int64)1)-1]),(char*)((byte*)" [options] filename[.pc/.q]"));
            printf("%s%s %s\n",(char*)((byte*)"\t"),(char*)(msysc_sysparams[((int64)1)-1]),(char*)((byte*)" -help"));
            return (byte *)(0);
        }
    }
    pc_getsyscmdline();
    mlib_convlcstring(file);
    fileext = mlib_extractext(file,(int64)0);
    file2 = (byte *)(0);
    if (((int64)((*fileext)) == (int64)0)    ) {
        if ((osnos_os_filelastwritetime((byte *)(0)) == (int64)0)) {
            (*filetype) = (int64)17232;
            file2 = mlib_pcm_copyheapstring(mlib_addext(file,(byte*)".pc"));
            goto L10;
        }
        pc_findnewestfile(&file2,&filetime,filetype,file,(byte*)".pc",(int64)17232);
        filetime = (int64)0;
        (*filetype) = (int64)0;
        pc_findnewestfile(&file2,&filetime,filetype,file,(byte*)".pc",(int64)17232);
        pc_findnewestfile(&file2,&filetime,filetype,file,(byte*)".q",(int64)81);
        pc_findnewestfile(&file2,&filetime,filetype,file,(byte*)".qa",(int64)16721);
        if ((file2 == 0)) {
            pc_support_loaderror((byte*)"Can't load",file);
        }
        file = file2;
    }
    else if (!!(mlib_eqstring(fileext,(byte*)"pc"))) {
        (*filetype) = (int64)17232;
        if (!!(pc_packfileptr)) {
            file2 = file;
        }
    }
    else if (!!(mlib_eqstring(fileext,(byte*)"q"))) {
        (*filetype) = (int64)81;
    }
    else if (!!(mlib_eqstring(fileext,(byte*)"qa"))) {
        (*filetype) = (int64)16721;
    }
    else {
        pc_support_loaderror((byte*)"Can't find .pc, .q or .qa file",file);
    }
//gotfile:
L10:;
    if ((file2 == 0)) {
        if (!(!!(mlib_checkfile(file)))) {
            pc_support_loaderror((byte*)"Can't load",file);
        }
        file2 = mlib_pcm_copyheapstring(file);
    }
    if ((!!(dsw) || !!(ssw))) {
        pc_fruncode = (int64)0;
        pc_fshowlog = (int64)1;
        pc_logdest = (!!(dsw)?(int64)2:(int64)1);
        pc_dopause = (int64)1;
    }
    if (!!(loadsw)) {
        pc_floadpc = (int64)1;
    }
    if (!!(fnsw)) {
        pc_dispatch_type = (int64)2;
    }
    if (!!(swsw)) {
        pc_dispatch_type = (int64)3;
    }
    if (!!(labsw)) {
        pc_dispatch_type = (int64)1;
    }
    if (!!(asmsw)) {
        pc_dispatch_type = (int64)5;
    }
    if (!!(debsw)) {
        pc_dispatch_type = (int64)4;
    }
    if (!!(tracesw)) {
        pc_decls_ftrace = (int64)1;
    }
    if (!!(dtracesw)) {
        pc_decls_fdtrace = (int64)1;
    }
    if (!!(vsw)) {
        pc_decls_fverbose = (int64)1;
    }
    if (!!(v2sw)) {
        pc_decls_fverbose = (int64)2;
    }
    if (!!(timesw)) {
        pc_fshowtimes = (int64)1;
    }
    if (!!(pcl2sw)) {
        pc_fshowfixedup = (int64)1;
        if ((pc_dispatch_type == (int64)5)) {
            pc_dispatch_type = (int64)4;
        }
    }
    if (((pc_dispatch_type == (int64)5) && !(!!(pc_assem_c_asmavailable())))) {
        pc_support_loaderror((byte*)"-asm not available",(byte*)"");
    }
    return mlib_pcm_copyheapstring(file2);
}

static void pc_showpcl(byte * caption,int64 n,int64 phase) {
    struct pc_decls_varrec *  pclstr;
    if (!!(pc_logdest)) {
        if ((pc_logdest == (int64)2)) {
            pc_pclcode_tx = (pc_last_tx = (int64)(ftell(pc_decls_logdev)));
        }
        pc_support_loaderror((byte*)"WRITEPCCODE",(byte*)"");
    }
}

static void pc_showgenfields(void) {
    if (!!(pc_logdest)) {
        if ((pc_logdest == (int64)2)) {
            pc_genfields_tx = (pc_last_tx = (int64)(ftell(pc_decls_logdev)));
        }
        pc_support_loaderror((byte*)"PRINT GENFIELDS",(byte*)"");
        fprintf(pc_decls_logdev,"\n");
    }
}

static void pc_do_showprogdiags_pc(byte * caption) {
    int64 i;
    struct pc_decls_strec *  d;
    struct pc_decls_procrec *  pp;
    if (!!(pc_logdest)) {
        pc_initbytecode((int64)1);
        printf("%s\n",(char*)((byte*)"DONE INITPC"));
        fprintf(pc_decls_logdev,"%s\n",(char*)((byte*)"SHOW ALL PC PCL2"));
        fprintf(pc_decls_logdev,"%s\n",(char*)(caption));
        pc_showpcl((byte*)"STARTUP CODE",(int64)0,(int64)2);
        pc_showpcl((byte*)"MAIN MODULE",pc_decls_nmodules,(int64)2);
    }
}

int64 pc_runcode(int64 frompc) {
    int64 i;
    int64 j;
    int64 cmd;
    int64 fmt;
    int64 *  lab;
    int64 exitcode;
    int64 progticks;
    pc_initbytecode(frompc);
    pc_decls_varstack = (struct pc_decls_varrec (*)[])(malloc((uint64)((int64)1120000)));
    if (!(!!(pc_decls_varstack))) {
        mlib_abortprogram((byte*)"varstack?");
    }
    pc_decls_sptr = &(*pc_decls_varstack)[((int64)70000)];
    --pc_decls_sptr;
    pc_decls_frameptr = (byte *)(pc_decls_sptr);
    pc_decls_pcptr = &(*pc_decls_moduletable[((int64)0)].pccode)[((int64)1)-1];
    pc_decls_pccode = (uint64 (*)[])(&(*pc_decls_moduletable[((int64)0)].pccode)[((int64)0)-1]);
    pc_khandlers_stopped = (uint8)0u;
    if (!!(pc_decls_fverbose)) {
        printf("%s\n",(char*)((byte*)"Starting Interpreter..."));
    }
    progticks = osnos_os_clock();
    pc_disploop();
    if (!!(pc_decls_logdev)) {
        fclose(pc_decls_logdev);
    }
    if (!!(pc_decls_fverbose)) {
        printf("%s\n",(char*)((byte*)"\nInterpreter stopped."));
    }
    progticks = (osnos_os_clock() - progticks);
    if (!!(pc_fshowtimes)) {
        printf("%s %lld %s\n",(char*)((byte*)"Run time:"),(int64)progticks,(char*)((byte*)"msec"));
    }
    if (((int64)((*pc_decls_sptr).tagx) == (int64)0)) {
        return (int64)0;
    }
    else {
        return (*pc_decls_sptr).value;
    }
}

static void pc_initbytecode(int64 frompc) {
    osnos_os_initwindows();
    pc_allocatestrings();
    pc_pclinit();
    pc_pcl_initusertypes();
    pc_fixup_all_pc();
}

static void pc_disploop(void) {
    int64 i;
    int64 k;
    if ((pc_dispatch_type==(int64)2)) {
        pc_disploop_fn((int64)0);
    } else if ((pc_dispatch_type==(int64)4)) {
        pc_disploop_deb();
    } else if ((pc_dispatch_type==(int64)1)) {
        pc_support_loaderror((byte*)"-LAB not available",(byte*)"");
    } else if ((pc_dispatch_type==(int64)3)) {
        pc_support_loaderror((byte*)"-SW not available",(byte*)"");
    } else if ((pc_dispatch_type==(int64)5)) {
        k = osnos_os_clock();
        pc_assem_c_disploop_asm();
        k = (osnos_os_clock() - k);
        pc_assem_c_disploop_asm();
    }
}

static void pc_pclinit(void) {
    int64 i;
L11:;
    for (i=(int64)1;i<=(int64)216;++i) {
L12:;
        if ((pc_dispatch_type==(int64)2)) {
            pq_common_cmdmap[(i)] = (void *)(pc_disploop_fn(i));
        } else if ((pc_dispatch_type==(int64)3)) {
            pq_common_cmdmap[(i)] = (void *)(i);
        } else if ((pc_dispatch_type==(int64)4)) {
            pq_common_cmdmap[(i)] = (void *)(i);
        } else if ((pc_dispatch_type==(int64)5)) {
            pq_common_cmdmap[(i)] = (void *)(i);
        }
L13:;
    }
L14:;
}

static void pc_fixup_all_pc(void) {
    int64 i;
    int64 j;
    int64 cmd;
    int64 lab;
    int64 a;
    int64 index;
    int64 startindex;
    int64 recordtype;
    int64 fieldtype;
    int64 mx;
    int64 pp;
    int64 a64;
    struct pc_decls_genfielddatarec gd;
    uint64 *  p;
L15:;
    for (mx=(int64)1;mx<=pc_decls_nmodules;++mx) {
L16:;
        pc_fixup_module_pc(mx);
L17:;
    }
L18:;
    pc_fixup_module_pc((int64)0);
}

static void pc_fixup_module_pc(int64 mx) {
    int64 i;
    int64 cmd;
    int64 lab;
    int64 index;
    int64 startindex;
    int64 recordtype;
    int64 fieldtype;
    int64 pp;
    int64 m;
    int64 a;
    struct pc_decls_genfielddatarec gd;
    uint64 *  p;
    uint64 *  pccode;
    struct pc_decls_strec *  d;
    struct pc_decls_strec *  owner;
    static int64 scount = (int64)0;
    struct pc_decls_varrec *  v;
    int64 av_1;
    pccode = (p = (uint64 *)(pc_decls_moduletable[(mx)].pccode));
L19:;
    while (1) {
        cmd = (int64)((*p));
        if ((mx == (int64)0)) {
            if (((cmd == (int64)73) && (pc_decls_stopseq == 0))            ) {
                pc_decls_stopseq = (p - (int64)2);
            }
            else if (((cmd == (int64)208) && (pc_decls_raiseseq == 0))) {
                pc_decls_raiseseq = p;
            }
        }
        (*p++) = (uint64)(pq_common_cmdmap[(cmd)]);
L21:;
        for (i=(int64)1;i<=pc_decls_cmdnopnds[(cmd)];++i) {
L22:;
            switch ((int64)(pq_common_cmdfmt[(cmd)][(i)-1])) {
            case 8:;
                (*p) = (uint64)(((pccode + (int64)((*p))) - (int64)1));
                break;
            case 3:;
                d = &(*pc_decls_pcsymboltable)[((int64)((*p)))-1];
                if (((*d).address == 0)) {
                    owner = (*d).owner;
L25:;
                    while (((int64)((*owner).nameid) == (int64)5)) {
                        owner = (*owner).owner;
L26:;
                    }
L27:;
                    m = (int64)((*owner).ax_moduleno);
                    (*d).address = (void *)(&(*pc_decls_moduletable[(m)].pccode)[((int64)((*d).index))-1]);
                }
                (*p) = (uint64)((*d).address);
                break;
            case 1:;
                d = &(*pc_decls_pcsymboltable)[((int64)((*p)))-1];
                if (((*d).address == 0)) {
                    v = (struct pc_decls_varrec *)(mlib_pcm_alloc((int64)16));
                    (*v).tagx = (uint32)0u;
                    (*d).address = (void *)(v);
                }
                (*p) = (uint64)((*d).address);
                break;
            case 14:;
                (*p) = (uint64)(&(*pc_decls_stringobjtable)[((int64)((*p)))]);
                break;
            default:;
            }
            ++p;
L23:;
        }
L24:;
        if (((cmd == (int64)4) || (cmd == (int64)0))) {
            goto L20;
        }
    }
L20:;
    if ((pc_dispatch_type == (int64)5)) {
        pc_assem_c_fixup_asm(mx);
    }
}

static int64 * pc_disploop_fn(int64 n) {
    int64 count;
    uint64 lastticks;
    uint64 ticks;
    if (!!(n)) {
        return (int64 *)(pc_handlertable[(n)]);
    }
    count = (int64)1;
    lastticks = (uint64)(osnos_os_clock());
L28:;
    do {
        pc_decls_pcptr = ((*(*(uint64 * (**)(void))(pc_decls_pcptr))))();
L29:;
    } while (!!!(pc_khandlers_stopped));;
L30:;
    ticks = (uint64)((osnos_os_clock() - (int64)(lastticks)));
    return (int64 *)(0);
}

static void pc_disploop_deb(void) {
    int64 a;
    int64 b;
    int64 i;
    int64 j;
    int64 k;
    int64 totalcounts;
    int64 lastcmd;
    int64 cmd;
    int64 t;
    int64 u;
    int64 index;
    int64 file;
    int64 line;
    int64 moduleno;
    struct pc_decls_varrec *  p;
    int64 count;
    int64 * (*fn)(void);
    uint64 lastticks;
    uint64 ticks;
    byte *  filename;
    count = (int64)1;
    lastticks = (uint64)(osnos_os_clock());
    lastcmd = (int64)1;
L31:;
    do {
        cmd = (int64)((*pc_decls_pcptr));
        if (((!!(mlib_fdebug) && !!(pc_decls_fdtrace)) || !!(pc_decls_ftrace))) {
            pc_support_findlinenumber(pc_decls_pcptr,&line,&moduleno);
            index = (&(*pc_decls_varstack)[((int64)70000)] - pc_decls_sptr);
            printf("%p %s%s%s %s %lld %p %s %lld\n",(void*)(pc_decls_pcptr),(char*)((byte*)"<"),(char*)(pq_common_cmdnames[(cmd)]),(char*)((byte*)">"),(char*)((byte*)"LINE="),(int64)line,(void*)(pc_decls_sptr),(char*)((byte*)"INDEX="),(int64)index);
        }
        pc_decls_pcptr = (uint64 *)(((*(int64 * (*)(void))(pc_handlertable[((int64)((*pc_decls_pcptr)))])))());
        if (!!(pc_decls_ftrace)) {
            printf("%s %p\n",(char*)((byte*)"NEXT PCPTR2:"),(void*)(pc_decls_pcptr));
        }
L32:;
    } while (!!!(pc_khandlers_stopped));;
L33:;
    printf("%s\n",(char*)((byte*)"DEB STOPPED"));
}

static void pc_getsyscmdline(void) {
    int64 i;
L34:;
    for (i=(int64)1;i<=msysc_nsysparams;++i) {
L35:;
        if ((i <= (int64)32)) {
            pc_decls_cmdparamtable[((i - (int64)1))] = mlib_pcm_copyheapstring(msysc_sysparams[(i)-1]);
        }
L36:;
    }
L37:;
    pc_decls_ncmdparams = (msysc_nsysparams - (int64)1);
}

static void pc_showmodules(void) {
    int64 i;
    int64 j;
    int64 k;
    struct pc_decls_modulerec m;
    int64 av_1;
    printf("%s %lld\n",(char*)((byte*)"Modules:"),(int64)pc_decls_nmodules);
L38:;
    for (i=pc_decls_nmodules;i>=(int64)1;--i) {
L39:;
        memcpy(&m,&pc_decls_moduletable[(i)],110);
        j = ((pc_decls_nmodules - i) + (int64)1);
        printf("%lld%s",(int64)j,(char*)((byte*)":"));
        av_1 = (int64)(m.level);
        while (av_1-- > 0) {
L42:;
            printf("%s",(char*)((byte*)"  "));
L43:;
        }
L44:;
        printf("%s %d\n",(char*)(m.name),m.sourcelen);
        printf("%s",(char*)((byte*)"       "));
L45:;
        for (j=(int64)1;j<=pc_decls_nmodules;++j) {
L46:;
            k = (int64)(m.importmap[(j)-1]);
            if (!!(k)) {
                printf("%s%s",(char*)(pc_decls_moduletable[(j)].name),(char*)((byte*)" "));
            }
L47:;
        }
L48:;
puts("");
L40:;
    }
L41:;
    if (!!(pc_decls_nextra)) {
        printf("%s %lld\n",(char*)((byte*)"Extra Modules"),(int64)pc_decls_nextra);
L49:;
        for (i=(int64)1;i<=pc_decls_nextra;++i) {
L50:;
            printf("%lld %s %s %lld %p\n",(int64)i,(char*)((byte*)":"),(char*)(pc_decls_extrafiles[(i)-1]),(int64)pc_decls_extrasizes[(i)-1],(void *)(pc_decls_extratext[(i)-1]));
L51:;
        }
L52:;
    }
}

static void pc_starttiming(void) {
    int64 t;
    t = osnos_os_clock();
L53:;
    do {
L54:;
    } while (!(osnos_os_clock() != t));;
L55:;
    pc_clockstart = osnos_os_clock();
}

static void pc_showtiming(void) {
    int64 t;
    int64 i;
    t = (osnos_os_clock() - pc_clockstart);
    printf("%lld %s\n",(int64)((t * (int64)1000) / osnos_os_getclockspersec()),(char*)((byte*)"msec\tLoad/compile time"));
    printf("%lld%s\n",(int64)pc_totallines,(char*)((byte*)"\tTotal lines compiled"));
    if ((t > (int64)1)) {
        printf("%lld%s\n",(int64)(int64)((((double)(pc_totallines) / (double)(t)) * (double)(osnos_os_getclockspersec()))),(char*)((byte*)"\tLines per second compile speed"));
    }
    printf("%lld%s\n",(int64)pc_totalpclopcodes,(char*)((byte*)"\tPCL byte-codes generated"));
}

void pc_runproc(void * fnptr,struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec *  oldsptr;
    byte *  oldframeptr;
    uint64 *  oldpcptr;
    byte oldstopped;
    int64 nparams;
    (*dest).tagx = (uint32)39u;
    (*dest).value = (int64)0;
    oldstopped = pc_khandlers_stopped;
    oldpcptr = pc_decls_pcptr;
    oldsptr = pc_decls_sptr;
    oldframeptr = pc_decls_frameptr;
    (*--pc_decls_sptr).tagx = (uint32)999u;
    if ((!!(b) && !!((*b).tag))    ) {
        nparams = (int64)2;
        (*--pc_decls_sptr) = (*b);
        (*--pc_decls_sptr) = (*a);
    }
    else if ((!!(a) && !!((*a).tag))) {
        nparams = (int64)1;
        (*--pc_decls_sptr) = (*a);
    }
    else {
        nparams = (int64)0;
    }
    (*--pc_decls_sptr).tagx = (uint32)16u;
    (*pc_decls_sptr).retaddr = pc_decls_stopseq;
    (*pc_decls_sptr).frameptr_low = (int32)(*(int64*)&pc_decls_frameptr);
    (*pc_decls_sptr).stackadj = (byte)((nparams * (int64)16));
    pc_decls_frameptr = (byte *)(pc_decls_sptr);
    pc_decls_pcptr = (uint64 *)(fnptr);
    pc_disploop();
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)16)) {
        printf("%s\n",(char*)((byte*)"RUNPROC: STOP used"));
        (*dest) = (*pc_decls_sptr);
    }
    else {
        ++pc_decls_sptr;
        (*dest) = (*pc_decls_sptr);
        if (((int64)((*dest).tag) == (int64)0)) {
            (*dest).tagx = (uint32)39u;
            (*dest).value = (int64)0;
        }
        else {
        }
    }
    pc_decls_pcptr = oldpcptr;
    pc_khandlers_stopped = oldstopped;
    pc_decls_sptr = oldsptr;
    pc_decls_frameptr = oldframeptr;
    pc_khandlers_stopped = oldstopped;
}

static void pc_showinttiming(byte * caption) {
    int64 t;
    int64 i;
    t = (osnos_os_clock() - pc_clockstart);
    printf("%lld %s %s\n",(int64)((t * (int64)1000) / osnos_os_getclockspersec()),(char*)((byte*)"msec"),(char*)(caption));
}

static void pc_allocatestrings(void) {
    struct pc_decls_objrec *  p;
    int64 i;
    byte *  s;
    pc_decls_stringobjtable = (struct pc_decls_objrec (*)[])(mlib_zalloctable(pc_decls_nstrings,(int64)32));
L56:;
    for (i=(int64)1;i<=pc_decls_nstrings;++i) {
L57:;
        s = (*pc_decls_stringtable)[(i)-1];
        p = &(*pc_decls_stringobjtable)[(i)];
        (*p).refcount = (uint32)5u;
        (*p).strptr = s;
        (*p).length = (uint32)((*pc_decls_stringlentable)[(i)-1]);
        (*p).objtype = (uint8)2u;
L58:;
    }
L59:;
}

static int64 pc_loadprogram(byte * filespec,int64 * filetype) {
    byte cmdstr[300];
    byte *  pcfile;
    int64 stopcode;
    if (((*filetype)==(int64)17232)) {
        return pc_loadpcfile(filespec);
    }
    else {
        pcfile = mlib_pcm_copyheapstring(mlib_changeext(filespec,(byte*)"pc"));
        if (!(!!(qc_qcompiler(filespec,pcfile)))) {
            pc_support_loaderror((byte*)"Couldn't compile",filespec);
        }
        return pc_loadpcfile(pcfile);
    }
    return (int64)0;
}

static int64 pc_loadpcfile(byte * filespec) {
    byte modulename[100];
    byte name[100];
    byte *  s;
    byte *  str;
    byte *  str2;
    struct pc_decls_modulerec m;
    int64 i;
    int64 j;
    int64 a;
    int64 b;
    int64 dir;
    int64 symtype;
    int64 x;
    int64 id;
    int64 t;
    int64 modno;
    int64 n;
    int64 cmd;
    int64 recordtype;
    int64 length;
    struct pc_decls_strec *  d;
    uint16 (*linetable)[];
    uint64 *  pccode;
    double xvalue;
    int64 av_1;
    mlib_pcm_clearmem((void *)(&pc_decls_moduletable[((int64)0)]),(int64)110);
    pc_decls_moduletable[((int64)0)].name = (byte*)"PROGRAM";
    pc_decls_moduletable[((int64)0)].filename = (byte*)"<->";
    pc_decls_moduletable[((int64)0)].sourcecode = (byte*)"<program>";
    pc_decls_moduletable[((int64)0)].sourcelen = (int32)(strlen(pc_decls_moduletable[((int64)0)].sourcecode));
    if ((pc_packfileptr == 0)) {
        s = mlib_readfile(filespec);
    }
    else {
        s = pc_packfileptr;
    }
    if ((s == 0)) {
        printf("%s %s %s\n",(char*)((byte*)"S="),(char*)(s),(char*)(filespec));
        pc_support_loaderror((byte*)"Can't load pc file:",filespec);
        return (int64)0;
    }
    a = (int64)((*s++));
    b = (int64)((*s++));
    if (((a != (int64)80) || (b != (int64)67))) {
        printf("%s\n",(char*)((byte*)"PC: bad sig"));
        return (int64)0;
    }
    s += (int64)2;
L60:;
    while (1) {
        dir = pc_support_readzint(&s);
        switch (dir) {
        case 1:;
            str = pc_support_readzstring(&s,(int64 *)(0));
            break;
        case 2:;
            pc_decls_nmodules = pc_support_readzint(&s);
L62:;
            for (i=(int64)1;i<=pc_decls_nmodules;++i) {
L63:;
                memset((void *)(&m),(int32)0,(uint64)((int64)110));
                m.name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64 *)(0)));
                m.filename = m.name;
                m.sourcecode = (byte*)"<no source>";
                m.sourcelen = (int32)0;
                memcpy(&pc_decls_moduletable[(i)],&m,110);
L64:;
            }
L65:;
            break;
        case 3:;
            pc_decls_ndlltable = pc_support_readzint(&s);
L66:;
            for (i=(int64)1;i<=pc_decls_ndlltable;++i) {
L67:;
                pc_decls_dlltable[(i)-1] = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64 *)(0)));
                pc_decls_dllinsttable[(i)-1] = (uint64)((int64)0);
L68:;
            }
L69:;
            break;
        case 4:;
            pc_decls_ndllproctable = pc_support_readzint(&s);
L70:;
            for (i=(int64)1;i<=pc_decls_ndllproctable;++i) {
L71:;
                pc_decls_dllproctable[(i)-1].name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64 *)(0)));
                pc_decls_dllproctable[(i)-1].dllindex = (int32)(pc_support_readzint(&s));
L72:;
            }
L73:;
            break;
        case 5:;
            pc_decls_nsymbols = pc_support_readzint(&s);
            pc_decls_pcsymboltable = (struct pc_decls_strec (*)[])(mlib_zalloctable(pc_decls_nsymbols,(int64)60));
L74:;
            for (i=(int64)1;i<=pc_decls_nsymbols;++i) {
L75:;
                symtype = pc_support_readzint(&s);
                if ((symtype==(int64)80)) {
                    id = (int64)6;
                } else if ((symtype==(int64)83)) {
                    id = (int64)10;
                } else if ((symtype==(int64)77)) {
                    id = (int64)2;
                } else if ((symtype==(int64)84)) {
                    id = (int64)5;
                }
                str = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64 *)(0)));
                x = pc_support_readzint(&s);
                a = pc_support_readzint(&s);
                b = pc_support_readzint(&s);
                d = pc_createstentry(i,str,x,id);
                (*d).index = (int32)(a);
                if ((id==(int64)2)) {
                    (*d).ax_moduleno = (byte)(a);
                } else if ((id==(int64)6)) {
                    str = pc_support_readzstring(&s,(int64 *)(0));
                    if (!!((*str))) {
                        (*d).metadata = mlib_pcm_copyheapstring(str);
                    }
                }
L76:;
            }
L77:;
            break;
        case 6:;
            n = pc_support_readzint(&s);
            pc_decls_ntypes = ((n + (int64)53) - (int64)1);
L78:;
            for (i=(int64)1;i<=n;++i) {
L79:;
                t = pc_support_readzint(&s);
                pc_decls_ttname[(t)] = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64 *)(0)));
                pc_decls_ttnamedef[(t)] = &(*pc_decls_pcsymboltable)[(pc_support_readzint(&s))-1];
                pc_decls_ttbasetype[(t)] = (int32)(pc_support_readzint(&s));
                pc_decls_tttarget[(t)] = (int32)(pc_support_readzint(&s));
                pc_decls_ttlower[(t)] = (int32)(pc_support_readzint(&s));
                pc_decls_ttlength[(t)] = (uint32)(pc_support_readzint(&s));
                pc_decls_ttsize[(t)] = pc_support_readzint(&s);
L80:;
            }
L81:;
            break;
        case 7:;
            pc_decls_ngenfieldnames = pc_support_readzint(&s);
L82:;
            for (i=(int64)1;i<=pc_decls_ngenfieldnames;++i) {
L83:;
                pc_decls_genfieldnames[(i)-1].name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64 *)(0)));
                pc_decls_genfieldnames[(i)-1].dataindex = (int32)(pc_support_readzint(&s));
                pc_decls_genfieldnames[(i)-1].datalength = (int32)(pc_support_readzint(&s));
L84:;
            }
L85:;
            break;
        case 8:;
            pc_decls_ngenfielddata = pc_support_readzint(&s);
            if ((pc_decls_ngenfielddata > (int64)1000)) {
                pc_support_loaderror((byte*)"Too many genfields",(byte*)"");
            }
L86:;
            for (i=(int64)1;i<=pc_decls_ngenfielddata;++i) {
L87:;
                pc_decls_genfielddata[(i)-1].fieldindex = (int32)(pc_support_readzint(&s));
                pc_decls_genfielddata[(i)-1].recordtype = (int32)(pc_support_readzint(&s));
                pc_decls_genfielddata[(i)-1].fieldtype = (int32)(pc_support_readzint(&s));
                a = pc_support_readzint(&s);
                if (((int64)(pc_decls_genfielddata[(i)-1].fieldtype) == (int64)18)) {
                    pc_decls_genfieldpcaddress[(i)-1] = pc_getprocaddr(a);
                }
                else {
                    pc_decls_genfielddata[(i)-1].offset = (int32)(a);
                }
L88:;
            }
L89:;
            break;
        case 9:;
            pc_support_loaderror((byte*)"OLD STRING TABLE SEEN",(byte*)"");
            pc_decls_nstrings = pc_support_readzint(&s);
            pc_decls_stringtable = (byte * (*)[])(mlib_alloctable(pc_decls_nstrings,(int64)8));
            pc_decls_stringlentable = (int64 (*)[])(mlib_alloctable(pc_decls_nstrings,(int64)8));
L90:;
            for (i=(int64)1;i<=pc_decls_nstrings;++i) {
L91:;
                pc_support_readzstring(&s,(int64 *)(0));
L92:;
            }
L93:;
            break;
        case 13:;
            pc_decls_nstrings = pc_support_readzint(&s);
            pc_decls_stringtable = (byte * (*)[])(mlib_alloctable(pc_decls_nstrings,(int64)8));
            pc_decls_stringlentable = (int64 (*)[])(mlib_alloctable(pc_decls_nstrings,(int64)8));
L94:;
            for (i=(int64)1;i<=pc_decls_nstrings;++i) {
L95:;
                length = pc_support_readzint(&s);
                str = pc_support_readzblock(&s,length);
                (*pc_decls_stringlentable)[(i)-1] = length;
                str2 = (byte *)(mlib_pcm_alloc((length + (int64)1)));
                memcpy((void *)(str2),(void *)(str),(uint64)(length));
                (*(str2 + length)) = (uint8)0u;
                (*pc_decls_stringtable)[(i)-1] = str2;
L96:;
            }
L97:;
            break;
        case 10:;
            pc_decls_nstructfields = pc_support_readzint(&s);
            pc_decls_pcfieldtable = (struct pc_decls_fieldrec (*)[])(mlib_zalloctable(pc_decls_nstructfields,(int64)60));
            t = (int64)0;
            n = (int64)0;
L98:;
            for (i=(int64)1;i<=pc_decls_nstructfields;++i) {
L99:;
                recordtype = pc_support_readzint(&s);
                if ((recordtype != t)) {
                    if (!!(t)) {
                        pc_decls_ttstructfields[(t)] = (int32)(n);
                    }
                    t = recordtype;
                    pc_decls_ttstartfield[(t)] = (int32)(i);
                    n = (int64)0;
                }
                ++n;
                (*pc_decls_pcfieldtable)[(i)-1].recordtype = (int16)(recordtype);
                (*pc_decls_pcfieldtable)[(i)-1].name = mlib_pcm_copyheapstring(pc_support_readzstring(&s,(int64 *)(0)));
                (*pc_decls_pcfieldtable)[(i)-1].fieldtype = (int16)(pc_support_readzint(&s));
                (*pc_decls_pcfieldtable)[(i)-1].fieldoffset = (int32)(pc_support_readzint(&s));
L100:;
            }
L101:;
            if (!!(t)) {
                pc_decls_ttstructfields[(t)] = (int32)(n);
            }
            break;
        case 11:;
            modno = pc_support_readzint(&s);
            n = pc_support_readzint(&s);
            pc_decls_moduletable[(modno)].linetable = (linetable = (uint16 (*)[])(mlib_zalloctable(n,(int64)2)));
            pc_decls_moduletable[(modno)].pccode = (uint64 (*)[])(mlib_zalloctable(n,(int64)8));
            pccode = (uint64 *)(pc_decls_moduletable[(modno)].pccode);
            pc_decls_moduletable[(modno)].pcindex = (int32)(n);
            pc_decls_moduletable[(modno)].npccode = (int32)(n);
            i = (int64)0;
L102:;
            while ((++i <= n)) {
                (*linetable)[(i)] = (uint16)(pc_support_readzint(&s));
                cmd = pc_support_readzint(&s);
                (*pccode++) = (uint64)(cmd);
L105:;
                for (j=(int64)1;j<=pc_decls_cmdnopnds[(cmd)];++j) {
L106:;
                    ++i;
                    if (((int64)(pq_common_cmdfmt[(cmd)][(j)-1])==(int64)12)) {
                        xvalue = pc_support_readzreal(&s);
                        (*pccode++) = *(uint64*)&xvalue;
                    }
                    else {
                        a = pc_support_readzint(&s);
                        (*pccode++) = (uint64)(a);
                    }
L107:;
                }
L108:;
L103:;
            }
L104:;
            break;
        case 12:;
            goto L61;
            break;
        default:;
            pc_support_loaderror((byte*)"PCDIR?",(byte*)"");
        }
    }
L61:;
    return (int64)1;
}

void pc_initpcldata(void) {
    int64 i;
    int64 j;
    int64 nn;
L109:;
    for (i=(int64)1;i<=(int64)216;++i) {
L110:;
        nn = (int64)0;
L113:;
        for (j=(int64)1;j<=(int64)4;++j) {
L114:;
            if (((int64)(pq_common_cmdfmt[(i)][(j)-1]) == (int64)0)) {
                goto L116;
            }
            ++nn;
L115:;
        }
L116:;
        pc_decls_cmdnopnds[(i)] = nn;
L111:;
    }
L112:;
}

static struct pc_decls_strec * pc_createstentry(int64 index,byte * name,int64 owner,int64 id) {
    struct pc_decls_strec *  p;
    if (!!(index)) {
        p = &(*pc_decls_pcsymboltable)[(index)-1];
    }
    else {
        p = (struct pc_decls_strec *)(mlib_pcm_allocz((int64)60));
    }
    (*p).name = name;
    (*p).nameid = (byte)(id);
    if (!!(owner)) {
        (*p).owner = &(*pc_decls_pcsymboltable)[(owner)-1];
    }
    else {
        (*p).owner = pc_decls_stprogram;
    }
    return p;
}

static void pc_findnewestfile(byte * * lastfilename,int64 * lastfiletime,int64 * lastfiletype,byte * filename,byte * fileext,int64 filetype) {
    byte *  file;
    int64 filetime;
    file = mlib_addext(filename,fileext);
    filetime = osnos_os_filelastwritetime(file);
    if ((filetime == (int64)0)) {
        return;
    }
    if ((filetime > (*lastfiletime))) {
        (*lastfilename) = mlib_pcm_copyheapstring(file);
        (*lastfiletime) = filetime;
        (*lastfiletype) = filetype;
    }
}

static void pc_showcaption(void) {
    printf("%s%s %s%s\n",(char*)((byte*)"3:PCL Interpreter 18.3.21 ("),(char*)(pc_decls_dispatchnames[(pc_dispatch_type)-1]),(char*)((byte*)"C64"),(char*)((byte*)")BART4"));
}

static uint64 * pc_getprocaddr(int64 n) {
    struct pc_decls_strec *  d;
    struct pc_decls_strec *  owner;
    int64 m;
    d = &(*pc_decls_pcsymboltable)[(n)-1];
    if (((*d).address == 0)) {
        owner = (*d).owner;
L117:;
        while (((int64)((*owner).nameid) == (int64)5)) {
            owner = (*owner).owner;
L118:;
        }
L119:;
        m = (int64)((*owner).ax_moduleno);
        (*d).address = (void *)(&(*pc_decls_moduletable[(m)].pccode)[((int64)((*d).index))-1]);
    }
    return (uint64 *)((*d).address);
}

static int32 pc_getfileint(byte * data,int64 offset) {
    return (*(int32 *)((data + offset)));
}

static int64 pc_checkpackfile(void) {
    int64 a;
    int64 offset;
    int64 i;
    int64 size;
    byte name[100];
    byte exefile[300];
    return (int64)0;
    strcpy(&exefile[((int64)1)-1],osnos_os_gethostname());
    printf("%s %p\n",(char*)((byte*)"Attempting to open"),(void*)(&exefile));
    pc_packexeptr = mlib_readfile(&exefile[((int64)1)-1]);
    if (!(!!(pc_packexeptr))) {
        printf("%s %p %p\n",(char*)((byte*)"Can't open"),(void*)(&exefile),(void*)(&pc_packexeptr));
        exit(0);
    }
    pc_packexesize = mlib_rfsize;
    printf("%s %lld\n",(char*)((byte*)"File read OK. Size"),(int64)pc_packexesize);
    a = (int64)(pc_getfileint(pc_packexeptr,(pc_packexesize - (int64)4)));
    if ((a != (int64)1262568272)) {
        free((void *)(pc_packexeptr));
        pc_packfileptr = (byte *)(0);
        return (int64)0;
    }
    offset = (int64)(pc_getfileint(pc_packexeptr,(pc_packexesize - (int64)8)));
    pc_packfilename = (pc_packexeptr + offset);
    offset += ((int64)(strlen(pc_packfilename)) + (int64)1);
    pc_packfilesize = (int64)(pc_getfileint(pc_packexeptr,offset));
    pc_packfileptr = ((pc_packexeptr + offset) + (int64)4);
    return (int64)1;
}

void pc_pcl_initusertypes(void) {
    int64 t;
    int64 sig;
    int64 basesig;
L120:;
    for (t=(int64)53;t<=pc_decls_ntypes;++t) {
L121:;
        if (((int64)(pc_decls_ttbasetype[(t)])==(int64)32)) {
            pc_decls_free_table[(t)] = (void (*)(struct pc_decls_varrec *))(&pc_pcfns_j_free_l_m_d);
            pc_decls_dupl_table[(t)] = (void (*)(struct pc_decls_varrec *))(&pc_pcfns_j_dupl_l_m_d);
            pc_decls_tostr_table[(t)] = (void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_fmtrec *,struct pc_decls_objrec *))(&pc_print_j_tostr_l);
            pc_decls_len_table[(t)] = pc_decls_len_table[((int64)32)];
            pc_decls_lwb_table[(t)] = pc_decls_lwb_table[((int64)32)];
            pc_decls_upb_table[(t)] = pc_decls_upb_table[((int64)32)];
            basesig = pc_support_gettypesig((int64)32,(int64)1);
            sig = pc_support_gettypesig(t,(int64)1);
            pc_decls_pushdotix_dtable[(sig)] = pc_decls_pushdotix_dtable[(basesig)];
            pc_decls_pushdotixref_dtable[(sig)] = pc_decls_pushdotixref_dtable[(basesig)];
        } else if (((int64)(pc_decls_ttbasetype[(t)])==(int64)33)) {
            pc_decls_free_table[(t)] = pc_decls_free_table[((int64)33)];
            pc_decls_dupl_table[(t)] = pc_decls_dupl_table[((int64)33)];
            pc_decls_tostr_table[(t)] = pc_decls_tostr_table[((int64)33)];
        } else if (((int64)(pc_decls_ttbasetype[(t)])==(int64)30)) {
            pc_decls_free_table[(t)] = pc_decls_free_table[((int64)30)];
            pc_decls_dupl_table[(t)] = pc_decls_dupl_table[((int64)30)];
            pc_decls_tostr_table[(t)] = pc_decls_tostr_table[((int64)30)];
            pc_decls_len_table[(t)] = pc_decls_len_table[((int64)30)];
            pc_decls_lwb_table[(t)] = pc_decls_lwb_table[((int64)30)];
            pc_decls_upb_table[(t)] = pc_decls_upb_table[((int64)30)];
            basesig = pc_support_gettypesig((int64)30,(int64)1);
            sig = pc_support_gettypesig(t,(int64)1);
            pc_decls_pushix_dtable[(sig)] = pc_decls_pushix_dtable[(basesig)];
            pc_decls_pushixref_dtable[(sig)] = pc_decls_pushixref_dtable[(basesig)];
        }
L122:;
    }
L123:;
}

int64 msysc_m_getdotindex(uint64 a,int64 i) {
    return (((int64)(a) & ((int64)1 << i)) >> i);
}

void msysc_m_setdotindex(uint64 * a,int64 i,int64 x) {
    uint32 *  a32;
    if ((i >= (int64)32)) {
        (*a) = (uint64)((((int64)((*a)) & ~(((int64)1 << i))) | (int64)(((uint64)(x) << i))));
    }
    else {
        a32 = (uint32 *)(a);
        (*a32) = (uint32)((((int64)((*a32)) & ~(((int64)1 << i))) | (int64)(((uint64)(x) << i))));
    }
}

int64 msysc_m_getdotslice(uint64 a,int64 i,int64 j) {
    if ((i >= j)) {
        return (int64)(((a >> j) & ~(((uint64)18446744073709551615u << ((i - j) + (int64)1)))));
    }
    else {
        return (int64)(((a >> i) & ~(((uint64)18446744073709551615u << ((j - i) + (int64)1)))));
    }
}

void msysc_m_setdotslice(uint64 * a,int64 i,int64 j,uint64 x) {
    int64 w;
    uint64 mask64;
    uint64 mask;
    uint32 *  a32;
    if ((i > j)) {
        printf("%s\n",(char*)((byte*)"SETDOTSLICE?"));
        exit(0);
    }
    if ((j >= (int64)32)) {
        mask64 = (~(((uint64)18446744073709551615u << ((j - i) + (int64)1))) << i);
        (*a) = (((*a) & ~(mask64)) | (x << i));
    }
    else {
        a32 = (uint32 *)(a);
        mask = (~(((uint64)18446744073709551615u << ((j - i) + (int64)1))) << i);
        (*a32) = (uint32)((((uint64)((*a32)) & ~(mask)) | (x << i)));
    }
}

int64 msysc_m_getnprocs(void) {
    return msysc__fnnprocs;
}

void * msysc_m_getprocaddr(int64 n) {
    return msysc__fnaddresses[(n)-1];
}

byte * msysc_m_getprocname(int64 n) {
    return msysc__fnnames[(n)-1];
}

int64 msysc_m_imin(int64 a,int64 b) {
    return (a<b?a:b);
}

int64 msysc_m_imax(int64 a,int64 b) {
    return (a>b?a:b);
}

void * mlib_pcm_alloc(int64 n) {
    byte *  p;
    int64 i;
    if (!(!!(mlib_pcm_setup))) {
        mlib_abortprogram((byte*)"need pcm_init");
    }
    if ((n > (int64)2048)) {
        mlib_alloccode = mlib_pcm_getac(n);
        mlib_allocbytes = (int64)(mlib_allocupper[(mlib_alloccode)]);
        p = (byte *)(mlib_allocmem(mlib_allocbytes));
        if (!(!!(p))) {
            mlib_abortprogram((byte*)"pcm_alloc failure");
        }
        if (!!((int64)0)) {
            mlib_addtomemalloc((int32 *)(p),mlib_allocbytes);
        }
        return (void *)(p);
    }
    mlib_alloccode = (int64)(mlib_sizeindextable[(n)]);
    if ((mlib_alloccode == (int64)0)) {
        mlib_alloccode = (int64)1;
    }
    mlib_allocbytes = (int64)(mlib_allocupper[(mlib_alloccode)]);
    if (!!((p = (byte *)(mlib_freelist[(mlib_alloccode)])))) {
        if (!!((int64)0)) {
            mlib_addtomemalloc((int32 *)(p),mlib_allocbytes);
        }
        mlib_freelist[(mlib_alloccode)] = (uint64 *)((*mlib_freelist[(mlib_alloccode)]));
        return (void *)(p);
    }
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    }
    if (!!((int64)0)) {
        mlib_addtomemalloc((int32 *)(p),mlib_allocbytes);
    }
    return (void *)(p);
}

void mlib_pcm_free(void * p,int64 n) {
    int64 acode;
    if ((n == (int64)0)) {
        return;
    }
    if ((n > (int64)2048)) {
        if (!!((int64)0)) {
            mlib_removefrommemalloc((int32 *)(p),n);
        }
        free(p);
        return;
    }
    if (!!(p)) {
        acode = (int64)(mlib_sizeindextable[(n)]);
        mlib_smallmemtotal -= (int64)(mlib_allocupper[(acode)]);
        if (!!((int64)0)) {
            mlib_removefrommemalloc((int32 *)(p),(int64)(mlib_allocupper[(acode)]));
        }
        (*(uint64 *)(p)) = (uint64)(mlib_freelist[(acode)]);
        mlib_freelist[(acode)] = (uint64 *)(p);
    }
}

void mlib_pcm_freeac(void * p,int64 alloc) {
    mlib_pcm_free(p,(int64)(mlib_allocupper[(alloc)]));
}

void mlib_pcm_copymem4(void * p,void * q,int64 n) {
    memcpy(p,q,(uint64)(n));
}

void mlib_pcm_clearmem(void * p,int64 n) {
    memset(p,(int32)0,(uint64)(n));
}

void mlib_pcm_init(void) {
    int64 i;
    int64 j;
    int64 k;
    int64 k1;
    int64 k2;
    int64 size;
    static int64 limit = (int64)8589934592;
    int64 av_1;
    if (!!(mlib_pcm_setup)) {
        return;
    }
    mlib_pcm_newblock((int64)0);
L124:;
    for (i=(int64)1;i<=(int64)2048;++i) {
L125:;
        j = (int64)1;
        k = (int64)16;
L128:;
        while ((i > k)) {
            k = (k << (int64)1);
            ++j;
L129:;
        }
L130:;
        mlib_sizeindextable[(i)] = (byte)(j);
L126:;
    }
L127:;
    mlib_allocupper[((int64)1)] = (uint64)((int64)16);
    size = (int64)16;
L131:;
    for (i=(int64)2;i<=(int64)27;++i) {
L132:;
        size *= (int64)2;
        mlib_allocupper[(i)] = (uint64)(size);
        if ((size >= (int64)33554432)) {
            k = i;
            goto L134;
        }
L133:;
    }
L134:;
L135:;
    for (i=(k + (int64)1);i<=(int64)300;++i) {
L136:;
        size += (int64)33554432;
        if ((size < limit)) {
            mlib_allocupper[(i)] = (uint64)(size);
            mlib_maxmemory = (uint64)(size);
        }
        else {
            mlib_maxalloccode = (i - (int64)1);
            goto L138;
        }
L137:;
    }
L138:;
    mlib_pcm_setup = (uint8)1u;
}

int64 mlib_pcm_getac(int64 size) {
    if ((size <= (int64)2048)) {
        return (int64)(mlib_sizeindextable[(size)]);
    }
    size = ((size + (int64)255) >> (int64)8);
    if ((size <= (int64)2048)) {
        return ((int64)(mlib_sizeindextable[(size)]) + (int64)8);
    }
    size = ((size + (int64)63) >> (int64)6);
    if ((size <= (int64)2048)) {
        return ((int64)(mlib_sizeindextable[(size)]) + (int64)14);
    }
    size = ((((size - (int64)2048) + (int64)2047) / (int64)2048) + (int64)22);
    return size;
}

void * mlib_pcm_newblock(int64 itemsize) {
    static int64 totalheapsize;
    byte *  p;
    totalheapsize += (int64)2097152;
    mlib_alloccode = (int64)0;
    p = (byte *)(mlib_allocmem((int64)2097152));
    if ((p == 0)) {
        mlib_abortprogram((byte*)"Can't alloc pc heap");
    }
    mlib_pcheapptr = p;
    mlib_pcheapend = (p + (int64)2097152);
    if ((mlib_pcheapstart == 0)) {
        mlib_pcheapstart = p;
    }
    mlib_pcheapptr += itemsize;
    return (void *)((uint32 *)(p));
}

int64 mlib_pcm_round(int64 n) {
    static int32 allocbytes[9] = {(int32)0,(int32)16,(int32)32,(int32)64,(int32)128,(int32)256,(int32)512,(int32)1024,(int32)2048};
    if ((n > (int64)2048)) {
        return n;
    }
    else {
        return (int64)(allocbytes[((int64)(mlib_sizeindextable[(n)]))]);
    }
}

int64 mlib_pcm_array(int64 n) {
    int64 m;
    if ((n <= (int64)2048)) {
        return mlib_pcm_round(n);
    }
    else {
        m = (int64)2048;
L139:;
        while ((n > m)) {
            m <<= (int64)1;
L140:;
        }
L141:;
        return m;
    }
}

void mlib_pcm_printfreelist(int64 size,uint64 * p) {
    printf("%s %lld\n",(char*)((byte*)"Size: "),(int64)size);
L142:;
    while (!!(p)) {
        printf((byte*)" %llX",(uint64)(p));
        p = (uint64 *)((*p));
L143:;
    }
L144:;
    puts((byte*)"");
}

void mlib_pcm_diags(byte * caption) {
    int64 i;
    int64 m;
    printf("%s %s\n",(char*)((byte*)"HEAP FREELISTS:"),(char*)(caption));
    m = (int64)16;
L145:;
    for (i=(int64)1;i<=(int64)8;++i) {
L146:;
        mlib_pcm_printfreelist(m,mlib_freelist[(i)]);
        m <<= (int64)1;
L147:;
    }
L148:;
}

void * mlib_pcm_allocz(int64 n) {
    void *  p;
    p = mlib_pcm_alloc(n);
    memset(p,(int32)0,(uint64)(n));
    return p;
}

byte * mlib_pcm_copyheapstring(byte * s) {
    byte *  q;
    int64 n;
    if ((s == 0)) {
        return (byte *)(0);
    }
    n = ((int64)(strlen(s)) + (int64)1);
    q = (byte *)(mlib_pcm_alloc(n));
    memcpy((void *)(q),(void *)(s),(uint64)(n));
    return q;
}

static void mlib_addtomemalloc(int32 * ptr,int64 size) {
    int64 i;
    printf("%s %p %lld\n",(char*)((byte*)"***************ADD TO ALLOC:"),(void*)(ptr),(int64)size);
L149:;
    for (i=(int64)1;i<=(int64)100000;++i) {
L150:;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            printf("%s %p %s\n",(char*)((byte*)"ALLOC ERROR:"),(void*)(ptr),(char*)((byte*)"ALREADY ALLOCATED\n\n\n"));
            exit((int64)1);
        }
        if ((mlib_memalloctable[(i)-1] == 0)) {
            mlib_memalloctable[(i)-1] = ptr;
            mlib_memallocsize[(i)-1] = (int32)(size);
            return;
        }
L151:;
    }
L152:;
    exit((int64)1);
}

static void mlib_removefrommemalloc(int32 * ptr,int64 size) {
    int64 i;
    printf("%s %p %lld\n",(char*)((byte*)"------------------************REMOVE FROM ALLOC:"),(void*)(ptr),(int64)size);
L153:;
    for (i=(int64)1;i<=(int64)100000;++i) {
L154:;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            if (((int64)(mlib_memallocsize[(i)-1]) != size)) {
                printf("%s %p %s %lld %s %d\n",(char*)((byte*)"REMOVE:FOUND"),(void*)(ptr),(char*)((byte*)"IN MEMALLOCTABLE, FREESIZE="),(int64)size,(char*)((byte*)", BUT STORED AS BLOCK SIZE:"),mlib_memallocsize[(i)-1]);
                mlib_abortprogram((byte*)"MEMSIZE");
            }
            mlib_memalloctable[(i)-1] = (int32 *)(0);
            return;
        }
L155:;
    }
L156:;
    printf("%s %p %s %lld\n",(char*)((byte*)"CAN'T FIND"),(void*)(ptr),(char*)((byte*)"IN MEMALLOCTABLE"),(int64)size);
    mlib_abortprogram((byte*)"MEM");
    exit((int64)1);
}

void * mlib_allocmem(int64 n) {
    void *  p;
    p = malloc((uint64)(n));
    if (!!(p)) {
        return p;
    }
    printf("%lld %lld\n",(int64)n,(int64)mlib_memtotal);
    mlib_abortprogram((byte*)"Alloc mem failure");
    return 0;
}

void * mlib_reallocmem(void * p,int64 n) {
    p = realloc(p,(uint64)(n));
    if (!!(p)) {
        return p;
    }
    printf("%lld\n",(int64)n);
    mlib_abortprogram((byte*)"Realloc mem failure");
    return 0;
}

void mlib_abortprogram(byte * s) {
    printf("%s\n",(char*)(s));
    printf("%s",(char*)((byte*)"ABORTING: Press key..."));
    osnos_os_getch();
    exit((int64)1);
}

int64 mlib_getfilesize(void * handlex) {
    uint32 p;
    uint32 size;
    p = (uint32)(ftell(handlex));
    fseek(handlex,(int32)0,(int32)2);
    size = (uint32)(ftell(handlex));
    fseek(handlex,(int32)(p),(int32)0);
    return (int64)(size);
}

void mlib_readrandom(void * handlex,byte * mem,int64 offset,int64 size) {
    fseek(handlex,(int32)(offset),(int32)0);
    fread((void *)(mem),(uint64)((int64)1),(uint64)(size),handlex);
}

int64 mlib_writerandom(void * handlex,byte * mem,int64 offset,int64 size) {
    fseek(handlex,(int32)(offset),(int32)0);
    return (int64)(fwrite((void *)(mem),(uint64)((int64)1),(uint64)(size),handlex));
}

byte * mlib_readfile(byte * filename) {
    void *  f;
    int64 size;
    byte *  m;
    byte *  p;
    f = fopen(filename,(byte*)"rb");
    if ((f == 0)) {
        return (byte *)(0);
    }
    mlib_rfsize = (size = mlib_getfilesize(f));
    m = (byte *)(malloc((uint64)((size + (int64)4))));
    if ((m == 0)) {
        return (byte *)(0);
    }
    mlib_readrandom(f,m,(int64)0,size);
    p = (m + size);
    (*p) = (uint8)0u;
    (*(p + (int64)1)) = (uint8)26u;
    (*(p + (int64)2)) = (uint8)0u;
    fclose(f);
    return m;
}

int64 mlib_writefile(byte * filename,byte * data,int64 size) {
    void *  f;
    int64 n;
    f = fopen(filename,(byte*)"wb");
    if ((f == 0)) {
        return (int64)0;
    }
    n = mlib_writerandom(f,data,(int64)0,size);
    fclose(f);
    return n;
}

int64 mlib_checkfile(byte * file) {
    void *  f;
    if (!!((f = fopen(file,(byte*)"rb")))) {
        fclose(f);
        return (int64)1;
    }
    return (int64)0;
}

void mlib_readlinen(void * handlex,byte * buffer,int64 size) {
    int64 ch;
    byte *  p;
    int64 n;
    byte buff[100];
    byte crseen;
    if ((handlex == 0)) {
        handlex = osnos_os_getstdin();
    }
    if ((handlex == 0)) {
        n = (int64)0;
        p = buffer;
L157:;
        while (1) {
            ch = (int64)(getchar());
            if ((((ch == (int64)13) || (ch == (int64)10)) || (ch == (int64)-1))) {
                (*p) = (uint8)0u;
                return;
            }
            (*p++) = (byte)(ch);
            ++n;
            if ((n >= (size - (int64)2))) {
                (*p) = (uint8)0u;
                return;
            }
        }
L158:;
    }
    (*buffer) = (uint8)0u;
    if ((fgets(buffer,(size - (int64)2),handlex) == 0)) {
        return;
    }
    n = (int64)(strlen(buffer));
    if ((n == (int64)0)) {
        return;
    }
    p = ((buffer + n) - (int64)1);
    crseen = (uint8)0u;
L159:;
    while (((p >= buffer) && (((int64)((*p)) == (int64)13) || ((int64)((*p)) == (int64)10)))) {
        if ((((int64)((*p)) == (int64)13) || ((int64)((*p)) == (int64)10))) {
            crseen = (uint8)1u;
        }
        (*p--) = (uint8)0u;
L160:;
    }
L161:;
    if ((!(!!(crseen)) && ((n + (int64)4) > size))) {
        printf("%lld %lld\n",(int64)size,(int64)n);
        mlib_abortprogram((byte*)"line too long");
    }
}

void mlib_iconvlcn(byte * s,int64 n) {
    int64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L162:;
        (*s) = (byte)(tolower((int32)((*s))));
        ++s;
L163:;
    }
L164:;
}

void mlib_iconvucn(byte * s,int64 n) {
    int64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L165:;
        (*s) = (byte)(toupper((int32)((*s))));
        ++s;
L166:;
    }
L167:;
}

void mlib_convlcstring(byte * s) {
L168:;
    while (!!((*s))) {
        (*s) = (byte)(tolower((int32)((*s))));
        ++s;
L169:;
    }
L170:;
}

void mlib_convucstring(byte * s) {
L171:;
    while (!!((*s))) {
        (*s) = (byte)(toupper((int32)((*s))));
        ++s;
L172:;
    }
L173:;
}

byte * mlib_changeext(byte * s,byte * newext) {
    static byte newfile[260];
    byte newext2[32];
    byte *  sext;
    int64 n;
    strcpy(&newfile[((int64)1)-1],s);
    if (((int64)((*newext))==(int64)0)) {
        newext2[((int64)1)-1] = (uint8)0u;
        newext2[((int64)2)-1] = (uint8)0u;
    } else if (((int64)((*newext))==(int64)46)) {
        strcpy(&newext2[((int64)1)-1],newext);
    }
    else {
        strcpy(&newext2[((int64)1)-1],(byte*)".");
        strcat(&newext2[((int64)1)-1],newext);
    }
    sext = mlib_extractext(s,(int64)1);
    if (((int64)((*sext))==(int64)0)) {
        strcat(&newfile[((int64)1)-1],&newext2[((int64)1)-1]);
    } else if (((int64)((*sext))==(int64)46)) {
        strcat(&newfile[((int64)1)-1],&newext2[((int64)2)-1]);
    }
    else {
        n = ((sext - s) - (int64)2);
        strcpy(((&newfile[((int64)1)-1] + n) + (int64)1),&newext2[((int64)1)-1]);
    }
    return &newfile[((int64)1)-1];
}

byte * mlib_extractext(byte * s,int64 period) {
    byte *  t;
    byte *  u;
    t = mlib_extractfile(s);
    if (((int64)((*t)) == (int64)0)) {
        return (byte*)"";
    }
    u = ((t + (int64)(strlen(t))) - (int64)1);
L174:;
    while ((u >= t)) {
        if (((int64)((*u)) == (int64)46)) {
            if (((int64)((*(u + (int64)1))) == (int64)0)) {
                return (!!(period)?(byte*)".":(byte*)"");
            }
            return (u + (int64)1);
        }
        --u;
L175:;
    }
L176:;
    return (byte*)"";
}

byte * mlib_extractpath(byte * s) {
    static byte str[260];
    byte *  t;
    int64 n;
    t = ((s + (int64)(strlen(s))) - (int64)1);
L177:;
    while ((t >= s)) {
        switch ((int64)((*t))) {
        case 92:;
        case 47:;
        case 58:;
            n = ((t - s) + (int64)1);
            memcpy((void *)(str),(void *)(s),(uint64)(n));
            str[(n)] = (uint8)0u;
            return str;
            break;
        default:;
        }
        --t;
L178:;
    }
L179:;
    return (byte*)"";
}

byte * mlib_extractfile(byte * s) {
    byte *  t;
    t = mlib_extractpath(s);
    if (((int64)((*t)) == (int64)0)) {
        return s;
    }
    return (s + (int64)(strlen(t)));
}

byte * mlib_extractbasefile(byte * s) {
    static byte str[100];
    byte *  f;
    byte *  e;
    int64 n;
    int64 flen;
    f = mlib_extractfile(s);
    flen = (int64)(strlen(f));
    if ((flen == (int64)0)) {
        return (byte*)"";
    }
    e = mlib_extractext(f,(int64)0);
    if (!!((*e))) {
        n = ((flen - (int64)(strlen(e))) - (int64)1);
        memcpy((void *)(&str),(void *)(f),(uint64)(n));
        str[(n)] = (uint8)0u;
        return str;
    }
    if (((int64)((*((f + flen) - (int64)1))) == (int64)46)) {
        memcpy((void *)(&str),(void *)(f),(uint64)((flen - (int64)1)));
        str[((flen - (int64)1))] = (uint8)0u;
        return str;
    }
    return f;
}

byte * mlib_addext(byte * s,byte * newext) {
    byte *  sext;
    sext = mlib_extractext(s,(int64)1);
    if (((int64)((*sext)) == (int64)0)) {
        return mlib_changeext(s,newext);
    }
    return s;
}

void * mlib_alloctable(int64 n,int64 size) {
    void *  p;
    p = malloc((uint64)(((n + (int64)1) * size)));
    if (!(!!(p))) {
        mlib_abortprogram((byte*)"Alloctable failure");
    }
    return p;
}

void * mlib_zalloctable(int64 n,int64 size) {
    int64 *  p;
    p = (int64 *)(mlib_alloctable(n,size));
    mlib_pcm_clearmem((void *)(p),((n + (int64)1) * size));
    return (void *)(p);
}

void mlib_checkfreelists(byte * s) {
    int64 i;
    uint64 *  p;
    uint64 *  q;
    int64 aa;
L180:;
    for (i=(int64)2;i<=(int64)2;++i) {
L181:;
        p = mlib_freelist[(i)];
L184:;
        while (!!(p)) {
            aa = (int64)(p);
            if (((aa > (int64)4294967295) || (aa < (int64)100))) {
                printf("%s %s %lld %p %p\n",(char*)(s),(char*)((byte*)"FREE LIST ERROR"),(int64)i,(void*)(p),(void*)(q));
            }
            q = p;
            p = (uint64 *)((*p));
L185:;
        }
L186:;
L182:;
    }
L183:;
}

void * mlib_pcm_alloc32(void) {
    byte *  p;
    int64 i;
    mlib_allocbytes = (int64)32;
    if (!!((p = (byte *)(mlib_freelist[((int64)2)])))) {
        mlib_freelist[((int64)2)] = (uint64 *)((*mlib_freelist[((int64)2)]));
        if (!!((int64)0)) {
            mlib_addtomemalloc((int32 *)(p),(int64)32);
        }
        return (void *)(p);
    }
    return mlib_pcm_alloc((int64)32);
}

void mlib_pcm_free32(void * p) {
    int64 acode;
    if (!!((int64)0)) {
        mlib_removefrommemalloc((int32 *)(p),(int64)32);
    }
    (*(uint64 *)(p)) = (uint64)(mlib_freelist[((int64)2)]);
    mlib_freelist[((int64)2)] = (uint64 *)(p);
}

void mlib_outbyte(void * f,int64 x) {
    fwrite((void *)(&x),(uint64)((int64)1),(uint64)((int64)1),f);
}

void mlib_outword16(void * f,uint64 x) {
    fwrite((void *)(&x),(uint64)((int64)2),(uint64)((int64)1),f);
}

void mlib_outword(void * f,uint64 x) {
    fwrite((void *)(&x),(uint64)((int64)4),(uint64)((int64)1),f);
}

void mlib_outword64(void * f,uint64 x) {
    fwrite((void *)(&x),(uint64)((int64)8),(uint64)((int64)1),f);
}

int64 mlib_myeof(void * f) {
    int64 c;
    c = (int64)(fgetc(f));
    if ((c == (int64)-1)) {
        return (int64)1;
    }
    ungetc((int32)(c),f);
    return (int64)0;
}

void * mlib_pcm_smallallocz(int64 n) {
    byte *  p;
    int64 i;
    if (((mlib_alloccode = (int64)(mlib_sizeindextable[(n)])) == (int64)0)) {
        mlib_alloccode = (int64)1;
    }
    mlib_allocbytes = (int64)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        memset((void *)(p),(int32)0,(uint64)(n));
        return (void *)(p);
    }
    memset((void *)(p),(int32)0,(uint64)(n));
    return (void *)(p);
}

void * mlib_pcm_smallalloc(int64 n) {
    byte *  p;
    int64 i;
    if (((mlib_alloccode = (int64)(mlib_sizeindextable[(n)])) == (int64)0)) {
        mlib_alloccode = (int64)1;
    }
    mlib_allocbytes = (int64)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    }
    return (void *)(p);
}

void mlib_strbuffer_add(struct mlib_strbuffer * dest,byte * s,int64 n) {
    int64 newlen;
    int64 oldlen;
    byte *  newptr;
    if ((n == (int64)-1)) {
        n = (int64)(strlen(s));
    }
    oldlen = (int64)((*dest).length);
    if ((oldlen == (int64)0)) {
        (*dest).strptr = (byte *)(mlib_pcm_alloc((n + (int64)1)));
        (*dest).allocated = (int32)(mlib_allocbytes);
        (*dest).length = (int32)(n);
        memcpy((void *)((*dest).strptr),(void *)(s),(uint64)(n));
        (*((*dest).strptr + n)) = (uint8)0u;
        return;
    }
    newlen = (oldlen + n);
    if (((newlen + (int64)1) > (int64)((*dest).allocated))) {
        newptr = (byte *)(mlib_pcm_alloc((newlen + (int64)1)));
        memcpy((void *)(newptr),(void *)((*dest).strptr),(uint64)(oldlen));
        (*dest).strptr = newptr;
        (*dest).allocated = (int32)(mlib_allocbytes);
    }
    memcpy((void *)(((*dest).strptr + oldlen)),(void *)(s),(uint64)(n));
    (*((*dest).strptr + newlen)) = (uint8)0u;
    (*dest).length = (int32)(newlen);
}

void mlib_gs_init(struct mlib_strbuffer * dest) {
    mlib_pcm_clearmem((void *)(dest),(int64)16);
}

void mlib_gs_free(struct mlib_strbuffer * dest) {
    if (!!((*dest).allocated)) {
        mlib_pcm_free((void *)((*dest).strptr),(int64)((*dest).allocated));
    }
}

void mlib_gs_str(struct mlib_strbuffer * dest,byte * s) {
    mlib_strbuffer_add(dest,s,(int64)-1);
}

void mlib_gs_char(struct mlib_strbuffer * dest,byte c) {
    byte s[16];
    s[((int64)1)-1] = c;
    s[((int64)2)-1] = (uint8)0u;
    mlib_strbuffer_add(dest,s,(int64)-1);
}

void mlib_gs_strn(struct mlib_strbuffer * dest,byte * s,int64 length) {
    mlib_strbuffer_add(dest,s,length);
}

void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s) {
    mlib_strbuffer_add(dest,(*s).strptr,(int64)-1);
}

void mlib_gs_strint(struct mlib_strbuffer * dest,int64 a) {
    byte str[256];
    sprintf(str,(byte*)"%lld",a);
    mlib_strbuffer_add(dest,str,(int64)-1);
}

void mlib_gs_strln(struct mlib_strbuffer * dest,byte * s) {
    mlib_gs_str(dest,s);
    mlib_gs_line(dest);
}

void mlib_gs_strsp(struct mlib_strbuffer * dest,byte * s) {
    mlib_gs_str(dest,s);
    mlib_gs_str(dest,(byte*)" ");
}

void mlib_gs_line(struct mlib_strbuffer * dest) {
    mlib_strbuffer_add(dest,(byte*)"\r\n",(int64)-1);
}

int64 mlib_gs_getcol(struct mlib_strbuffer * dest) {
    return (int64)((*dest).length);
}

void mlib_gs_leftstr(struct mlib_strbuffer * dest,byte * s,int64 w,int64 padch) {
    int64 col;
    int64 i;
    int64 n;
    int64 slen;
    byte str[2560];
    col = (int64)((*dest).length);
    strcpy(str,s);
    slen = (int64)(strlen(s));
    n = (w - slen);
    if ((n > (int64)0)) {
L187:;
        for (i=(int64)1;i<=n;++i) {
L188:;
            str[((slen + i))-1] = (byte)(padch);
L189:;
        }
L190:;
        str[(((slen + n) + (int64)1))-1] = (uint8)0u;
    }
    mlib_gs_str(dest,str);
}

void mlib_gs_leftint(struct mlib_strbuffer * dest,int64 a,int64 w,int64 padch) {
    byte str[256];
    sprintf(str,(byte*)"%d",a);
    mlib_gs_leftstr(dest,str,w,padch);
}

void mlib_gs_padto(struct mlib_strbuffer * dest,int64 col,int64 ch) {
    int64 i;
    int64 n;
    byte str[2560];
    n = (col - (int64)((*dest).length));
    if ((n <= (int64)0)) {
        return;
    }
L191:;
    for (i=(int64)1;i<=n;++i) {
L192:;
        str[(i)-1] = (byte)(ch);
L193:;
    }
L194:;
    str[((n + (int64)1))-1] = (uint8)0u;
    mlib_gs_str(dest,str);
}

void mlib_gs_println(struct mlib_strbuffer * dest,void * f) {
    if ((f == 0)) {
        printf((byte*)"%.*s\r\n",(*dest).length,(*dest).strptr);
    }
    else {
        fprintf(f,(byte*)"%.*s\r\n",(*dest).length,(*dest).strptr);
    }
}

int64 mlib_nextcmdparam(int64 * paramno,byte * * name,byte * * value,byte * defext) {
    static int64 infile = (int64)0;
    static byte *  filestart = 0;
    static byte *  fileptr = 0;
    static byte colonseen = (uint8)0u;
    byte *  q;
    byte *  item;
    byte *  fileext;
    byte *  rest;
    int64 length;
    static byte str[300];
//reenter:
L195:;
    (*value) = (byte *)(0);
    (*name) = (byte *)(0);
    if (!!(infile)) {
        if ((mlib_readnextfileitem(&fileptr,&item) == (int64)0)) {
            free((void *)(filestart));
            infile = (int64)0;
            goto L195;
        }
    }
    else {
        if (((*paramno) > msysc_nsysparams)) {
            return (int64)0;
        }
        item = msysc_sysparams[((*paramno))-1];
        ++(*paramno);
        length = (int64)(strlen(item));
        if (((int64)((*item)) == (int64)64)) {
            filestart = (fileptr = mlib_readfile((item + (int64)1)));
            if ((filestart == 0)) {
                printf("%s %s\n",(char*)((byte*)"Can't open"),(char*)(item));
                exit(0);
            }
            infile = (int64)1;
            goto L195;
        }
        if (((int64)((*item)) == (int64)58)) {
            colonseen = (uint8)1u;
            return (int64)4;
        }
    }
    (*value) = (byte *)(0);
    if (((int64)((*item)) == (int64)45)) {
        (*name) = (item + (!!(colonseen)?(int64)0:(int64)1));
        q = strchr(item,(int32)58);
        if (!(!!(q))) {
            q = strchr(item,(int32)61);
        }
        if (!!(q)) {
            (*value) = (q + (int64)1);
            (*q) = (uint8)0u;
        }
        return (!!(colonseen)?(int64)5:(int64)1);
    }
    fileext = mlib_extractext(item,(int64)0);
    (*name) = item;
    if (((int64)((*fileext)) == (int64)0)    ) {
        strcpy(str,(*name));
        if ((!!(defext) && !(!!(colonseen)))) {
            (*name) = mlib_addext(str,defext);
        }
    }
    else if (!!(mlib_eqstring(fileext,(byte*)"dll"))) {
        return (!!(colonseen)?(int64)5:(int64)3);
    }
    return (!!(colonseen)?(int64)5:(int64)2);
}

static int64 mlib_readnextfileitem(byte * * fileptr,byte * * item) {
    byte *  p;
    byte *  pstart;
    byte *  pend;
    int64 i;
    int64 n;
    static byte str[256];
    p = (*fileptr);
L196:;
    while (1) {
        if (((int64)((*p))==(int64)32) || ((int64)((*p))==(int64)9) || ((int64)((*p))==(int64)13) || ((int64)((*p))==(int64)10)) {
            ++p;
        } else if (((int64)((*p))==(int64)26) || ((int64)((*p))==(int64)0)) {
            return (int64)0;
        }
        else {
            goto L197;
        }
    }
L197:;
    if (((int64)((*p)) == (int64)34)) {
        pstart = ++p;
L198:;
        while (1) {
            if (((int64)((*p))==(int64)0) || ((int64)((*p))==(int64)26)) {
                printf("%s\n",(char*)((byte*)"Unexpected EOF in @file"));
                exit(0);
            } else if (((int64)((*p))==(int64)34)) {
                pend = p++;
                if (((int64)((*p)) == (int64)44)) {
                    ++p;
                }
                goto L199;
            }
            ++p;
        }
L199:;
    }
    else {
        pstart = p;
L200:;
        while (1) {
            if (((int64)((*p))==(int64)0) || ((int64)((*p))==(int64)26)) {
                pend = p;
                goto L201;
            } else if (((int64)((*p))==(int64)32) || ((int64)((*p))==(int64)9) || ((int64)((*p))==(int64)44) || ((int64)((*p))==(int64)13) || ((int64)((*p))==(int64)10)) {
                pend = p++;
                goto L201;
            }
            ++p;
        }
L201:;
    }
    n = (pend - pstart);
    if ((n >= (int64)256)) {
        printf("%s\n",(char*)((byte*)"@file item too long"));
        exit(0);
    }
    memcpy((void *)(str),(void *)(pstart),(uint64)(n));
    str[((n + (int64)1))-1] = (uint8)0u;
    (*item) = str;
    (*fileptr) = p;
    return (int64)1;
}

void mlib_ipadstr(byte * s,int64 width,byte * padchar) {
    int64 n;
    int64 av_1;
    n = (int64)(strlen(s));
    av_1 = (width - n);
    while (av_1-- > 0) {
L202:;
        strcat(s,padchar);
L203:;
    }
L204:;
}

byte * mlib_padstr(byte * s,int64 width,byte * padchar) {
    static byte str[256];
    strcpy(str,s);
    mlib_ipadstr(str,width,padchar);
    return str;
}

byte * mlib_chr(int64 c) {
    static byte str[8];
    str[((int64)1)-1] = (byte)(c);
    str[((int64)2)-1] = (uint8)0u;
    return str;
}

int64 mlib_cmpstring(byte * s,byte * t) {
    int64 res;
    if (((res = (int64)(strcmp(s,t))) < (int64)0)    ) {
        return (int64)-1;
    }
    else if ((res > (int64)0)) {
        return (int64)1;
    }
    else {
        return (int64)0;
    }
}

int64 mlib_cmpstringn(byte * s,byte * t,int64 n) {
    int64 res;
    if (((res = (int64)(strncmp(s,t,(uint64)(n)))) < (int64)0)    ) {
        return (int64)-1;
    }
    else if ((res > (int64)0)) {
        return (int64)1;
    }
    else {
        return (int64)0;
    }
}

int64 mlib_eqstring(byte * s,byte * t) {
    return (int64)(((int64)(strcmp(s,t)) == (int64)0));
}

int64 mlib_cmpbytes(byte * p,byte * q,int64 n) {
    int64 res;
    if (((res = (int64)(memcmp((void *)(p),(void *)(q),(uint64)(n)))) < (int64)0)    ) {
        return (int64)-1;
    }
    else if ((res > (int64)0)) {
        return (int64)1;
    }
    else {
        return (int64)0;
    }
}

int64 mlib_eqbytes(byte * p,byte * q,int64 n) {
    return (int64)(((int64)(memcmp((void *)(p),(void *)(q),(uint64)(n))) == (int64)0));
}

void osnos_os_init(void) {
    osnos_init_flag = (int64)1;
}

int64 osnos_os_execwait(byte * cmdline,int64 newconsole,byte * workdir) {
    return (int64)(system(cmdline));
}

int64 osnos_os_execcmd(byte * cmdline,int64 newconsole) {
    return (int64)(system(cmdline));
}

int64 osnos_os_getch(void) {
    return (int64)0;
}

int64 osnos_os_kbhit(void) {
    mlib_abortprogram((byte*)"kbhit");
    return (int64)0;
}

void osnos_os_flushkeys(void) {
    mlib_abortprogram((byte*)"flushkeys");
}

void * osnos_os_getconsolein(void) {
    return 0;
}

void * osnos_os_getconsoleout(void) {
    return 0;
}

void * osnos_os_proginstance(void) {
    mlib_abortprogram((byte*)"PROGINST");
    return 0;
}

uint64 osnos_os_getdllinst(byte * name) {
    return (uint64)((int64)0);
}

void (*osnos_os_getdllprocaddr(int64 hinst,byte * name))(void) {
    static struct osnos_os_getdllprocaddr_rec table[23] =     {
    {(byte*)"malloc",(void *)(malloc)},
    {(byte*)"realloc",(void *)(realloc)},
    {(byte*)"free",(void *)(free)},
    {(byte*)"printf",(void *)(printf)},
    {(byte*)"puts",(void *)(puts)},
    {(byte*)"fgetc",(void *)(fgetc)},
    {(byte*)"fputc",(void *)(fputc)},
    {(byte*)"getchar",(void *)(getchar)},
    {(byte*)"fopen",(void *)(fopen)},
    {(byte*)"fclose",(void *)(fclose)},
    {(byte*)"fseek",(void *)(fseek)},
    {(byte*)"ftell",(void *)(ftell)},
    {(byte*)"fread",(void *)(fread)},
    {(byte*)"fwrite",(void *)(fwrite)},
    {(byte*)"clock",(void *)(clock)},
    {(byte*)"isalpha",(void *)(isalpha)},
    {(byte*)"tolower",(void *)(tolower)},
    {(byte*)"feof",(void *)(feof)},
    {(byte*)"memset",(void *)(memset)},
    {(byte*)"memcpy",(void *)(memcpy)},
    {(byte*)"ungetc",(void *)(ungetc)},
    {(byte*)"remove",(void *)(remove)},
    {(byte*)"system",(void *)(system)}
};
    int64 i;
    int64 av_1;
L205:;
    for (i=(int64)1;i<=(int64)23;++i) {
L206:;
        if (((int64)(strcmp(table[(i)-1].name,name)) == (int64)0)) {
            return (void (*)(void))(table[(i)-1].addr);
        }
L207:;
    }
L208:;
    return (void (*)(void))(0);
}

void osnos_os_initwindows(void) {
}

int64 osnos_os_getchx(void) {
    mlib_abortprogram((byte*)"getchx");
    return (int64)0;
}

byte * osnos_os_getos(void) {
    return (byte*)"NO-OS";
}

int64 osnos_os_getoscode(void) {
    return (int64)78;
}

int64 osnos_os_iswindows(void) {
    static int64 iswindows = (int64)-1;
    void *  f;
    (int64)123456;
    (int64)1193046;
    return (int64)0;
    if ((iswindows == (int64)-1)) {
        f = fopen((byte*)"c:/windows/notepad.exe",(byte*)"rb");
        if (!!(f)) {
            fclose(f);
            iswindows = (int64)1;
        }
        else {
            iswindows = (int64)0;
        }
    }
    return iswindows;
}

int64 osnos_os_shellexec(byte * opc,byte * file) {
    mlib_abortprogram((byte*)"SHELL EXEC");
    return (int64)0;
}

void osnos_os_sleep(int64 a) {
    mlib_abortprogram((byte*)"sleep");
}

void * osnos_os_getstdin(void) {
    return 0;
}

void * osnos_os_getstdout(void) {
    return 0;
}

byte * osnos_os_gethostname(void) {
    return (byte*)"";
}

int64 osnos_os_gethostsize(void) {
    return (int64)64;
}

byte * osnos_os_getmpath(void) {
    return (byte*)"";
}

void osnos_os_exitprocess(int64 x) {
    exit(0);
}

int64 osnos_os_gettimestamp(void) {
    return (int64)(clock());
}

int64 osnos_os_gettickcount(void) {
    return (int64)(clock());
}

int64 osnos_os_clock(void) {
    if (!!(osnos_os_iswindows())) {
        return (int64)(clock());
    }
    else {
        return ((int64)(clock()) / (int64)1000);
    }
}

int64 osnos_os_getclockspersec(void) {
    return (!!(osnos_os_iswindows())?(int64)1000:(int64)1000000);
}

void osnos_os_setmesshandler(void * addr) {
    mlib_abortprogram((byte*)"SETMESSHANDLER");
}

int64 osnos_os_filelastwritetime(byte * filename) {
    return (int64)0;
}

int64 osnos_os_hpcounter(void) {
    return (int64)1;
}

int64 osnos_os_hpfrequency(void) {
    return (int64)1;
}

void osnos_os_getsystime(void * tm) {
}

void osnos_os_peek(void) {
}

void pc_support_prterror(byte * mess) {
    printf("%s %s\n",(char*)((byte*)"Print error:"),(char*)(mess));
    osnos_os_getch();
    exit((int64)1);
}

int64 pc_support_testelem(byte (*p)[],int64 n) {
    return (!!(((*p)[((n >> (int64)3))] & pc_support_bytemasks[((n & (int64)7))]))?(int64)1:(int64)0);
}

void pc_support_setelem(byte (*p)[],int64 n) {
    (*p)[((n >> (int64)3))] |= pc_support_bytemasks[((n & (int64)7))];
}

void pc_support_pcustype_def(byte * mess,struct pc_decls_varrec * x) {
    int64 t;
    t = (int64)((*x).tag);
    pc_support_showlinenumber();
    printf("%s %s %s %s\n",(char*)((byte*)"USTYPE:Type not supported: "),(char*)(mess),(char*)((byte*)":"),(char*)(pc_decls_ttname[(t)]));
    mlib_abortprogram((byte*)"Stopping");
}

uint64 * pc_support_pcustype(byte * mess,struct pc_decls_varrec * x) {
    pc_decls_err_message = mess;
    pc_decls_err_var1 = (*x);
    pc_decls_err_pcptr = pc_decls_pcptr;
    pc_support_pcustype_def(mess,x);
    return pc_decls_pcptr;
}

uint64 * pc_support_pcustypet(byte * mess,int64 t) {
    static struct pc_decls_varrec v;
    v.tagx = (uint32)(t);
    return pc_support_pcustype(mess,&v);
}

void pc_support_pcmxtypes_def(byte * mess,struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 s;
    int64 t;
    s = (int64)((*x).tag);
    t = (int64)((*y).tag);
    pc_support_showlinenumber();
    printf("%s %s %s %s %s %s\n",(char*)((byte*)"MXTYPES:Mixed Types not supported:/"),(char*)(mess),(char*)((byte*)"/:"),(char*)(pc_decls_ttname[(s)]),(char*)((byte*)":"),(char*)(pc_decls_ttname[(t)]));
    mlib_abortprogram((byte*)"Stopping");
}

uint64 * pc_support_pcmxtypes(byte * mess,struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    pc_decls_err_message = mess;
    pc_decls_err_var1 = (*x);
    pc_decls_err_var2 = (*y);
    pc_decls_err_pcptr = pc_decls_pcptr;
    pc_support_pcmxtypes_def(mess,x,y);
    return pc_decls_pcptr;
}

uint64 * pc_support_pcmxtypestt(byte * mess,int64 s,int64 t) {
    static struct pc_decls_varrec u;
    static struct pc_decls_varrec v;
    u.tagx = (uint32)(s);
    v.tagx = (uint32)(t);
    return pc_support_pcmxtypes(mess,&u,&v);
}

byte * pc_support_gettypename(int64 t) {
    return pc_decls_ttname[(t)];
}

void pc_support_inittypetables(void) {
    int64 i;
    int64 size;
    int64 bitsize;
    int64 av_1;
L209:;
    for (i=(int64)0;i<=(int64)52;++i) {
L210:;
        pc_decls_ttname[(i)] = pc_types_stdtypenames[(i)];
        pc_decls_ttbasetype[(i)] = (int32)(i);
        if ((i==(int64)50) || (i==(int64)51) || (i==(int64)52)) {
            bitsize = (int64)64;
        }
        else {
            bitsize = pc_types_stdtypewidths[(i)];
        }
        switch (bitsize) {
        case 0:;
            break;
        case 1:;
        case 2:;
        case 4:;
            size = (int64)1;
            break;
        default:;
            size = (bitsize / (int64)8);
        }
        pc_decls_ttsize[(i)] = size;
        pc_decls_ttbitwidth[(i)] = (int32)(bitsize);
        pc_decls_ttlower[(i)] = (int32)1;
L211:;
    }
L212:;
    pc_decls_ntypes = (int64)52;
    pc_decls_tttarget[((int64)22)] = (int32)35;
}

uint64 * pc_support_pcerror(byte * mess) {
    pc_support_showlinenumber();
    printf("%s %s\n",(char*)((byte*)"PCERROR:"),(char*)(mess));
    osnos_os_getch();
    exit((int64)1);
    return (uint64 *)(0);
}

void pc_support_vxunimpl(byte * mess) {
    pc_support_showlinenumber();
    printf("%s %s\n",(char*)((byte*)"Unimplemented VX op:"),(char*)(mess));
    osnos_os_getch();
    exit((int64)1);
}

void pc_support_pclunimpl(int64 cmd) {
    pc_support_showlinenumber();
    if ((cmd != (int64)216)) {
        printf("%s %s\n",(char*)((byte*)"Unimplemented cmd:"),(char*)(pq_common_cmdnames[(cmd)]));
    }
    else {
        printf("%s\n",(char*)((byte*)"J-opcode not allowed with -LAB or -FN"));
    }
    mlib_abortprogram((byte*)"Stopping");
}

byte * pc_support_convcstring(byte * svalue,int64 length) {
    static byte strbuffer1[2000];
    static byte strbuffer2[2000];
    static byte strbuffer3[2000];
    static byte strbuffer4[2000];
    static byte strbuffer5[2000];
    static byte strbuffer6[2000];
    static int64 strindex = (int64)0;
    static byte (*table[6])[] = {&strbuffer1,&strbuffer2,&strbuffer3,&strbuffer4,&strbuffer5,&strbuffer6};
    byte (*p)[];
    if ((length >= (int64)2000)) {
        pc_support_pcerror((byte*)"ConvCstring>=2000");
    }
    if ((svalue == 0)) {
        return (byte*)"";
    }
    if ((++strindex == (int64)6)) {
        strindex = (int64)0;
    }
    p = table[(strindex)];
    memcpy((void *)(p),(void *)(svalue),(uint64)(length));
    (*p)[(length)] = (uint8)0u;
    return (byte *)(p);
}

int64 pc_support_getintvalue(struct pc_decls_varrec * p) {
    switch ((int64)((*p).tag)) {
    case 1:;
    case 13:;
        return (*p).value;
        break;
    case 3:;
        return (int64)((*p).xvalue);
        break;
    default:;
        pc_support_pcustype((byte*)"getintvalue",p);
    }
    return (int64)0;
}

int64 pc_support_nextpoweroftwo(int64 x) {
    int64 a = (int64)1;
    if ((x == (int64)0)) {
        return (int64)0;
    }
L213:;
    while ((a < x)) {
        a <<= (int64)1;
L214:;
    }
L215:;
    return a;
}

static void pc_support_showlinenumber(void) {
    int64 lineno;
    int64 moduleno;
    int64 count;
    uint64 *  ptr;
    struct pc_decls_varrec *  s;
    struct pc_decls_varrec *  send;
    pc_support_findlinenumber(pc_decls_pcptr,&lineno,&moduleno);
    pc_support_printlinenumber(lineno,moduleno,(byte*)"");
    s = pc_decls_sptr;
    send = &(*pc_decls_varstack)[((int64)70000)];
    count = (int64)0;
L216:;
    while (((s <= send) && (count < (int64)15))) {
        if (((int64)((*s).tag) == (int64)16)) {
            ptr = ((*s).retaddr - (int64)3);
            pc_support_findlinenumber(ptr,&lineno,&moduleno);
            pc_support_printlinenumber(lineno,moduleno,(byte*)"Called from:");
            ++count;
        }
        ++s;
L217:;
    }
L218:;
}

static void pc_support_printlinenumber(int64 lineno,int64 moduleno,byte * calledfrom) {
    printf("%s %s %lld %s %s\n",(char*)(calledfrom),(char*)((byte*)"LINE:"),(int64)lineno,(char*)((byte*)"in FILE:"),(char*)(pc_decls_moduletable[(moduleno)].filename));
}

void pc_support_findlinenumber(uint64 * ptr,int64 * lineno,int64 * moduleno) {
    int64 pcindex;
    int64 i;
    struct pc_decls_modulerec m;
    (*lineno) = (int64)0;
    pcindex = pc_support_findpcindex(ptr,moduleno);
    if (!!(pcindex)) {
        memcpy(&m,&pc_decls_moduletable[((*moduleno))],110);
L219:;
        for (i=pcindex;i>=(int64)1;--i) {
L220:;
            (*lineno) = (int64)((*m.linetable)[(i)]);
            if (!!((*lineno))) {
                return;
            }
L221:;
        }
L222:;
    }
}

int64 pc_support_findpcindex(uint64 * ptr,int64 * moduleno) {
    int64 i;
    int64 j;
    uint64 *  p;
    uint64 *  q;
L223:;
    for (i=(int64)0;i<=pc_decls_nmodules;++i) {
L224:;
        p = (uint64 *)(pc_decls_moduletable[(i)].pccode);
        q = (p + (int64)(pc_decls_moduletable[(i)].pcindex));
        if (((ptr >= p) && (ptr < q))) {
            (*moduleno) = i;
            return ((ptr - p) + (int64)1);
        }
L225:;
    }
L226:;
    return (int64)0;
}

void pc_support_showlinetable(byte * caption,int64 i) {
    int64 j;
    printf("%s %lld %d %s\n",(char*)((byte*)"MODULE"),(int64)i,pc_decls_moduletable[(i)].pcindex,(char*)(caption));
L227:;
    for (j=(int64)7;j<=(int64)12;++j) {
L228:;
        printf("%s %lld %u\n",(char*)((byte*)"\tLINE"),(int64)j,(*pc_decls_moduletable[(i)].linetable)[(j)]);
L229:;
    }
L230:;
}

void pc_support_writezstring(void * f,byte * s) {
    int64 i;
    int64 n;
    int64 av_1;
    mlib_outbyte(f,(int64)254);
    n = (int64)(strlen(s));
    av_1 = n;
    while (av_1-- > 0) {
L231:;
        mlib_outbyte(f,(int64)((*s++)));
L232:;
    }
L233:;
    mlib_outbyte(f,(int64)0);
}

void pc_support_writezint(void * f,int64 x) {
    byte *  p;
    int64 av_1;
    if (((x >= (int64)0) && (x <= (int64)239))    ) {
        mlib_outbyte(f,x);
    }
    else if (((x >= (int64)240) && (x < (int64)480))) {
        mlib_outbyte(f,(int64)245);
        mlib_outbyte(f,(x - (int64)240));
    }
    else if (((x >= (int64)480) && (x < (int64)720))) {
        mlib_outbyte(f,(int64)246);
        mlib_outbyte(f,(x - (int64)480));
    }
    else if (((x >= (int64)720) && (x < (int64)960))) {
        mlib_outbyte(f,(int64)247);
        mlib_outbyte(f,(x - (int64)720));
    }
    else if (((x >= (int64)-127) && (x < (int64)0))) {
        mlib_outbyte(f,(int64)248);
        mlib_outbyte(f,-(x));
    }
    else if (((x >= (int64)-32768) && (x <= (int64)32767))) {
        mlib_outbyte(f,(int64)249);
        mlib_outword16(f,(uint64)(x));
    }
    else if (((x > (int64)-2147483648) && (x <= (int64)2147483647))) {
        mlib_outbyte(f,(int64)250);
        mlib_outword(f,(uint64)(x));
    }
    else {
        p = (byte *)(&x);
        mlib_outbyte(f,(int64)251);
        av_1 = (int64)8;
        while (av_1-- > 0) {
L234:;
            mlib_outbyte(f,(int64)((*p++)));
L235:;
        }
L236:;
    }
}

void pc_support_writezint4(void * f,int64 x) {
    mlib_outbyte(f,(int64)250);
    mlib_outword(f,(uint64)(x));
}

void pc_support_writezrange(void * f,byte * p) {
    int64 av_1;
    mlib_outbyte(f,(int64)251);
    av_1 = (int64)8;
    while (av_1-- > 0) {
L237:;
        mlib_outbyte(f,(int64)((*p++)));
L238:;
    }
L239:;
}

void pc_support_writezreal(void * f,double x) {
    byte *  p;
    int64 *  q;
    int64 av_1;
    int64 av_2;
    p = (byte *)(&x);
    q = (int64 *)(&x);
    if ((q != 0)) {
        mlib_outbyte(f,(int64)253);
        av_1 = (int64)8;
        while (av_1-- > 0) {
L240:;
            mlib_outbyte(f,(int64)((*p++)));
L241:;
        }
L242:;
    }
    else {
        mlib_outbyte(f,(int64)252);
        p += (int64)4;
        av_2 = (int64)4;
        while (av_2-- > 0) {
L243:;
            mlib_outbyte(f,(int64)((*p++)));
L244:;
        }
L245:;
    }
}

void pc_support_writezeof(void * f) {
    mlib_outbyte(f,(int64)255);
}

static void pc_support_zerror(byte * mess) {
    printf("%s %s\n",(char*)((byte*)"Z error:"),(char*)(mess));
    exit((int64)1);
}

int64 pc_support_readzvalue(byte * * pp,int32 * dest,int32 * dest2) {
    byte *  p;
    int8 *  sp;
    int64 *  destint;
    double *  destreal;
    void * *  destptr;
    int64 t;
    byte bb;
    byte c;
    int32 length;
    int32 dummy;
    p = (*pp);
    bb = (*p++);
    t = (int64)1;
    if ((dest2 == 0)) {
        dest2 = &dummy;
    }
    switch ((int64)(bb)) {
    case 245:;
        (*dest) = (int32)(((int64)((*p++)) + (int64)240));
        break;
    case 246:;
        (*dest) = (int32)(((int64)((*p++)) + (int64)480));
        break;
    case 247:;
        (*dest) = (int32)(((int64)((*p++)) + (int64)720));
        break;
    case 248:;
        (*dest) = (int32)(-((*(int8 *)(p))));
        ++p;
        break;
    case 249:;
        (*dest) = (int32)((*(int16 *)(p)));
        p += (int64)2;
        break;
    case 250:;
        (*dest) = (*(int32 *)(p));
        p += (int64)4;
        break;
    case 251:;
        destint = (int64 *)(dest);
        (*destint) = (*(int64 *)(p));
        p += (int64)8;
        t = (int64)2;
        break;
    case 252:;
        (*dest++) = (int32)0;
        (*dest) = (*(int32 *)(p));
        p += (int64)4;
        t = (int64)3;
        break;
    case 253:;
        destint = (int64 *)(dest);
        (*destint) = (*(int64 *)(p));
        p += (int64)8;
        t = (int64)3;
        break;
    case 254:;
        destptr = (void * *)(dest);
        (*destptr) = (void *)((uint64)(p));
        length = (int32)0;
L246:;
        do {
            c = (*p++);
            ++length;
L247:;
        } while (!!(!!(c)));;
L248:;
        (*dest2) = --length;
        t = (int64)4;
        break;
    case 244:;
        pc_support_zerror((byte*)"Can't deal with ZBYTES yet");
        exit((int64)1);
        break;
    case 255:;
        return (int64)0;
        break;
    default:;
        (*dest) = (int32)(bb);
    }
    (*pp) = p;
    return t;
}

int64 pc_support_readzint(byte * * p) {
    int64 aa;
    int64 status;
    aa = (int64)0;
    status = pc_support_readzvalue(p,(int32 *)(&aa),(int32 *)(0));
    if ((status==(int64)1)) {
        if (((int64)((int32)(aa)) < (int64)0)) {
            aa |= (int64)((uint64)18446744069414584320u);
        }
    } else if ((status==(int64)2)) {
    }
    else {
        pc_support_zerror((byte*)"Z:Int32 Expected");
    }
    return aa;
}

int64 pc_support_readzdint(byte * * p) {
    int64 aa;
    int64 status;
    aa = (int64)0;
    if (((status = pc_support_readzvalue(p,(int32 *)(&aa),(int32 *)(0))) != (int64)2)) {
        if ((status == (int64)1)) {
            if ((aa > (int64)2147483647)) {
                aa |= (int64)((uint64)18446744071562067968u);
            }
        }
        else {
            pc_support_zerror((byte*)"ZformatD");
        }
    }
    return aa;
}

double pc_support_readzreal(byte * * p) {
    double x;
    int64 status;
    if (((status = pc_support_readzvalue(p,(int32 *)(&x),(int32 *)(0))) != (int64)3)) {
        pc_support_zerror((byte*)"ZformatR");
    }
    return x;
}

byte * pc_support_readzstring(byte * * p,int64 * ilength) {
    int64 aa;
    int32 length;
    int32 status;
    if (((int64)((status = (int32)(pc_support_readzvalue(p,(int32 *)(&aa),&length)))) != (int64)4)) {
        printf("%s %d\n",(char*)((byte*)"STATUS="),status);
        pc_support_zerror((byte*)"ZformatS");
    }
    if (!!(ilength)) {
        (*ilength) = (int64)(length);
    }
    return (byte *)(aa);
}

byte * pc_support_readzblock(byte * * pp,int64 length) {
    byte *  pdata;
    pdata = (*pp);
    (*pp) = (pdata + length);
    return pdata;
}

void pc_support_checkmt(int64 id) {
    printf("%s %lld %s %p\n",(char*)((byte*)"CHECKMT"),(int64)id,(char*)((byte*)":"),(void*)(pc_decls_moduletable[((int64)1)].pccode));
}

int64 pc_support_ipower(int64 a,int64 n) {
    if ((n <= (int64)0)    ) {
        return (int64)0;
    }
    else if ((n == (int64)0)) {
        return (int64)1;
    }
    else if ((n == (int64)1)) {
        return a;
    }
    else if (((n & (int64)1) == (int64)0)) {
        return pc_support_ipower((a * a),(n / (int64)2));
    }
    else {
        return (a * pc_support_ipower((a * a),((n - (int64)1) / (int64)2)));
    }
}

void pc_support_loaderror(byte * mess,byte * mess2) {
    printf("%s %s %s\n",(char*)((byte*)"Load Error:"),(char*)(mess),(char*)(mess2));
    exit((int64)1);
}

int64 pc_support_gettypesig(int64 s,int64 t) {
    int64 typesig;
    typesig = (int64)(pc_decls_sigmap[(s)][(t)]);
    if ((typesig == (int64)0)) {
        typesig = ++pc_decls_nexttypesig;
        pc_decls_sigmap[(s)][(t)] = (byte)(typesig);
    }
    return typesig;
}

byte * pc_support_getfnname(void * fnaddr) {
    int64 i;
    int64 n;
    n = msysc_m_getnprocs();
L249:;
    for (i=(int64)1;i<=n;++i) {
L250:;
        if ((msysc_m_getprocaddr(i) == fnaddr)) {
            return msysc_m_getprocname(i);
        }
L251:;
    }
L252:;
    return (byte*)"<FUNCTION NOT FOUND>";
}

void pc_support_junimpl(byte * s) {
    byte mess[100];
    strcpy(mess,(byte*)"J handler unimpl: ");
    strcat(mess,s);
    pc_support_pcerror(mess);
}

uint64 * pc_misc_raiseexception(int64 exceptno) {
    struct pc_decls_varrec *  stackend;
    struct pc_decls_varrec *  oldsptr;
    stackend = &(*pc_decls_varstack)[((int64)70000)];
    oldsptr = pc_decls_sptr;
L253:;
    while (1) {
        if ((pc_decls_sptr >= stackend)) {
            pc_decls_sptr = oldsptr;
            pc_misc_default_exception(exceptno);
        }
        if ((((int64)((*pc_decls_sptr).tag) == (int64)17) && ((exceptno == (int64)0) || ((int64)((*pc_decls_sptr).exceptiontype) == exceptno)))) {
            goto L254;
        }
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        ++pc_decls_sptr;
    }
L254:;
    pc_decls_frameptr = ((byte *)(pc_decls_sptr) + (int64)((*pc_decls_sptr).frameoffset));
    return (uint64 *)((*pc_decls_sptr).refptr);
}

void pc_misc_raise_error(int64 error_no) {
    (*--pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = error_no;
    pc_decls_err_pcptr = pc_decls_pcptr;
    pc_decls_pcptr = pc_decls_raiseseq;
}

static void pc_misc_default_exception(int64 exceptno) {
    printf("%s\n",(char*)((byte*)"DEFAULT EXCEPTION HANDLER"));
    if ((exceptno==(int64)1)) {
        pc_support_pcerror((byte*)"PC/ERROR");
    } else if ((exceptno==(int64)2)) {
        pc_support_pcerror((byte*)"USER/ERROR");
    } else if ((exceptno==(int64)3)) {
        pc_decls_pcptr = pc_decls_err_pcptr;
        pc_support_pcustype_def(pc_decls_err_message,&pc_decls_err_var1);
    } else if ((exceptno==(int64)4)) {
        pc_decls_pcptr = pc_decls_err_pcptr;
        pc_support_pcmxtypes_def(pc_decls_err_message,&pc_decls_err_var1,&pc_decls_err_var2);
    } else if ((exceptno==(int64)5)) {
        pc_decls_pcptr = pc_decls_err_pcptr;
        pc_support_pcerror((byte*)"EXCEPTION/DIVIDE BY ZERO");
    } else if ((exceptno==(int64)6)) {
        printf("%s\n",(char*)((byte*)"STOPMODULEERROR"));
    } else if ((exceptno==(int64)7)) {
        printf("%s\n",(char*)((byte*)"BOUNDSERROR"));
    }
    else {
        printf("%s %s\n",(char*)((byte*)"Exception:"),(char*)(pq_common_errornames[(exceptno)-1]));
    }
    exit((int64)1);
}

void pc_pcfns_pc_ufree(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  pa;
    int64 tag;
    pa = (*p).objptr;
    if (((int64)((*pa).refcount) <= (int64)0)) {
        printf("%s %s %u\n",(char*)((byte*)"TTNAME[P^.TAG]="),(char*)(pc_decls_ttname[((int64)((*p).tag))]),(*pa).length);
        printf("%s %p %u\n",(char*)((byte*)"PA="),(void*)(pa),(*pa).refcount);
        pc_support_pcerror((byte*)"FREE:BAD REF COUNT");
    }
    if (((int64)(--(*pa).refcount) == (int64)0)) {
        switch ((int64)((*pa).objtype)) {
        case 0:;
            tag = (int64)((*p).tag);
            (*p).tag = (uint16)0u;
            ((*pc_decls_free_table[(tag)]))(p);
            break;
        case 1:;
            pc_pcfns_pc_freeref((*pa).objptr2,(int64)((*p).tag));
            pc_objects_freeobject(pa);
            break;
        default:;
            pc_objects_freeobject(pa);
        }
    }
}

void pc_pcfns_pc_cfree(struct pc_decls_varrec * p) {
    if (!!((*p).hasref)) {
        pc_pcfns_pc_ufree(p);
    }
}

void pc_pcfns_pc_ufreex(struct pc_decls_varrec * p) {
    int64 tag;
    struct pc_decls_objrec *  pa;
    pa = (*p).objptr;
    switch ((int64)((*pa).objtype)) {
    case 0:;
        tag = (int64)((*p).tag);
        (*p).tag = (uint16)0u;
        ((*pc_decls_free_table[(tag)]))(p);
        break;
    case 1:;
        pc_pcfns_pc_freeref((*pa).objptr2,(int64)((*p).tag));
        pc_objects_freeobject(pa);
        break;
    default:;
        pc_objects_freeobject(pa);
    }
}

void pc_pcfns_pc_freeref(struct pc_decls_objrec * p,int64 tag) {
    struct pc_decls_varrec v;
    if (((int64)(--(*p).refcount) == (int64)0)) {
        v.tagx = (uint32)(tag);
        v.objptr = p;
        ((*pc_decls_free_table[(tag)]))(&v);
    }
}

void pc_pcfns_pc_cshare(struct pc_decls_varrec * p) {
    if (!!((*p).hasref)) {
        ++(*(*p).objptr).refcount;
    }
}

void pc_pcfns_pc_ushare(struct pc_decls_varrec * p) {
    ++(*(*p).objptr).refcount;
}

void pc_pcfns_pc_dupl(struct pc_decls_varrec * p) {
    struct pc_decls_varrec v;
    if (!!((*p).hasref)) {
        v = (*p);
        ((*pc_decls_dupl_table[((int64)(v.tag))]))(p);
        pc_pcfns_pc_ufree(&v);
    }
}

void pc_pcfns_j_free_s(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  q;
    q = (*p).objptr;
    if (!!((*q).length)) {
        mlib_pcm_free((void *)((*q).strptr),(int64)((*q).allocated));
    }
    pc_objects_freeobject(q);
}

void pc_pcfns_j_free_l_m_d(struct pc_decls_varrec * p) {
    int64 i;
    int64 n;
    struct pc_decls_objrec *  r;
    struct pc_decls_varrec *  q;
    int64 av_1;
    r = (*p).objptr;
    n = (int64)((*r).length);
    q = (*r).vptr;
    av_1 = n;
    while (av_1-- > 0) {
L255:;
        if (!!((*q).hasref)) {
            pc_pcfns_pc_ufree(q);
        }
        ++q;
L256:;
    }
L257:;
    if (!!(n)) {
        pc_objects_free_listdata((*r).vptr,(int64)((*r).allocated));
    }
    pc_objects_freeobject(r);
}

void pc_pcfns_j_free_k(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  r;
    struct pc_decls_varrec *  q;
    r = (*p).objptr;
    pc_objects_free_arraydata((*r).vptr,(int64)44,(int64)((*r).allocated));
    pc_objects_freeobject(r);
}

void pc_pcfns_j_free_a_j(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  r;
    struct pc_decls_varrec *  q;
    r = (*p).objptr;
    pc_objects_free_arraydata((*r).vptr,(int64)((*r).elemtag),(int64)((*r).allocated));
    pc_objects_freeobject(r);
}

void pc_pcfns_j_free_b_e(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  r;
    struct pc_decls_varrec *  q;
    r = (*p).objptr;
    pc_objects_free_bitdata((*r).ptr,(int64)((*r).elemtag),(int64)((*r).allocated64));
    pc_objects_freeobject(r);
}

void pc_pcfns_j_dupl_s(struct pc_decls_varrec * p) {
    int64 n;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  newp;
    pa = (*p).objptr;
    pc_pcfns_pc_makestring((*pa).strptr,(int64)((*pa).length),p);
}

void pc_pcfns_j_dupl_l_m_d(struct pc_decls_varrec * p) {
    int64 i;
    int64 j;
    int64 n;
    int64 nbytes;
    struct pc_decls_varrec *  q;
    struct pc_decls_varrec *  r;
    struct pc_decls_varrec *  e;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    int64 av_1;
    oldp = (*p).objptr;
    if (((int64)((*oldp).refcount) < (int64)0)) {
        printf("%s\n",(char*)((byte*)"CIRC"));
        pc_support_pcerror((byte*)"DUPL/LIST CIRC");
        return;
    }
    n = (int64)((*oldp).length);
    newp = pc_objects_make_listobj(n,(int64)((*oldp).lower));
    (*p).objptr = newp;
    (*oldp).refcount = -((*oldp).refcount);
    if (!!(n)) {
        r = (*newp).vptr;
        mlib_pcm_copymem4((void *)(r),(void *)((*oldp).vptr),(n * (int64)16));
        av_1 = n;
        while (av_1-- > 0) {
L258:;
            if (!!((*r).hasref)) {
                if (((int64)(pc_decls_ttbasetype[((int64)((*r).tag))]) != (int64)32)) {
                    ++(*(*r).objptr).refcount;
                    pc_pcfns_pc_dupl(r);
                }
                else {
                    ++(*(*r).objptr).refcount;
                }
            }
            ++r;
L259:;
        }
L260:;
    }
    (*oldp).refcount = -((*oldp).refcount);
}

void pc_pcfns_j_dupl_a_j(struct pc_decls_varrec * p) {
    int64 i;
    int64 j;
    int64 n;
    int64 nbytes;
    struct pc_decls_varrec *  q;
    struct pc_decls_varrec *  r;
    struct pc_decls_varrec *  e;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    oldp = (*p).objptr;
    n = (int64)((*oldp).length);
    newp = pc_objects_make_arrayobj(n,(int64)((*oldp).elemtag),(int64)((*oldp).lower));
    (*p).objptr = newp;
    if (!!(n)) {
        mlib_pcm_copymem4((void *)((*newp).ptr),(void *)((*oldp).ptr),(n * pc_decls_ttsize[((int64)((*oldp).elemtag))]));
    }
}

void pc_pcfns_j_dupl_b(struct pc_decls_varrec * p) {
    int64 i;
    int64 j;
    int64 n;
    int64 nbytes;
    struct pc_decls_varrec *  q;
    struct pc_decls_varrec *  r;
    struct pc_decls_varrec *  e;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    oldp = (*p).objptr;
    n = (int64)((*oldp).length);
    newp = pc_objects_make_bitsobj(n,(int64)((*oldp).elemtag),(int64)((*oldp).lower));
    (*p).objptr = newp;
    if (!!(n)) {
        mlib_pcm_copymem4((void *)((*newp).ptr),(void *)((*oldp).ptr),pc_objects_get_objbytes(oldp));
    }
}

void pc_pcfns_j_dupl_e(struct pc_decls_varrec * p) {
    int64 i;
    int64 j;
    int64 nbytes;
    int64 n;
    struct pc_decls_varrec *  q;
    struct pc_decls_varrec *  r;
    struct pc_decls_varrec *  e;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    oldp = (*p).objptr;
    n = (int64)((*oldp).allocated64);
    newp = pc_objects_make_bitsobj((int64)((*oldp).length),(int64)41,(int64)((*oldp).lower));
    (*newp).length = (*oldp).length;
    (*p).objptr = newp;
    if (!!(n)) {
        mlib_pcm_copymem4((void *)((*newp).ptr),(void *)((*oldp).ptr),pc_objects_get_objbytes(oldp));
    }
}

void pc_pcfns_j_dupl_k(struct pc_decls_varrec * p) {
    int64 i;
    int64 j;
    int64 n;
    int64 nbytes;
    struct pc_decls_objrec *  oldp;
    struct pc_decls_objrec *  newp;
    oldp = (*p).objptr;
    nbytes = pc_decls_ttsize[((int64)((*p).tag))];
    newp = pc_objects_make_arrayobj(nbytes,(int64)44,(int64)1);
    (*newp).length = (*oldp).length;
    (*p).objptr = newp;
    mlib_pcm_copymem4((void *)((*newp).ptr),(void *)((*oldp).ptr),nbytes);
}

void pc_pcfns_pc_makelist(int64 n,struct pc_decls_varrec * a,struct pc_decls_varrec * b,int64 lower) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    int64 i;
    struct pc_decls_objrec *  l;
    int64 av_1;
    a += (n - (int64)1);
    l = pc_objects_make_listobj(n,lower);
    (*l).mutable = (uint8)0u;
    v.tagx = (uint32)(((int64)29 | (int64)65536));
    v.objptr = l;
    p = (*l).vptr;
    q = ((p + (int64)((*l).allocated)) - (int64)1);
    av_1 = n;
    while (av_1-- > 0) {
L261:;
        (*p) = (*a--);
        if (!!((*p).hasref)) {
            pc_pcfns_pc_ushare(p);
        }
        ++p;
L262:;
    }
L263:;
L264:;
    while ((p <= q)) {
        (*p).tagx = (uint32)0u;
        ++p;
L265:;
    }
L266:;
    (*b) = v;
}

void pc_pcfns_pc_makerecord(int64 n,int64 t,struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    int64 i;
    struct pc_decls_objrec *  r;
    int64 av_1;
    if (!!(mlib_fdebug)) {
        printf("%s\n",(char*)((byte*)"MAKERECORD"));
    }
    a += (n - (int64)1);
    r = pc_objects_newobject();
    p = ((*r).vptr = pc_objects_make_listdata(n,&(*r).allocated,(int64)0));
    (*r).length = (uint32)(n);
    (*r).lower = (int32)1;
    (*r).mutable = (uint8)1u;
    v.tagx = (uint32)((t | (int64)65536));
    v.objptr = r;
    av_1 = n;
    while (av_1-- > 0) {
L267:;
        (*p) = (*a--);
        if (!!((*p).hasref)) {
            pc_pcfns_pc_ushare(p);
        }
        ++p;
L268:;
    }
L269:;
    (*b) = v;
}

void pc_pcfns_pc_makearray(int64 n,int64 arraytype,int64 elemtype,int64 lower,struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    struct pc_decls_varrec v;
    byte *  p;
    byte *  q;
    int64 i;
    int64 esize;
    int64 nbytes;
    int64 basetag;
    struct pc_decls_objrec *  l;
    int64 av_1;
    a += (n - (int64)1);
    if ((elemtype == (int64)0)) {
        elemtype = (int64)((*a).tag);
        basetag = (int64)(pc_decls_ttbasetype[(elemtype)]);
        if ((basetag==(int64)30) || (basetag==(int64)33)) {
        }
        else {
            if ((basetag > (int64)35)) {
            }
            else {
                pc_support_pcerror((byte*)"makearray elem");
            }
        }
    }
    l = pc_objects_make_arrayobj(n,elemtype,lower);
    v.tagx = (uint32)((arraytype | (int64)65536));
    v.objptr = l;
    p = (*l).ptr;
    esize = pc_decls_ttsize[(elemtype)];
    av_1 = n;
    while (av_1-- > 0) {
L270:;
        pc_pcfns_pc_storepacked(p,a,elemtype);
        p += esize;
        --a;
L271:;
    }
L272:;
    (*b) = v;
}

void pc_pcfns_pc_makerange(struct pc_decls_varrec * x,struct pc_decls_varrec * y,struct pc_decls_varrec * z) {
    if ((((int64)((*x).tag) == (int64)1) && ((int64)((*y).tag) == (int64)1))) {
        (*z).tagx = (uint32)4u;
        (*z).range_upper = (int32)((*y).value);
        (*z).range_lower = (int32)((*x).value);
    }
    else {
        pc_support_pcmxtypes((byte*)"vxmakerange",x,y);
    }
}

void pc_pcfns_pc_makeset(int64 n,struct pc_decls_varrec * data,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec l;
    struct pc_decls_varrec *  q;
    byte *  p;
    int64 top;
    int64 a;
    int64 b;
    int64 i;
    int64 j;
    int64 t;
    int64 size;
    byte alloc;
    struct pc_decls_objrec *  s;
    static int64 count = (int64)0;
    int64 av_1;
    int64 av_2;
    if (!!(mlib_fdebug)) {
        printf("%s %s %lld %lld\n",(char*)((byte*)"MAKESET"),(char*)((byte*)"FDEBUG="),(int64)mlib_fdebug,(int64)++count);
        pc_support_pcerror((byte*)"XXX");
    }
    top = (int64)0;
    q = data;
    av_1 = n;
    while (av_1-- > 0) {
L273:;
        switch ((int64)((*q).tag)) {
        case 4:;
            a = (int64)((*q).range_lower);
            b = (int64)((*q).range_upper);
            break;
        case 1:;
            a = (*q).value;
            b = a;
            break;
        default:;
            b = (a = pc_support_getintvalue(q));
        }
        if (((a < (int64)0) || (b < (int64)0))) {
            pc_support_pcerror((byte*)"Neg set element");
        }
        if ((a > top)) {
            top = a;
        }
        if ((b > top)) {
            top = b;
        }
        ++q;
L274:;
    }
L275:;
    s = pc_objects_make_setobj((top + (int64)1));
    l.tagx = (uint32)(((int64)9 | (int64)65536));
    l.objptr = s;
    q = data;
    av_2 = n;
    while (av_2-- > 0) {
L276:;
        switch ((int64)((*q).tag)) {
        case 4:;
            a = (int64)((*q).range_lower);
            b = (int64)((*q).range_upper);
            if ((a > b)) {
                t = a;
                a = b;
                b = t;
            }
            break;
        case 1:;
            b = (a = (*q).value);
            break;
        default:;
            b = (a = pc_support_getintvalue(q));
        }
L279:;
        for (j=a;j<=b;++j) {
L280:;
            pc_support_setelem((byte (*)[])((*s).ptr),j);
L281:;
        }
L282:;
        ++q;
L277:;
    }
L278:;
    (*dest) = l;
}

void pc_pcfns_pc_makestruct(int64 n,int64 t,struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    struct pc_decls_varrec v;
    byte *  p;
    byte *  q;
    int64 i;
    int64 nfields;
    int64 index;
    struct pc_decls_objrec *  l;
    struct pc_decls_strec *  d;
    struct pc_decls_strec *  f;
    if (!!(mlib_fdebug)) {
        printf("%s\n",(char*)((byte*)"MAKESTRUCT"));
    }
    l = pc_objects_make_arrayobj(pc_decls_ttsize[(t)],(int64)44,(int64)1);
    v.tagx = (uint32)((t | (int64)65536));
    v.objptr = l;
    p = (*l).ptr;
    if (!(!!(pc_decls_runfrompc))) {
        d = pc_decls_ttnamedef[(t)];
        nfields = (int64)0;
        f = (*d).deflist;
L283:;
        while (!!(f)) {
            if ((((int64)((*f).nameid) == (int64)13) && !(!!((*f).ax_at)))) {
                ++nfields;
                if ((nfields > n)) {
                    pc_support_pcerror((byte*)"Too few struct fields");
                }
                pc_pcfns_pc_storepacked((p + (int64)((*f).offset)),a,(int64)((*f).mode));
                ++a;
            }
            f = (*f).nextdef;
L284:;
        }
L285:;
    }
    else {
        index = (int64)(pc_decls_ttstartfield[(t)]);
        nfields = (int64)(pc_decls_ttstructfields[(t)]);
        if ((nfields != n)) {
            pc_support_pcerror((byte*)"makestruct: wrong # fields");
        }
L286:;
        for (i=nfields;i>=(int64)1;--i) {
L287:;
            pc_pcfns_pc_storepacked((p + (int64)((*pc_decls_pcfieldtable)[(((index + i) - (int64)1))-1].fieldoffset)),a,(int64)((*pc_decls_pcfieldtable)[(((index + i) - (int64)1))-1].fieldtype));
            ++a;
L288:;
        }
L289:;
    }
    (*b) = v;
}

void pc_pcfns_pc_makedict(int64 n,struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    int64 i;
    int64 m;
    struct pc_decls_objrec *  l;
    int64 av_1;
    m = (n * (int64)2);
    a += (m - (int64)1);
    l = pc_objects_make_listobj(msysc_m_imax((int64)16,pc_support_nextpoweroftwo(m)),(int64)1);
    v.tagx = (uint32)(((int64)10 | (int64)65536));
    v.objptr = l;
    p = (*l).vptr;
    q = ((p + (int64)((*l).allocated)) - (int64)1);
    av_1 = n;
    while (av_1-- > 0) {
L290:;
        pc_pcfns_adddictitem(&v,a,(a - (int64)1));
        a -= (int64)2;
L291:;
    }
L292:;
    (*b) = v;
}

void pc_pcfns_pc_storepacked(byte * p,struct pc_decls_varrec * q,int64 t) {
    int64 plength;
    int64 qlength;
    int64 s;
    int64 sbase;
    int64 tbase;
    struct pc_decls_objrec *  qa;
    sbase = (int64)(pc_decls_ttbasetype[((s = (int64)((*q).tag)))]);
    tbase = (int64)(pc_decls_ttbasetype[(t)]);
    switch (sbase) {
    case 1:;
    case 2:;
        switch (tbase) {
        case 37:;
        case 44:;
            (*p) = (byte)((*q).value);
            return;
            break;
        case 38:;
        case 45:;
            (*(uint16 *)(p)) = (uint16)((*q).value);
            return;
            break;
        case 39:;
        case 46:;
            (*(int32 *)(p)) = (int32)((*q).value);
            return;
            break;
        case 40:;
        case 47:;
        case 1:;
        case 2:;
            (*(int64 *)(p)) = (*q).value;
            return;
            break;
        case 48:;
            (*(float *)(p)) = (float)((*q).value);
            return;
            break;
        case 49:;
            (*(double *)(p)) = (double)((*q).value);
            return;
            break;
        default:;
        }
        break;
    case 3:;
        switch (tbase) {
        case 39:;
        case 46:;
            (*(int32 *)(p)) = (int32)((*q).xvalue);
            return;
            break;
        case 48:;
            (*(float *)(p)) = (float)((*q).xvalue);
            return;
            break;
        case 49:;
            (*(double *)(p)) = (*q).xvalue;
            return;
            break;
        case 38:;
        case 45:;
            (*(int16 *)(p)) = (int16)((*q).xvalue);
            return;
            break;
        default:;
        }
        break;
    case 5:;
        qa = (*q).objptr;
        plength = (int64)(pc_decls_ttlength[(t)]);
        qlength = (int64)((*qa).length);
        switch (tbase) {
        case 5:;
            if ((t == tbase)) {
                if ((qlength != (int64)1)) {
                    pc_support_pcerror((byte*)"Str not len 1");
                }
                (*p) = (*(*qa).strptr);
                return;
            }
            if ((qlength > plength)) {
                qlength = plength;
            }
            memcpy((void *)(p),(void *)((*qa).strptr),(uint64)(qlength));
            pc_pcfns_setfslength(p,plength,qlength);
            return;
            break;
        case 21:;
            if ((qlength >= plength)) {
                memcpy((void *)(p),(void *)((*qa).strptr),(uint64)(plength));
            }
            else {
                memcpy((void *)(p),(void *)((*qa).strptr),(uint64)(qlength));
                (*(p + qlength)) = (uint8)0u;
            }
            return;
            break;
        default:;
        }
        break;
    case 33:;
        if ((s != t)) {
            pc_support_pcmxtypestt((byte*)"spack struct",s,t);
        }
        memcpy((void *)(p),(void *)((*(*q).objptr).ptr),(uint64)(pc_decls_ttsize[(t)]));
        return;
        break;
    case 30:;
        if ((s != t)) {
            pc_support_pcmxtypestt((byte*)"spack array",s,t);
        }
        memcpy((void *)(p),(void *)((*(*q).objptr).ptr),(uint64)(pc_decls_ttsize[(t)]));
        return;
        break;
    default:;
    }
    pc_support_pcmxtypestt((byte*)"storepacked (source->dest)",s,t);
}

static void pc_pcfns_adddictitem(struct pc_decls_varrec * d,struct pc_decls_varrec * p,struct pc_decls_varrec * q) {
    struct pc_decls_objrec *  da;
    struct pc_decls_varrec *  r;
    da = (*d).objptr;
    if (((int64)((*da).length) == (int64)0)) {
        pc_support_pcerror((byte*)"NULL DICT");
    }
    r = pc_pcfns_finddictitem(da,p,(int64)1);
    if (!!((*r).hasref)) {
        pc_pcfns_pc_ufree(r);
    }
    (*r) = (*q);
    if (!!((*r).hasref)) {
        pc_pcfns_pc_ushare(r);
    }
}

struct pc_decls_varrec * pc_pcfns_finddictitem(struct pc_decls_objrec * d,struct pc_decls_varrec * p,int64 doins) {
    int64 hash;
    int64 index;
    int64 size;
    int64 keytag;
    int64 wrapped;
    int64 limit;
    int64 keyvalue;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  qa;
//retry:
L293:;
    size = ((int64)((*d).length) / (int64)2);
    index = (pc_pcfns_gethashvalue(p) & (size - (int64)1));
    q = ((*d).vptr + (index * (int64)2));
    wrapped = (int64)0;
    keytag = (int64)((*p).tag);
    keyvalue = (*p).value;
    pa = (*p).objptr;
L294:;
    while (1) {
        if (((int64)((*q).tag) == (int64)0)        ) {
            goto L295;
        }
        else if (((int64)((*q).tag) == keytag)) {
            if ((keytag==(int64)1) || (keytag==(int64)3) || (keytag==(int64)2) || (keytag==(int64)4)) {
                if (((*q).value == keyvalue)) {
                    return (q + (int64)1);
                }
            } else if ((keytag==(int64)5)) {
                qa = (*q).objptr;
                if (((*pa).length == (*qa).length)) {
                    if (((int64)(memcmp((void *)((*pa).strptr),(void *)((*qa).strptr),(uint64)((*pa).length))) == (int64)0)) {
                        return (q + (int64)1);
                    }
                }
            }
        }
        ++index;
        q += (int64)2;
        if ((index >= size)) {
            if (!!(wrapped)) {
                pc_support_pcerror((byte*)"DICT FULL?");
            }
            wrapped = (int64)1;
            index = (int64)1;
            q = (*d).vptr;
        }
    }
L295:;
    if (!!(doins)) {
        limit = ((size * (int64)15) / (int64)16);
        if (((int64)((*d).dictitems) >= limit)) {
            pc_pcfns_expanddict(d);
            goto L293;
        }
        (*q) = (*p);
        if (!!((*q).hasref)) {
            pc_pcfns_pc_ushare(q);
        }
        ++(*d).dictitems;
        return (q + (int64)1);
    }
    else {
        return (struct pc_decls_varrec *)(0);
    }
}

static void pc_pcfns_expanddict(struct pc_decls_objrec * d) {
    int64 n;
    int64 m;
    int64 i;
    int64 j;
    int64 k;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    struct pc_decls_varrec *  r;
    n = (int64)((*d).allocated);
    m = (n / (int64)2);
    p = (*d).vptr;
    (*d).vptr = pc_objects_make_listdata((n * (int64)2),&(*d).allocated,(int64)1);
    (*d).length *= (uint32)2u;
    (*d).dictitems = (uint32)0u;
    q = p;
L296:;
    for (i=(int64)1;i<=m;++i) {
L297:;
        if (((int64)((*q).tag) != (int64)0)) {
            r = pc_pcfns_finddictitem(d,q,(int64)1);
            if (!!((*q).hasref)) {
                pc_pcfns_pc_ufree(q);
            }
            ++q;
            (*r) = (*q++);
        }
        else {
            q += (int64)2;
        }
L298:;
    }
L299:;
    pc_objects_free_listdata(p,n);
}

static void pc_pcfns_setfslength(byte * s,int64 m,int64 n) {
    if ((m == n)    ) {
    }
    else if ((n == (m - (int64)1))) {
        (*((s + m) - (int64)1)) = (uint8)0u;
    }
    else {
        (*((s + m) - (int64)2)) = (uint8)0u;
        (*((s + m) - (int64)1)) = (byte)(n);
    }
}

int64 pc_pcfns_getfslength(byte * s,int64 m) {
    s += (m - (int64)1);
    if (((int64)((*(s - (int64)1))) == (int64)0)    ) {
        return (int64)((*s));
    }
    else if (((int64)((*s)) == (int64)0)) {
        return (m - (int64)1);
    }
    else {
        return m;
    }
}

int64 pc_pcfns_gethashvalue(struct pc_decls_varrec * p) {
    int64 hsum;
    int64 csum;
    int64 c;
    int64 n;
    int64 i;
    byte *  s;
    int64 av_1;
    switch ((int64)((*p).tag)) {
    case 5:;
        n = (int64)((*(*p).objptr).length);
        if (!(!!(n))) {
            return (int64)0;
        }
        hsum = (csum = (int64)0);
        s = (*(*p).objptr).strptr;
        av_1 = n;
        while (av_1-- > 0) {
L300:;
            c = (int64)((*s++));
            csum += c;
            hsum = ((hsum << (int64)2) + c);
L301:;
        }
L302:;
        return ((((c + (hsum << (int64)3)) ^ csum) ^ c) & (int64)2147483647);
        break;
    case 1:;
    case 2:;
    case 3:;
    case 4:;
        return (*p).value;
        break;
    default:;
        printf("%u\n",(*p).tag);
        pc_support_pcustype((byte*)"Can't hash:",p);
    }
    return (int64)0;
}

void pc_pcfns_pc_storeptr(struct pc_decls_varrec * p,struct pc_decls_varrec * q) {
    struct pc_decls_varrec *  dest;
    struct pc_decls_varrec *  pptr;
    struct pc_decls_varrec *  qptr;
    struct pc_decls_varrec v;
    int64 i;
    int64 n;
    int64 etag;
    uint32 ii;
    uint32 jj;
    uint32 mask;
    int64 poffset;
    int64 qoffset;
    int64 bitwidthx;
    byte *  pp;
    byte *  qq;
    int64 aa;
    int64 bb;
    switch ((int64)((*p).tag)) {
    case 22:;
        dest = (*p).varptr;
        if (!!((*dest).hasref)) {
            pc_pcfns_pc_ufree(dest);
        }
        if (!!((*q).hasref)) {
            pc_pcfns_pc_ushare(q);
        }
        (*dest) = (*q);
        break;
    case 23:;
        pc_pcfns_pc_storepacked((*p).refptr,q,(int64)((*p).refelemtag));
        if (!!((*q).hasref)) {
            pc_pcfns_pc_ufree(q);
        }
        break;
    case 24:;
        pc_pcfns_pc_storebit((*p).refptr,(int64)((*p).refbitoffset),q,(int64)((*p).refelemtag));
        break;
    case 29:;
        pc_pcfns_pc_popptrlist(p,q);
        if (!!((*p).hasref)) {
            pc_pcfns_pc_ufree(p);
        }
        if (!!((*q).hasref)) {
            pc_pcfns_pc_ufree(q);
        }
        break;
    default:;
        pc_support_pcustype((byte*)"pc_popptr",p);
    }
}

void pc_pcfns_pc_storebit(byte * p,int64 shift,struct pc_decls_varrec * q,int64 t) {
    byte bb;
    if (((int64)((*q).tag) != (int64)1)) {
        pc_support_pcerror((byte*)"storebit not int");
    }
    switch (t) {
    case 41:;
        (*p) = (byte)((((int64)((*p)) & ~(((int64)1 << shift))) | (((*q).value & (int64)1) << shift)));
        break;
    case 42:;
        (*p) = (byte)((((int64)((*p)) & ~(((int64)3 << shift))) | (((*q).value & (int64)3) << shift)));
        break;
    case 43:;
        (*p) = (byte)((((int64)((*p)) & ~(((int64)15 << shift))) | (((*q).value & (int64)15) << shift)));
        break;
    default:;
        pc_support_pcustypet((byte*)"storebit",t);
    }
}

void pc_pcfns_pc_popptrlist(struct pc_decls_varrec * p,struct pc_decls_varrec * q) {
    int64 i;
    int64 nleft;
    int64 nright;
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  pdata;
    struct pc_decls_varrec *  qdata;
    struct pc_decls_objrec *  pp;
    struct pc_decls_objrec *  qq;
    pp = (*p).objptr;
    nleft = (int64)((*pp).length);
    pdata = (*pp).vptr;
    v.tagx = (uint32)0u;
    switch ((int64)(pc_decls_ttbasetype[((int64)((*q).tag))])) {
    case 29:;
        qq = (*q).objptr;
        nright = (int64)((*qq).length);
//dolist:
L303:;
        qdata = (*qq).vptr;
L304:;
        for (i=(int64)1;i<=nleft;++i) {
L305:;
            if ((i <= nright)) {
                pc_pcfns_pc_storeptr(pdata,qdata++);
            }
            else {
                pc_pcfns_pc_storeptr(pdata,&v);
            }
            ++pdata;
L306:;
        }
L307:;
        break;
    case 4:;
L308:;
        for (i=(int64)1;i<=nleft;++i) {
L309:;
            if ((i <= (int64)2)) {
                v.tagx = (uint32)1u;
                v.value = ((i == (int64)1)?(int64)((*q).range_lower):(int64)((*q).range_upper));
                pc_pcfns_pc_storeptr(pdata,&v);
            }
            else {
                v.tagx = (uint32)0u;
                pc_pcfns_pc_storeptr(pdata,&v);
            }
            ++pdata;
L310:;
        }
L311:;
        break;
    case 32:;
        qq = (*q).objptr;
        nright = (int64)(pc_decls_ttlength[((int64)((*q).tag))]);
        goto L303;
        break;
    case 30:;
        pc_support_pcerror((byte*)"POPPTRLIST ARRAY");
        break;
    default:;
        pc_support_pcustype((byte*)"popptrlist",q);
    }
}

void pc_pcfns_pc_loadpacked(void * p,int64 t,struct pc_decls_varrec * dest,struct pc_decls_objrec * ownerobj) {
    int64 length;
    struct pc_decls_varrec *  q;
    struct pc_decls_varrec *  r;
    int64 *  pp;
    struct pc_decls_objrec *  s;
    byte *  ss;
    int64 av_1;
    switch ((int64)(pc_decls_ttbasetype[(t)])) {
    case 37:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = (int64)((*(int8 *)(p)));
        break;
    case 38:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = (int64)((*(int16 *)(p)));
        break;
    case 39:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = (int64)((*(int32 *)(p)));
        break;
    case 40:;
    case 1:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = (*(int64 *)(p));
        break;
    case 44:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = (int64)((*(byte *)(p)));
        break;
    case 45:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = (int64)((*(uint16 *)(p)));
        break;
    case 46:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = (int64)((*(uint32 *)(p)));
        break;
    case 47:;
        (*dest).tagx = (uint32)2u;
        (*dest).value = (int64)((*(uint32 *)(p)));
        break;
    case 49:;
        (*dest).tagx = (uint32)3u;
        (*dest).xvalue = (*(double *)(p));
        break;
    case 48:;
        (*dest).tagx = (uint32)3u;
        (*dest).xvalue = (double)((*(float *)(p)));
        break;
    case 5:;
        (*dest).tagx = (uint32)(((int64)5 | (int64)65536));
        length = (int64)(pc_decls_ttlength[(t)]);
        if ((length >= (int64)2)) {
            length = pc_pcfns_getfslength((byte *)(p),length);
        }
        else {
            length = (int64)1;
        }
        s = pc_objects_make_strslicexobj((byte *)(p),length);
        (*dest).objptr = s;
        break;
    case 21:;
        (*dest).tagx = (uint32)(((int64)5 | (int64)65536));
        ss = (byte *)(p);
        av_1 = (int64)(pc_decls_ttlength[(t)]);
        while (av_1-- > 0) {
L312:;
            if (((int64)((*ss)) == (int64)0)) {
                goto L314;
            }
            ++ss;
L313:;
        }
L314:;
        s = pc_objects_make_strslicexobj((byte *)(p),(ss - (byte *)(p)));
        (*dest).objptr = s;
        break;
    case 23:;
        (*dest).tagx = (uint32)23u;
        (*dest).refptr = (byte *)((*(int32 * *)(p)));
        (*dest).refelemtag = (uint16)(pc_decls_tttarget[(t)]);
        break;
    case 33:;
        s = pc_objects_newobject();
        (*s).mutable = (uint8)1u;
        (*s).lower = (int32)1;
        (*s).ptr = (byte *)(p);
        (*s).length = pc_decls_ttlength[(t)];
//dostruct:
L315:;
        (*dest).objptr = s;
        (*dest).tagx = (uint32)((t | (int64)65536));
        if (!!(ownerobj)) {
            (*s).objtype = (uint8)1u;
            (*s).objptr2 = ownerobj;
            ++(*ownerobj).refcount;
        }
        else {
            (*s).objtype = (uint8)2u;
        }
        break;
    case 30:;
        s = pc_objects_newobject();
        (*s).mutable = (uint8)1u;
        (*s).lower = pc_decls_ttlower[(t)];
        (*s).ptr = (byte *)(p);
        (*s).length = pc_decls_ttlength[(t)];
        (*s).elemtag = (uint16)(pc_decls_tttarget[(t)]);
        goto L315;
        break;
    default:;
        printf("%s %lld %d\n",(char*)((byte*)"T="),(int64)t,pc_decls_ttbasetype[(t)]);
        pc_support_pcmxtypestt((byte*)"loadpacked",t,(int64)(pc_decls_ttbasetype[(t)]));
    }
}

void pc_pcfns_pc_loadbit(byte * p,int64 shift,int64 t,struct pc_decls_varrec * dest) {
    (*dest).tagx = (uint32)1u;
    switch (t) {
    case 41:;
        (*dest).value = !!(((int64)((*p)) & ((int64)1 << shift)));
        break;
    case 42:;
        (*dest).value = (((int64)((*p)) & ((int64)3 << shift)) >> shift);
        break;
    case 43:;
        (*dest).value = (((int64)((*p)) & ((int64)15 << shift)) >> shift);
        break;
    default:;
        pc_support_pcustypet((byte*)"loadbit",t);
    }
}

void pc_pcfns_pc_loadptr(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    switch ((int64)((*x).tag)) {
    case 22:;
        (*y) = (*(*x).varptr);
        if (!!((*y).hasref)) {
            ++(*(*y).objptr).refcount;
        }
        break;
    case 23:;
        pc_pcfns_pc_loadpacked((void *)((*x).refptr),(int64)((*x).refelemtag),y,(struct pc_decls_objrec *)(0));
        break;
    default:;
        pc_support_pcustype((byte*)"pc_loadptr",x);
    }
}

void pc_pcfns_pc_storestring(struct pc_decls_varrec * p,struct pc_decls_varrec * q) {
    struct pc_decls_objrec *  pp;
    struct pc_decls_objrec *  qq;
    pp = (*p).objptr;
    qq = (*q).objptr;
    if (((int64)((*pp).objtype) == (int64)0)) {
        pc_support_pcerror((byte*)"popstr not slice");
    }
    if (((int64)((*q).tag) != (int64)5)) {
        pc_support_pcerror((byte*)"popstr not str");
    }
    if (((*pp).length != (*qq).length)) {
        pc_support_pcerror((byte*)"popstr diff lengths");
    }
    if (!(!!((*pp).mutable))) {
        pc_support_pcerror((byte*)"popstr not mut");
    }
    if (!!((*pp).length)) {
        memcpy((void *)((*pp).strptr),(void *)((*qq).strptr),(uint64)((*pp).length));
    }
    pc_pcfns_pc_ufree(p);
    pc_pcfns_pc_ufree(q);
}

void pc_pcfns_pc_iconvert(int64 t,struct pc_decls_varrec * x) {
    int64 s;
    int64 tbase;
    int64 aa;
    struct pc_decls_varrec bn;
    s = (int64)((*x).tag);
    if (((s == t) && (s < (int64)29))) {
        return;
    }
    tbase = (int64)(pc_decls_ttbasetype[(t)]);
    (*x).tag = (uint16)(t);
    switch ((int64)(pc_decls_ttbasetype[(s)])) {
    case 1:;
        switch (tbase) {
        case 1:;
            break;
        case 3:;
            (*x).xvalue = (double)((*x).value);
            break;
        case 2:;
            break;
        case 7:;
            pc_bigint_bn_makeint((*pc_decls_sptr).value,pc_decls_sptr);
            break;
        default:;
            pc_support_pcustypet((byte*)"conv dint=>",t);
        }
        break;
    case 2:;
        switch (tbase) {
        case 1:;
            break;
        case 2:;
            break;
        case 3:;
            break;
        default:;
            pc_support_pcustypet((byte*)"conv dint=>",t);
        }
        break;
    case 3:;
        switch (tbase) {
        case 1:;
            (*x).value = (int64)((*x).xvalue);
            break;
        default:;
            pc_support_pcustypet((byte*)"conv real=>",t);
        }
        break;
    case 23:;
    case 22:;
    case 24:;
    case 18:;
        switch (tbase) {
        case 1:;
            break;
        default:;
            pc_support_pcustypet((byte*)"conv ptr=>",t);
        }
        break;
    case 5:;
        switch (tbase) {
        case 7:;
            pc_bigint_bn_makestr((*(*x).objptr).strptr,(int64)((*(*x).objptr).length),&bn);
            pc_pcfns_pc_ufree(x);
            (*x) = bn;
            break;
        case 5:;
            break;
        default:;
            pc_support_pcustypet((byte*)"string=>",t);
        }
        break;
    case 13:;
        if ((tbase != (int64)1)) {
            pc_support_pcustypet((byte*)"type=>",t);
        }
        break;
    case 7:;
        switch (tbase) {
        case 1:;
            aa = pc_bigint_bn_int(x);
            (*x).tagx = (uint32)(((int64)7 | (int64)65536));
            pc_pcfns_pc_ufree(x);
            (*x).tagx = (uint32)1u;
            (*x).value = aa;
            (*x).tagx = (uint32)(t);
            break;
        default:;
            pc_support_pcustypet((byte*)"longint=>",t);
        }
        break;
    default:;
        pc_support_pcmxtypestt((byte*)"HARDCONV s^.t",s,t);
    }
}

void pc_pcfns_pc_iconvcase(struct pc_decls_varrec * a,struct pc_decls_varrec * b,int64 upper) {
    int64 i;
    int64 n;
    byte *  s;
    struct pc_decls_objrec *  pa;
    int64 av_1;
    int64 av_2;
    pa = (*a).objptr;
    if (((int64)((*b).tag) > (int64)0)) {
        n = pc_support_getintvalue(b);
    }
    else {
        n = (int64)((*pa).length);
    }
    if (((int64)((*a).tag) != (int64)5)) {
        pc_support_pcerror((byte*)"convcase/notstr");
    }
    if ((n < (int64)0)) {
        pc_support_pcerror((byte*)"CONVCASE N<0");
    }
    if ((n == (int64)0)) {
        return;
    }
    if ((n > (int64)((*pa).length))) {
        printf("%s %lld %u\n",(char*)((byte*)"N="),(int64)n,(*pa).length);
        pc_support_pcerror((byte*)"convcase/N?");
    }
    s = (*pa).strptr;
    if (!!(upper)) {
        av_1 = n;
        while (av_1-- > 0) {
L316:;
            (*s) = (byte)(toupper((int32)((*s))));
            ++s;
L317:;
        }
L318:;
    }
    else {
        av_2 = n;
        while (av_2-- > 0) {
L319:;
            (*s) = (byte)(tolower((int32)((*s))));
            ++s;
L320:;
        }
L321:;
    }
}

int64 pc_pcfns_pc_eqstring_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 n;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    n = (int64)((*px).length);
    if ((n != (int64)((*py).length))) {
        return (int64)0;
    }
    if ((n == (int64)0)) {
        return (int64)1;
    }
    return (int64)((mlib_cmpstringn((*px).strptr,(*py).strptr,n) == (int64)0));
}

int64 pc_pcfns_pc_equal_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y,int64 shallow) {
    int64 xt;
    int64 yt;
    int64 xbase;
    int64 ybase;
    int64 xval;
    int64 yval;
    int64 i;
    int64 nbits;
    int64 nbytes;
    int64 n;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    int64 av_1;
    int64 av_2;
    xbase = (int64)(pc_decls_ttbasetype[((xt = (int64)((*x).tag)))]);
    ybase = (int64)(pc_decls_ttbasetype[((yt = (int64)((*y).tag)))]);
    if ((ybase == (int64)0)) {
        pc_support_pcerror((byte*)"pcequal/void");
    }
    px = (*x).objptr;
    py = (*y).objptr;
    switch (xbase) {
    case 1:;
        switch (ybase) {
        case 1:;
        case 2:;
            return (((*x).value == (*y).value)?(int64)1:(int64)0);
            break;
        case 3:;
            return (((double)((*x).value) == (*y).xvalue)?(int64)1:(int64)0);
            break;
        default:;
        }
        break;
    case 2:;
        switch (ybase) {
        case 46:;
            return (((*x).uvalue == (*y).uvalue)?(int64)1:(int64)0);
            break;
        default:;
        }
        break;
    case 3:;
        switch (ybase) {
        case 1:;
            return (((*x).xvalue == (double)((*y).value))?(int64)1:(int64)0);
            break;
        case 3:;
            return (((*x).xvalue == (*y).xvalue)?(int64)1:(int64)0);
            break;
        default:;
        }
        break;
    case 4:;
        if ((ybase == (int64)4)) {
            return (((*x).value == (*y).value)?(int64)1:(int64)0);
        }
        break;
    case 22:;
        switch (ybase) {
        case 22:;
        case 1:;
            return (int64)(((*x).value == (*y).value));
            break;
        default:;
        }
        break;
    case 23:;
        switch (ybase) {
        case 23:;
        case 1:;
            return (int64)(((*x).value == (*y).value));
            break;
        default:;
        }
        break;
    case 18:;
        switch (ybase) {
        case 18:;
        case 1:;
            return (int64)(((*x).value == (*y).value));
            break;
        default:;
        }
        break;
    case 29:;
        if ((ybase == (int64)29)) {
            if (!!(shallow)) {
                return (int64)((px == py));
            }
            if (((*px).length != (*py).length)) {
                return (int64)0;
            }
            p = (*px).vptr;
            q = (*py).vptr;
            av_1 = (int64)((*px).length);
            while (av_1-- > 0) {
L322:;
                if ((pc_pcfns_pc_equal_nf(p++,q++,shallow) == (int64)0)) {
                    return (int64)0;
                }
L323:;
            }
L324:;
            return (int64)1;
        }
        break;
    case 5:;
        switch (ybase) {
        case 5:;
            return pc_pcfns_pc_eqstring_nf(x,y);
            break;
        default:;
        }
        break;
    case 33:;
        if ((xt != yt)) {
            return (int64)0;
        }
        return pc_pcfns_comparebytes((*px).ptr,(*py).ptr,pc_decls_ttsize[(xt)]);
        break;
    case 9:;
        if ((ybase != (int64)9)) {
            return (int64)0;
        }
        if (((*px).length != (*py).length)) {
            return (int64)0;
        }
        nbytes = ((((int64)((*px).length) - (int64)1) / (int64)64) + (int64)1);
        return pc_pcfns_comparebytes((*px).ptr,(*py).ptr,nbytes);
        break;
    case 0:;
        pc_support_pcerror((byte*)"Comparing void types");
        break;
    case 7:;
        if ((ybase != (int64)7)) {
            return (int64)0;
        }
        return (int64)((pc_bigint_bn_equal(x,y) == (int64)1));
        break;
    case 32:;
        if ((xt != yt)) {
            return (int64)0;
        }
        if (!!(shallow)) {
            return (int64)((px == py));
        }
        p = (*px).vptr;
        q = (*py).vptr;
        n = (int64)(pc_decls_ttlength[(xt)]);
        av_2 = n;
        while (av_2-- > 0) {
L325:;
            if ((pc_pcfns_pc_equal_nf(p++,q++,shallow) == (int64)0)) {
                return (int64)0;
            }
L326:;
        }
L327:;
        return (int64)1;
        break;
    case 30:;
        if ((ybase == (int64)30)) {
            pc_support_pcerror((byte*)"pc_equal/array");
        }
        return (int64)0;
        break;
    case 13:;
        if (((ybase == (int64)13) && ((*x).value == (*y).value))) {
            return (int64)1;
        }
        break;
    default:;
        printf("%s\n",(char*)((byte*)"DIFF TYPES"));
        return (int64)0;
    }
    return (int64)0;
}

int64 pc_pcfns_comparebytes(byte * p,byte * q,int64 n) {
    return (int64)(((int64)(memcmp((void *)(p),(void *)(q),(uint64)(n))) == (int64)0));
}

int64 pc_pcfns_pc_compare_nf(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 xt;
    int64 yt;
    int64 xbase;
    int64 ybase;
    int64 xval;
    int64 yval;
    int64 i;
    int64 nbits;
    int64 nbytes;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    ybase = (int64)(pc_decls_ttbasetype[((yt = (int64)((*y).tag)))]);
    xbase = (int64)(pc_decls_ttbasetype[((xt = (int64)((*x).tag)))]);
    switch (xbase) {
    case 1:;
        switch (ybase) {
        case 1:;
            return (((*x).value < (*y).value)?(int64)-1:(((*x).value > (*y).value)?(int64)1:(int64)0));
            break;
        case 3:;
            return (((double)((*x).value) < (*y).xvalue)?(int64)-1:(((double)((*x).value) > (*y).xvalue)?(int64)1:(int64)0));
            break;
        default:;
            goto L328;
        }
        break;
    case 2:;
        switch (ybase) {
        case 2:;
            return (((*x).uvalue < (*y).uvalue)?(int64)-1:(((*x).uvalue > (*y).uvalue)?(int64)1:(int64)0));
            break;
        default:;
            goto L328;
        }
        break;
    case 3:;
        switch (ybase) {
        case 1:;
            return (((*x).xvalue < (double)((*y).value))?(int64)-1:(((*x).xvalue > (double)((*y).value))?(int64)1:(int64)0));
            break;
        case 3:;
            return (((*x).xvalue < (*y).xvalue)?(int64)-1:(((*x).xvalue > (*y).xvalue)?(int64)1:(int64)0));
            break;
        default:;
            goto L328;
        }
        break;
    case 23:;
        switch (ybase) {
        case 23:;
        case 1:;
            return (((*x).value < (*y).value)?(int64)-1:(((*x).value > (*y).value)?(int64)1:(int64)0));
            break;
        default:;
            goto L328;
        }
        break;
    case 22:;
        switch (ybase) {
        case 22:;
        case 1:;
            return (((*x).value < (*y).value)?(int64)-1:(((*x).value > (*y).value)?(int64)1:(int64)0));
            break;
        default:;
            goto L328;
        }
        break;
    case 5:;
        switch (ybase) {
        case 5:;
            px = (*x).objptr;
            py = (*y).objptr;
            return pc_pcfns_cmpstringlen((*px).strptr,(*py).strptr,(int64)((*px).length),(int64)((*py).length));
            break;
        default:;
            goto L328;
        }
        break;
    case 7:;
        if ((ybase == (int64)7)) {
            return pc_bigint_bn_cmp(x,y);
        }
        else {
            goto L328;
        }
        break;
    default:;
//badcmp:
L328:;
        pc_support_pcmxtypes((byte*)"pc_compare",x,y);
    }
    return (int64)0;
}

int64 pc_pcfns_cmpstringlen(byte * s,byte * t,int64 slen,int64 tlen) {
    if ((slen == (int64)0)    ) {
        if ((tlen == (int64)0)) {
            return (int64)0;
        }
        else {
            return (int64)-1;
        }
    }
    else if ((tlen == (int64)0)) {
        return (int64)1;
    }
    else {
        if ((slen == tlen)) {
            if ((slen == (int64)1)) {
                if (((*s) < (*t))                ) {
                    return (int64)-1;
                }
                else if (((*s) > (*t))) {
                    return (int64)1;
                }
                else {
                    return (int64)0;
                }
            }
            return mlib_cmpstringn(s,t,slen);
        }
        else {
            return mlib_cmpstring(pc_support_convcstring(s,slen),pc_support_convcstring(t,tlen));
        }
    }
}

int64 pc_pcfns_pc_eqstring(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    int64 res;
    int64 n;
    res = pc_pcfns_pc_eqstring_nf(x,y);
    px = (*x).objptr;
    py = (*y).objptr;
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    return res;
}

int64 pc_pcfns_pc_equal(struct pc_decls_varrec * x,struct pc_decls_varrec * y,int64 shallow) {
    int64 res;
    int64 n;
    res = pc_pcfns_pc_equal_nf(x,y,shallow);
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    return res;
}

int64 pc_pcfns_pc_compare(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 res;
    int64 n;
    res = pc_pcfns_pc_compare_nf(x,y);
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    return res;
}

int64 pc_pcfns_u8inarray(byte a,struct pc_decls_objrec * p) {
    int64 i;
    byte *  q;
    int64 av_1;
    i = (int64)((*p).lower);
    q = (*p).ptr;
    av_1 = (int64)((*p).length);
    while (av_1-- > 0) {
L329:;
        if (((*q) == a)) {
            return i;
        }
        ++q;
        ++i;
L330:;
    }
L331:;
    return ((int64)((*p).lower) - (int64)1);
}

int64 pc_pcfns_u16inarray(uint16 a,struct pc_decls_objrec * p) {
    int64 i;
    uint16 *  q;
    int64 av_1;
    i = (int64)((*p).lower);
    q = (uint16 *)((*p).ptr);
    av_1 = (int64)((*p).length);
    while (av_1-- > 0) {
L332:;
        if (((*q) == a)) {
            return i;
        }
        ++q;
        ++i;
L333:;
    }
L334:;
    return ((int64)((*p).lower) - (int64)1);
}

int64 pc_pcfns_u32inarray(uint32 a,struct pc_decls_objrec * p) {
    int64 i;
    uint32 *  q;
    int64 av_1;
    i = (int64)((*p).lower);
    q = (uint32 *)((*p).ptr);
    av_1 = (int64)((*p).length);
    while (av_1-- > 0) {
L335:;
        if (((*q) == a)) {
            return i;
        }
        ++q;
        ++i;
L336:;
    }
L337:;
    return ((int64)((*p).lower) - (int64)1);
}

int64 pc_pcfns_u64inarray(uint64 a,struct pc_decls_objrec * p) {
    int64 i;
    uint64 *  q;
    int64 av_1;
    i = (int64)((*p).lower);
    q = (uint64 *)((*p).ptr);
    av_1 = (int64)((*p).length);
    while (av_1-- > 0) {
L338:;
        if (((*q) == a)) {
            return i;
        }
        ++q;
        ++i;
L339:;
    }
L340:;
    return ((int64)((*p).lower) - (int64)1);
}

int64 pc_pcfns_bitinbits(byte a,struct pc_decls_objrec * p) {
    int64 i;
    int64 offset;
    int64 mask;
    byte *  q;
    int64 av_1;
    i = (int64)((*p).lower);
    q = (*p).ptr;
    offset = ((int64)((*p).bitoffset) - (int64)1);
    mask = (int64)1;
    if (!!(offset)) {
        mask = (mask << offset);
    }
    av_1 = (int64)((*p).length);
    while (av_1-- > 0) {
L341:;
        printf("%s %u %lld %s %lld %lld %s %u\n",(char*)((byte*)"Q^="),(*q),(int64)((int64)((*q)) & mask),(char*)((byte*)"MASK="),(int64)mask,(int64)i,(char*)((byte*)"A="),a);
        if (!!(((int64)((*q)) & mask))        ) {
            if (!!(a)) {
                return i;
            }
        }
        else if (((int64)(a) == (int64)0)) {
            return i;
        }
        ++i;
        mask <<= (int64)1;
        if ((mask >= (int64)256)) {
            mask = (int64)1;
            ++q;
        }
L342:;
    }
L343:;
    return ((int64)((*p).lower) - (int64)1);
}

int64 pc_pcfns_pc_strinstr(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 xlen;
    int64 ylen;
    int64 result;
    int64 i;
    int64 j;
    int64 k;
    byte *  sx;
    byte *  sy;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64)((*px).length);
    ylen = (int64)((*py).length);
    if (((xlen == (int64)0) || (ylen == (int64)0))) {
        return (int64)0;
    }
    k = (ylen - xlen);
L344:;
    for (i=(int64)0;i<=k;++i) {
L345:;
        sx = (*px).strptr;
        sy = ((*py).strptr + i);
L348:;
        for (j=(int64)1;j<=xlen;++j) {
L349:;
            if (((*sx) != (*sy))) {
                goto L352;
            }
            ++sx;
            ++sy;
L350:;
        }
L351:;
        return (i + (int64)1);
//nextpos:
L352:;
L346:;
    }
L347:;
    return (int64)0;
}

byte * pc_pcfns_getbitoffset(byte * p,int64 offset,int64 index,int64 t,byte * newoffset) {
    switch (t) {
    case 41:;
        index += offset;
        p += (index >> (int64)3);
        (*newoffset) = (byte)((index & (int64)7));
        break;
    case 42:;
        index += (offset >> (int64)1);
        p += (index >> (int64)2);
        (*newoffset) = (byte)(((index & (int64)3) * (int64)2));
        break;
    case 43:;
        index += (offset >> (int64)2);
        p += (index >> (int64)1);
        (*newoffset) = (byte)(((index & (int64)1) * (int64)4));
        break;
    default:;
    }
    return p;
}

void pc_pcfns_pc_iappendlist(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    int64 n;
    int64 lower;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  p;
    p = (*a).objptr;
    if (((int64)((*p).objtype) != (int64)0)) {
        pc_support_pcerror((byte*)"Can't extend slice");
    }
    if (!(!!((*p).mutable))) {
        p = pc_objects_copyonwrite(p,(int64)29);
    }
    n = ((int64)((*p).length) + (int64)1);
    if ((n > (int64)((*p).allocated))) {
        pc_objects_resize_listobj(p,n);
    }
    else {
        (*p).length = (uint32)(n);
    }
    (*(((*p).vptr + n) - (int64)1)).tagx = (uint32)0u;
    (*a).objptr = p;
    q = (((*p).vptr + (int64)((*p).length)) - (int64)1);
    if (!!(b)) {
        (*q) = (*b);
    }
    else {
        (*q).tagx = (uint32)0u;
    }
}

void pc_pcfns_pc_iappendarray(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    int64 n;
    int64 lower;
    byte *  q;
    struct pc_decls_objrec *  p;
    p = (*a).objptr;
    if (((int64)((*p).objtype) != (int64)0)) {
        pc_support_pcerror((byte*)"Can't extend slice");
    }
    if (!(!!((*p).mutable))) {
        p = pc_objects_copyonwrite(p,(int64)((*a).tag));
    }
    n = ((int64)((*p).length) + (int64)1);
    if ((n > (int64)((*p).allocated))) {
        pc_objects_resize_arrayobj(p,n);
    }
    else {
        (*p).length = (uint32)(n);
    }
    (*a).objptr = p;
    q = ((*p).strptr + (((int64)((*p).length) - (int64)1) * pc_decls_ttsize[((int64)((*p).elemtag))]));
    if (!!(b)) {
        pc_pcfns_pc_storepacked(q,b,(int64)((*p).elemtag));
    }
    else {
    }
}

void pc_pcfns_pc_mul_listi(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_varrec *  newptr;
    struct pc_decls_varrec *  oldptr;
    struct pc_decls_varrec *  q;
    int64 newlength;
    int64 newalloc;
    int64 oldlength;
    int64 k;
    int64 i;
    int64 newtag;
    int64 lwr;
    int64 dvalue;
    struct pc_decls_varrec d;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pc;
    int64 av_1;
    d = (*a);
    pa = d.objptr;
    oldlength = (int64)((*pa).length);
    newlength = (oldlength * (*b).value);
    oldptr = (*pa).vptr;
    if (!(!!(oldlength))) {
        return;
    }
    if ((newlength < (int64)0)    ) {
        pc_support_pcerror((byte*)"mullist 0");
    }
    else if ((newlength == (int64)0)) {
        if (!!((*a).hasref)) {
            pc_pcfns_pc_ufree(a);
        }
        (*c).tagx = (uint32)29u;
        (*c).objptr = pc_objects_emptylist;
        ++(*pc_objects_emptylist).refcount;
        return;
    }
    if ((oldlength == (int64)1)) {
        pc = pc_objects_make_listobj(newlength,(int64)((*pa).lower));
        newptr = (*pc).vptr;
        (*c).tagx = d.tagx;
        (*c).objptr = pc;
        q = (*d.objptr).vptr;
        av_1 = newlength;
        while (av_1-- > 0) {
L353:;
            (*newptr) = (*q);
            if (!!((*newptr).hasref)) {
                ++(*(*newptr).objptr).refcount;
                pc_pcfns_pc_dupl(newptr);
            }
            ++newptr;
L354:;
        }
L355:;
        if (!!(d.hasref)) {
            pc_pcfns_pc_ufree(&d);
        }
    }
    else {
        pc_support_pcerror((byte*)"MULLISTINT/COMPLEX");
    }
}

void pc_pcfns_pc_mul_stri(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    int64 i;
    int64 m;
    int64 oldlen;
    int64 newlen;
    byte *  newptr;
    byte *  p;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  s;
    int64 av_1;
    m = pc_support_getintvalue(b);
    if ((m < (int64)0)    ) {
        pc_support_pcerror((byte*)"neg str mul");
    }
    else if ((m == (int64)0)) {
        pc_pcfns_pc_emptystring(c);
        return;
    }
    else if ((m == (int64)1)) {
        if ((a != c)) {
            (*c) = (*a);
            if (!!((*c).hasref)) {
                pc_pcfns_pc_ushare(c);
            }
        }
        return;
    }
    else {
        pa = (*a).objptr;
        oldlen = (int64)((*pa).length);
        if (!!(oldlen)) {
            newlen = (oldlen * m);
            pc_pcfns_pc_makestringn(newlen,&v);
            p = (*v.objptr).strptr;
            av_1 = m;
            while (av_1-- > 0) {
L356:;
                memcpy((void *)(p),(void *)((*pa).strptr),(uint64)(oldlen));
                p += oldlen;
L357:;
            }
L358:;
            pc_pcfns_pc_ufree(a);
            (*c) = v;
        }
        else {
            (*c) = (*a);
            pc_pcfns_pc_ushare(a);
            return;
        }
    }
}

void pc_pcfns_pc_duplvar(struct pc_decls_varrec * p) {
    if (!!((*p).hasref)) {
        ((*pc_decls_dupl_table[((int64)((*p).tag))]))(p);
    }
}

void pc_pcfns_pc_iconcatlist(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    struct pc_decls_varrec *  newptr;
    struct pc_decls_varrec *  c;
    struct pc_decls_varrec *  d;
    int64 n;
    int64 alen;
    int64 blen;
    int64 newlen;
    int64 oldbytes;
    int64 newbytes;
    struct pc_decls_varrec *  v;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    int64 av_1;
    int64 av_2;
    pa = (*a).objptr;
    if (!(!!((*pa).mutable))) {
        pa = pc_objects_copyonwrite(pa,(int64)((*a).tag));
        (*a).objptr = pa;
    }
    pb = (*b).objptr;
    alen = (int64)((*pa).length);
    blen = (int64)((*pb).length);
    if ((alen == (int64)0)    ) {
        if (!!(blen)) {
            pc_objects_resize_listobj(pa,blen);
            d = (*pa).vptr;
            memcpy((void *)(d),(void *)((*pb).vptr),(uint64)((blen * (int64)16)));
            av_1 = blen;
            while (av_1-- > 0) {
L359:;
                if (!!((*d).hasref)) {
                    pc_pcfns_pc_ushare(d);
                }
                ++d;
L360:;
            }
L361:;
        }
    }
    else if (!!(blen)) {
        newlen = (alen + blen);
        pc_objects_resize_listobj(pa,newlen);
        d = ((*pa).vptr + alen);
        memcpy((void *)(d),(void *)((*pb).vptr),(uint64)((blen * (int64)16)));
        av_2 = blen;
        while (av_2-- > 0) {
L362:;
            if (!!((*d).hasref)) {
                pc_pcfns_pc_ushare(d);
            }
            ++d;
L363:;
        }
L364:;
    }
}

void pc_pcfns_pc_iappendbits(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    int64 lower;
    int64 elemtype;
    int64 index;
    int64 n;
    byte bitoffset;
    byte *  q;
    struct pc_decls_objrec *  p;
    p = (*a).objptr;
    if (!(!!((*p).mutable))) {
        (*a).objptr = (p = pc_objects_copyonwrite(p,(int64)((*a).tag)));
    }
    n = ((int64)((*p).length) + (int64)1);
    if ((n > (int64)((*p).allocated64))) {
        pc_objects_resize_bitsobj(p,n);
    }
    else {
        (*p).length = (uint32)(n);
    }
    elemtype = (int64)((*p).elemtag);
    q = pc_pcfns_getbitoffset((*p).strptr,((int64)((*p).bitoffset) - (int64)1),((int64)((*p).length) - (int64)1),elemtype,&bitoffset);
    if (!!(b)) {
        pc_pcfns_pc_storebit(q,(int64)(bitoffset),b,elemtype);
    }
}

void pc_pcfns_pc_makestring(byte * s,int64 length,struct pc_decls_varrec * dest) {
    byte *  t;
    if ((s == 0)) {
        pc_pcfns_pc_makestringx((byte *)(0),(int64)0,(int64)0,dest);
        return;
    }
    if ((length == (int64)-1)) {
        length = (int64)(strlen(s));
    }
    if ((length == (int64)0)) {
        pc_pcfns_pc_makestringx(t,(int64)0,(int64)0,dest);
    }
    else {
        t = (byte *)(mlib_pcm_alloc(length));
        memcpy((void *)(t),(void *)(s),(uint64)(length));
        pc_pcfns_pc_makestringx(t,length,mlib_allocbytes,dest);
    }
}

void pc_pcfns_pc_makestringx(byte * s,int64 length,int64 allocated,struct pc_decls_varrec * dest) {
    byte *  t;
    struct pc_decls_objrec *  p;
    if ((length == (int64)-1)) {
        length = (int64)(strlen(s));
    }
    (*dest).tagx = (uint32)65541u;
    (*dest).objptr = (p = pc_objects_newobject());
    if ((length == (int64)0)) {
        (*p).strptr = (byte *)(0);
    }
    else {
        (*p).strptr = s;
        (*p).length = (uint32)(length);
        (*p).allocated = (uint32)(allocated);
    }
    (*p).mutable = (uint8)1u;
}

void pc_pcfns_pc_makestringn(int64 length,struct pc_decls_varrec * dest) {
    struct pc_decls_objrec *  p;
    (*dest).tagx = (uint32)65541u;
    (*dest).objptr = (p = pc_objects_newobject());
    if ((length > (int64)((uint64)4000000000u))) {
        pc_support_pcerror((byte*)"String*n too long");
    }
    (*p).strptr = (byte *)(mlib_pcm_alloc(length));
    (*p).mutable = (uint8)1u;
    (*p).length = (uint32)(length);
    (*p).allocated = (uint32)(mlib_allocbytes);
}

void pc_pcfns_pc_emptystring(struct pc_decls_varrec * dest) {
    struct pc_decls_objrec *  p;
    if (((int64)(pc_decls_emptystringvar.tag) == (int64)0)) {
        p = pc_objects_newobject();
        (*p).refcount = (uint32)1u;
        (*p).mutable = (uint8)1u;
        pc_decls_emptystringvar.tagx = (uint32)(((int64)5 | (int64)65536));
        pc_decls_emptystringvar.objptr = p;
    }
    else {
        p = pc_decls_emptystringvar.objptr;
    }
    (*dest).tagx = (uint32)(((int64)5 | (int64)65536));
    (*dest).objptr = p;
    ++(*p).refcount;
}

void pc_pcfns_pc_makechar(int64 ch,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec v;
    byte str[10];
    struct pc_decls_objrec *  p;
    (*dest).tagx = (uint32)(((int64)5 | (int64)65536));
    p = pc_decls_chrtable[(ch)];
    if ((p == 0)) {
        str[((int64)1)-1] = (byte)(ch);
        str[((int64)2)-1] = (uint8)0u;
        pc_pcfns_pc_makestring(str,(int64)1,&v);
        p = v.objptr;
        (*p).mutable = (uint8)0u;
        pc_decls_chrtable[(ch)] = p;
    }
    ++(*p).refcount;
    (*dest).objptr = p;
}

struct pc_decls_objrec * pc_objects_newobject(void) {
    struct pc_decls_objrec *  p;
    p = (struct pc_decls_objrec *)(mlib_pcm_alloc32());
    memcpy(&(*p),&pc_objects_zeroobj,32);
    return p;
}

void pc_objects_freeobject(struct pc_decls_objrec * p) {
    mlib_pcm_free32((void *)(p));
}

struct pc_decls_objrec * pc_objects_addref_obj(struct pc_decls_objrec * p) {
    ++(*p).refcount;
    return p;
}

void pc_objects_makezobjects(void) {
    pc_objects_emptyset = pc_objects_newobject();
    (*pc_objects_emptyset).refcount = (uint32)5u;
    pc_objects_emptylist = pc_objects_newobject();
    (*pc_objects_emptylist).refcount = (uint32)5u;
    (*pc_objects_emptylist).lower = (int32)1;
    pc_objects_deflistobj.refcount = (uint32)1u;
    pc_objects_deflistobj.mutable = (uint8)1u;
    pc_objects_deflistobj.elemtag = (uint16)0u;
    pc_objects_deflistobj.lower = (int32)1;
    pc_objects_zeroobj.refcount = (uint32)1u;
}

struct pc_decls_varrec * pc_objects_make_listdata(int64 length,uint32 * allocated,int64 clear) {
    byte *  p;
    if ((length == (int64)0)) {
        (*allocated) = (uint32)0u;
        return (struct pc_decls_varrec *)(0);
    }
    if ((length > (int64)((uint64)4000000000u))) {
        pc_support_pcerror((byte*)"List too big");
    }
    p = (byte *)(mlib_pcm_alloc((length * (int64)16)));
    if (!!(clear)) {
        mlib_pcm_clearmem((void *)(p),mlib_allocbytes);
    }
    (*allocated) = (uint32)((mlib_allocbytes / (int64)16));
    return (struct pc_decls_varrec *)(p);
}

void pc_objects_free_listdata(struct pc_decls_varrec * p,int64 allocated) {
    pc_objects_free_arraydata(p,(int64)35,allocated);
}

struct pc_decls_varrec * pc_objects_make_arraydata(int64 length,int64 elemtype,uint32 * allocated,int64 clear) {
    struct pc_decls_varrec *  p;
    int64 elemsize;
    if ((length == (int64)0)) {
        (*allocated) = (uint32)0u;
        return (struct pc_decls_varrec *)(0);
    }
    if ((length > (int64)((uint64)4000000000u))) {
        pc_support_pcerror((byte*)"Array too big");
    }
    elemsize = pc_decls_ttsize[(elemtype)];
    p = (struct pc_decls_varrec *)(mlib_pcm_alloc((length * elemsize)));
    if (!!(clear)) {
        mlib_pcm_clearmem((void *)(p),mlib_allocbytes);
    }
    (*allocated) = (uint32)((mlib_allocbytes / elemsize));
    return p;
}

void pc_objects_free_arraydata(struct pc_decls_varrec * p,int64 elemtype,int64 allocated) {
    if (!!(allocated)) {
        mlib_pcm_free((void *)(p),(allocated * pc_decls_ttsize[(elemtype)]));
    }
}

byte * pc_objects_make_bitdata(int64 length,int64 elemtype,uint64 * allocated,int64 clear) {
    byte *  p;
    int64 bitwidthx;
    int64 nbits;
    int64 nbytes;
    if ((length == (int64)0)) {
        (*allocated) = (uint64)((int64)0);
        return (byte *)(0);
    }
    if ((length > (int64)((uint64)4000000000u))) {
        pc_support_pcerror((byte*)"Set/bitarray too big");
    }
    bitwidthx = (int64)(pc_decls_ttbitwidth[(elemtype)]);
    nbits = (length * bitwidthx);
    nbytes = ((((nbits - (int64)1) / (int64)64) + (int64)1) * (int64)8);
    p = (byte *)(mlib_pcm_alloc(nbytes));
    if (!!(clear)) {
        mlib_pcm_clearmem((void *)(p),mlib_allocbytes);
    }
    (*allocated) = (uint64)(((int64)((uint64)(mlib_allocbytes)) * ((int64)8 / bitwidthx)));
    return p;
}

void pc_objects_free_bitdata(byte * p,int64 elemtype,int64 allocated) {
    if (!!(allocated)) {
        mlib_pcm_free((void *)(p),(allocated / ((int64)8 / (int64)(pc_decls_ttbitwidth[(elemtype)]))));
    }
}

struct pc_decls_objrec * pc_objects_make_listobj(int64 length,int64 lower) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  q;
    int64 av_1;
    p = (struct pc_decls_objrec *)(mlib_pcm_alloc32());
    memcpy(&(*p),&pc_objects_deflistobj,32);
    if (!!(length)) {
        q = (struct pc_decls_varrec *)(mlib_pcm_alloc((length * (int64)16)));
        (*p).allocated = (uint32)((mlib_allocbytes / (int64)16));
    }
    else {
        q = (struct pc_decls_varrec *)(0);
    }
    (*p).vptr = q;
    (*p).length = (uint32)(length);
    (*p).lower = (int32)(lower);
    av_1 = length;
    while (av_1-- > 0) {
L365:;
        (*q).tagx = (uint32)0u;
        ++q;
L366:;
    }
L367:;
    return p;
}

struct pc_decls_objrec * pc_objects_make_arrayobj(int64 length,int64 elemtype,int64 lower) {
    struct pc_decls_objrec *  p;
    p = pc_objects_newobject();
    (*p).vptr = pc_objects_make_arraydata(length,elemtype,&(*p).allocated,(int64)1);
    (*p).mutable = (uint8)1u;
    (*p).length = (uint32)(length);
    (*p).lower = (int32)(lower);
    (*p).elemtag = (uint16)(elemtype);
    return p;
}

struct pc_decls_objrec * pc_objects_make_setobj(int64 length) {
    struct pc_decls_objrec *  p;
    p = pc_objects_newobject();
    (*p).ptr = pc_objects_make_bitdata(length,(int64)41,&(*p).allocated64,(int64)1);
    (*p).mutable = (uint8)1u;
    (*p).length = (uint32)(length);
    (*p).lower = (int32)0;
    (*p).elemtag = (uint16)41u;
    return p;
}

struct pc_decls_objrec * pc_objects_make_bitsobj(int64 length,int64 elemtype,int64 lower) {
    struct pc_decls_objrec *  p;
    p = pc_objects_newobject();
    (*p).ptr = pc_objects_make_bitdata(length,elemtype,&(*p).allocated64,(int64)1);
    (*p).mutable = (uint8)1u;
    (*p).length = (uint32)(length);
    (*p).lower = (int32)(lower);
    (*p).elemtag = (uint16)(elemtype);
    return p;
}

void pc_objects_resize_listobj(struct pc_decls_objrec * p,int64 n) {
    struct pc_decls_varrec *  q;
    uint32 allocated;
    if ((n <= (int64)((*p).allocated))) {
        (*p).length = (uint32)(n);
        return;
    }
    q = pc_objects_make_listdata(n,&allocated,(int64)0);
    if (!!((*p).length)) {
        memcpy((void *)(q),(void *)((*p).vptr),(uint64)(((int64)((*p).length) * (int64)16)));
    }
    (*p).vptr = q;
    (*p).allocated = allocated;
    (*p).length = (uint32)(n);
}

void pc_objects_resize_arrayobj(struct pc_decls_objrec * p,int64 n) {
    struct pc_decls_varrec *  q;
    uint32 allocated;
    if ((n <= (int64)((*p).allocated))) {
        (*p).length = (uint32)(n);
        return;
    }
    q = pc_objects_make_arraydata(n,(int64)((*p).elemtag),&allocated,(int64)1);
    if (!!((*p).length)) {
        memcpy((void *)(q),(void *)((*p).vptr),(uint64)(((int64)((*p).length) * pc_decls_ttsize[((int64)((*p).elemtag))])));
        pc_objects_free_arraydata((*p).vptr,(int64)((*p).elemtag),(int64)((*p).allocated));
    }
    (*p).vptr = q;
    (*p).allocated = allocated;
    (*p).length = (uint32)(n);
}

void pc_objects_resize_bitsobj(struct pc_decls_objrec * p,int64 n) {
    byte *  q;
    uint64 allocated;
    if ((n <= (int64)((*p).allocated))) {
        (*p).length = (uint32)(n);
        return;
    }
    q = pc_objects_make_bitdata(n,(int64)((*p).elemtag),&allocated,(int64)1);
    if (!!((*p).length)) {
        memcpy((void *)(q),(void *)((*p).ptr),(uint64)(pc_objects_get_objbytes(p)));
        pc_objects_free_bitdata((*p).ptr,(int64)((*p).elemtag),(int64)((*p).allocated64));
    }
    (*p).ptr = q;
    (*p).allocated64 = allocated;
    (*p).length = (uint32)(n);
}

struct pc_decls_objrec * pc_objects_make_strslicexobj(byte * s,int64 length) {
    struct pc_decls_objrec *  p;
    if ((length == (int64)0)) {
        s = (byte *)(0);
    }
    p = pc_objects_newobject();
    (*p).strptr = s;
    (*p).mutable = (uint8)1u;
    (*p).length = (uint32)(length);
    (*p).objtype = (uint8)2u;
    return p;
}

struct pc_decls_objrec * pc_objects_copyonwrite(struct pc_decls_objrec * p,int64 tag) {
    struct pc_decls_objrec *  q;
    struct pc_decls_varrec v;
    if (!!((*p).mutable)) {
        return p;
    }
    v.tagx = (uint32)((tag + (int64)65536));
    v.objptr = p;
    pc_pcfns_pc_dupl(&v);
    q = v.objptr;
    (*q).mutable = (uint8)1u;
    return q;
}

int64 pc_objects_get_objbytes(struct pc_decls_objrec * p) {
    int64 elemtype;
    int64 nbits;
    elemtype = (int64)((*p).elemtag);
    if ((elemtype==(int64)41) || (elemtype==(int64)42) || (elemtype==(int64)43)) {
        nbits = (int64)((pc_decls_ttbitwidth[(elemtype)] * (int32)((*p).length)));
        if (!!((nbits & (int64)7))) {
            return ((nbits / (int64)8) + (int64)1);
        }
        else {
            return (nbits / (int64)8);
        }
    }
    return (pc_decls_ttsize[(elemtype)] * (int64)((*p).length));
}

void pc_bigint_bn_makestr(byte * s,int64 length,struct pc_decls_varrec * dest) {
    int64 base;
    if ((length == (int64)0)) {
        pc_support_pcerror((byte*)"bnmakestr");
    }
    base = (int64)10;
    if (((length > (int64)2) && ((int64)((*(s + (int64)1))) == (int64)120))) {
        switch ((int64)((*s))) {
        case 48:;
            base = (int64)16;
            break;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            base = ((int64)((*s)) - (int64)48);
            break;
        default:;
        }
    }
    if ((base == (int64)10)) {
        pc_bigint_bn_makeu(s,length,dest);
    }
    else {
        pc_bigint_bn_makeu_base((s + (int64)2),(length - (int64)2),dest,base);
    }
}

void pc_bigint_bn_makeint(int64 aa,struct pc_decls_varrec * dest) {
    byte s[100];
    int32 (*ptr)[];
    if ((abs(aa) < (int64)1000000)) {
        pc_bigint_makebigint((int64)1,dest);
        ptr = (*(*dest).objptr).bnptr;
        if ((aa >= (int64)0)) {
            (*ptr)[((int64)1)] = (int32)(aa);
            (*ptr)[((int64)0)] = (int32)0;
        }
        else {
            (*ptr)[((int64)1)] = (int32)(-(aa));
            (*ptr)[((int64)0)] = (int32)1;
        }
    }
    else {
        sprintf(s,(byte*)"%lld",aa);
        pc_bigint_bn_makestr(s,(int64)(strlen(s)),dest);
    }
}

static void pc_bigint_bn_makeu(byte * s,int64 nchars,struct pc_decls_varrec * bn) {
    int64 i;
    int64 ndigits;
    int64 n;
    int64 neg;
    struct pc_decls_objrec *  p;
    neg = (int64)0;
    if (((int64)((*s)) == (int64)45)) {
        ++s;
        --nchars;
        neg = (int64)1;
    }
    if ((nchars == (int64)0)) {
        pc_support_pcerror((byte*)"bnmakeu");
    }
    ndigits = (((nchars - (int64)1) / (int64)6) + (int64)1);
    pc_bigint_makebigint(ndigits,bn);
    p = (*bn).objptr;
    (*(*p).bnptr)[((int64)0)] = (int32)(neg);
    n = nchars;
    i = ndigits;
L368:;
    while ((n > (int64)0)) {
        if ((n >= (int64)6)) {
            (*(*p).bnptr)[(i)] = (int32)(pc_bigint_strvaln(((s + n) - (int64)6),(int64)6));
        }
        else {
            (*(*p).bnptr)[(i)] = (int32)(pc_bigint_strvaln(s,n));
        }
        --i;
        n -= (int64)6;
L369:;
    }
L370:;
    if (((ndigits == (int64)1) && ((int64)((*(*p).bnptr)[((int64)1)]) == (int64)0))) {
        (*(*p).bnptr)[((int64)0)] = (int32)0;
    }
}

void pc_bigint_bn_makeu_base(byte * s,int64 nchars,struct pc_decls_varrec * bn,int64 base) {
    int64 i;
    int64 ndigits;
    int64 n;
    int64 ch;
    int64 neg;
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec a;
    struct pc_decls_varrec b;
    struct pc_decls_varrec c;
    struct pc_decls_varrec vdigit;
    neg = (int64)0;
    if (((int64)((*s)) == (int64)45)) {
        ++s;
        --nchars;
        neg = (int64)1;
    }
    if ((nchars == (int64)0)) {
        pc_support_pcerror((byte*)"bnmakeub");
    }
    pc_bigint_bn_zero(&a);
L371:;
    while (!!((ch = (int64)((*s++))))) {
        pc_bigint_muldigit(&a,base,(int64)0,&b);
        pc_bigint_bn_makeint((ch - (int64)48),&vdigit);
        pc_bigint_bn_addu(&b,&vdigit,&c);
        pc_bigint_freebigint(&a);
        pc_bigint_freebigint(&b);
        pc_bigint_freebigint(&vdigit);
        a = c;
L372:;
    }
L373:;
    if (!!(neg)) {
        (*(*a.objptr).bnptr)[((int64)0)] = (int32)1;
    }
    (*bn) = a;
}

static int64 pc_bigint_strvaln(byte * s,int64 n) {
    int64 a;
    int64 av_1;
    a = (int64)0;
    av_1 = n;
    while (av_1-- > 0) {
L374:;
        a = (((a * (int64)10) + (int64)((*s))) - (int64)48);
        ++s;
L375:;
    }
L376:;
    return a;
}

static void pc_bigint_makebigint(int64 ndigits,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec l;
    int32 *  p;
    int64 i;
    l.tagx = (uint32)(((int64)7 | (int64)65536));
    l.objptr = pc_objects_make_arrayobj((ndigits + (int64)1),(int64)39,(int64)0);
    l.bndigits = (uint32)(ndigits);
    (*dest) = l;
}

void pc_bigint_freebigint(struct pc_decls_varrec * bn) {
    if (((int64)((*bn).tag) != (int64)0)) {
        pc_pcfns_pc_ufree(bn);
    }
}

void pc_bigint_bn_neg(struct pc_decls_varrec * bn) {
    struct pc_decls_objrec *  p;
    p = (*bn).objptr;
    if ((((int64)((*bn).bndigits) == (int64)1) && ((int64)((*(*p).bnptr)[((int64)1)]) == (int64)0))) {
        (*(*p).bnptr)[((int64)0)] = (int32)0;
    }
    else {
        (*(*p).bnptr)[((int64)0)] ^= (int32)1;
    }
}

void pc_bigint_bn_abs(struct pc_decls_varrec * bn) {
    (*(*(*bn).objptr).bnptr)[((int64)0)] = (int32)0;
}

void pc_bigint_bn_add(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    int64 nega;
    int64 negb;
    nega = (int64)((*(*(*a).objptr).bnptr)[((int64)0)]);
    negb = (int64)((*(*(*b).objptr).bnptr)[((int64)0)]);
    if ((!(!!(nega)) && !(!!(negb)))) {
        pc_bigint_bn_addu(a,b,c);
        return;
    }
    if ((!!(nega) && !!(negb))) {
        pc_bigint_bn_addu(a,b,c);
        (*(*(*c).objptr).bnptr)[((int64)0)] = (int32)1;
        return;
    }
    if ((!(!!(nega)) && !!(negb))) {
        pc_bigint_bn_subu(a,b,c);
        return;
    }
    pc_bigint_bn_subu(b,a,c);
}

static void pc_bigint_bn_addu(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    int64 da;
    int64 db;
    int64 d;
    int64 aoffset;
    int64 boffset;
    int64 i;
    int64 ia;
    int64 ib;
    int64 carry;
    int64 sum;
    struct pc_decls_varrec e;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    struct pc_decls_objrec *  pc;
    struct pc_decls_objrec *  pe;
    pa = (*a).objptr;
    pb = (*b).objptr;
    da = (int64)((*a).bndigits);
    db = (int64)((*b).bndigits);
    if ((da == db)    ) {
        d = da;
        aoffset = (boffset = (int64)0);
    }
    else if ((da > db)) {
        d = da;
        aoffset = (int64)0;
        boffset = (db - da);
    }
    else {
        d = db;
        aoffset = (da - db);
        boffset = (int64)0;
    }
    pc_bigint_makebigint(d,c);
    pc = (*c).objptr;
    carry = (int64)0;
L377:;
    for (i=d;i>=(int64)1;--i) {
L378:;
        ia = (i + aoffset);
        ib = (i + boffset);
        if (((ia >= (int64)1) && (ib >= (int64)1))        ) {
            sum = ((int64)(((*(*pa).bnptr)[(ia)] + (*(*pb).bnptr)[(ib)])) + carry);
        }
        else if ((ia < (int64)1)) {
            sum = ((int64)((*(*pb).bnptr)[(ib)]) + carry);
        }
        else {
            sum = ((int64)((*(*pa).bnptr)[(ia)]) + carry);
        }
        if ((sum < (int64)1000000)) {
            carry = (int64)0;
            (*(*pc).bnptr)[(i)] = (int32)(sum);
        }
        else {
            carry = (int64)1;
            (*(*pc).bnptr)[(i)] = (int32)((sum - (int64)1000000));
        }
L379:;
    }
L380:;
    if (!!(carry)) {
        pc_bigint_makebigint((d + (int64)1),&e);
        pe = e.objptr;
L381:;
        for (i=(int64)1;i<=d;++i) {
L382:;
            (*(*pe).bnptr)[((i + (int64)1))] = (*(*pc).bnptr)[(i)];
L383:;
        }
L384:;
        (*(*pe).bnptr)[((int64)1)] = (int32)1;
        (*(*pe).bnptr)[((int64)0)] = (int32)0;
        pc_bigint_freebigint(c);
        (*c) = e;
        return;
    }
    (*(*pc).bnptr)[((int64)0)] = (int32)0;
}

void pc_bigint_bn_sub(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    int64 nega;
    int64 negb;
    nega = (int64)((*(*(*a).objptr).bnptr)[((int64)0)]);
    negb = (int64)((*(*(*b).objptr).bnptr)[((int64)0)]);
    if ((!(!!(nega)) && !(!!(negb)))) {
        pc_bigint_bn_subu(a,b,c);
        return;
    }
    if ((!!(nega) && !!(negb))) {
        pc_bigint_bn_subu(b,a,c);
        return;
    }
    if ((!(!!(nega)) && !!(negb))) {
        pc_bigint_bn_addu(a,b,c);
        return;
    }
    pc_bigint_bn_subu(a,b,c);
    (*(*(*c).objptr).bnptr)[((int64)0)] = (int32)1;
}

static void pc_bigint_bn_subu(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    int64 da;
    int64 db;
    int64 minus;
    int64 d;
    int64 carry;
    int64 diff;
    int64 aoffset;
    int64 boffset;
    int64 i;
    int64 ia;
    int64 ib;
    int64 z;
    struct pc_decls_varrec e;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    struct pc_decls_objrec *  pc;
    struct pc_decls_objrec *  pe;
    int64 av_1;
    int64 av_2;
    pa = (*a).objptr;
    pb = (*b).objptr;
    da = (int64)((*a).bndigits);
    db = (int64)((*b).bndigits);
    minus = (int64)0;
    if ((da == db)    ) {
        d = da;
        aoffset = (boffset = (int64)0);
        pc_bigint_makebigint(da,c);
    }
    else if ((da > db)) {
        d = da;
        aoffset = (int64)0;
        boffset = (db - da);
        pc_bigint_makebigint(da,c);
    }
    else {
        aoffset = (da - db);
        pc_bigint_makebigint(db,c);
        pc = (*c).objptr;
        goto L385;
    }
    pc = (*c).objptr;
    carry = (int64)0;
L386:;
    for (i=d;i>=(int64)1;--i) {
L387:;
        ib = (i + boffset);
        if ((ib >= (int64)1)) {
            diff = ((int64)(((*(*pa).bnptr)[(i)] - (*(*pb).bnptr)[(ib)])) - carry);
        }
        else {
            diff = ((int64)((*(*pa).bnptr)[(i)]) - carry);
        }
        if ((diff < (int64)0)) {
            carry = (int64)1;
            (*(*pc).bnptr)[(i)] = (int32)((diff + (int64)1000000));
        }
        else {
            carry = (int64)0;
            (*(*pc).bnptr)[(i)] = (int32)(diff);
        }
L388:;
    }
L389:;
    if (!!(carry)) {
//doreverse:
L385:;
        carry = (int64)0;
        minus = (int64)1;
        d = db;
        aoffset = (da - db);
L390:;
        for (i=d;i>=(int64)1;--i) {
L391:;
            ia = (i + aoffset);
            if ((ia >= (int64)1)) {
                diff = ((int64)(((*(*pb).bnptr)[(i)] - (*(*pa).bnptr)[(ia)])) - carry);
            }
            else {
                diff = ((int64)((*(*pb).bnptr)[(i)]) - carry);
            }
            if ((diff < (int64)0)) {
                carry = (int64)1;
                (*(*pc).bnptr)[(i)] = (int32)((diff + (int64)1000000));
            }
            else {
                carry = (int64)0;
                (*(*pc).bnptr)[(i)] = (int32)(diff);
            }
L392:;
        }
L393:;
    }
    z = (int64)0;
L394:;
    for (i=(int64)1;i<=((int64)((*c).bndigits) - (int64)1);++i) {
L395:;
        if (!!((*(*pc).bnptr)[(i)])) {
            goto L397;
        }
        ++z;
L396:;
    }
L397:;
    if (!!(z)) {
        pc_bigint_makebigint(((int64)((*c).bndigits) - z),&e);
        pe = e.objptr;
L398:;
        for (i=(int64)1;i<=(int64)(e.bndigits);++i) {
L399:;
            (*(*pe).bnptr)[(i)] = (*(*pc).bnptr)[((i + z))];
L400:;
        }
L401:;
        (*(*pe).bnptr)[((int64)0)] = (int32)(minus);
        pc_bigint_freebigint(c);
        (*c) = e;
        return;
    }
    (*(*pc).bnptr)[((int64)0)] = (int32)(minus);
}

void pc_bigint_bn_mul(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    struct pc_decls_objrec *  pc;
    pa = (*a).objptr;
    pb = (*b).objptr;
    if (((*(*pa).bnptr)[((int64)0)] != (*(*pb).bnptr)[((int64)0)])) {
        pc_bigint_bn_mulu(a,b,c);
        pc = (*c).objptr;
        if ((((int64)((*c).bndigits) > (int64)1) || !!((*(*pc).bnptr)[((int64)1)]))) {
            (*(*pc).bnptr)[((int64)0)] = (int32)0;
        }
        return;
    }
    pc_bigint_bn_mulu(a,b,c);
}

void pc_bigint_muldigit(struct pc_decls_varrec * a,int64 b,int64 d,struct pc_decls_varrec * c) {
    int64 i;
    int64 alen;
    int64 p;
    int64 carry;
    int64 nb;
    struct pc_decls_varrec e;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pc;
    struct pc_decls_objrec *  pe;
    int64 av_1;
    int64 av_2;
    pa = (*a).objptr;
    nb = b;
    alen = (int64)((*a).bndigits);
    if ((nb == (int64)0)) {
        pc_bigint_bn_zero(c);
        return;
    }
    if ((nb == (int64)1)) {
        if ((d == (int64)0)) {
            (*c) = (*a);
            if (!!((*c).hasref)) {
                pc_pcfns_pc_ushare(c);
            }
            return;
        }
        pc_bigint_makebigint((alen + d),c);
        pc = (*c).objptr;
        (*(*pc).bnptr)[((int64)0)] = (int32)0;
L402:;
        for (i=(int64)1;i<=alen;++i) {
L403:;
            (*(*pc).bnptr)[(i)] = (*(*pa).bnptr)[(i)];
L404:;
        }
L405:;
L406:;
        for (i=(alen + (int64)1);i<=(alen + d);++i) {
L407:;
            (*(*pc).bnptr)[(i)] = (int32)0;
L408:;
        }
L409:;
        return;
    }
    pc_bigint_makebigint(((alen + d) + (int64)1),c);
    pc = (*c).objptr;
    carry = (int64)0;
L410:;
    for (i=alen;i>=(int64)1;--i) {
L411:;
        p = (((int64)((*(*pa).bnptr)[(i)]) * nb) + carry);
        (*(*pc).bnptr)[((i + (int64)1))] = (int32)((p % (int64)1000000));
        carry = (p / (int64)1000000);
L412:;
    }
L413:;
    (*(*pc).bnptr)[((int64)1)] = (int32)(carry);
    if (((int64)((*(*pc).bnptr)[((int64)1)]) == (int64)0)) {
        pc_bigint_makebigint(((int64)((*c).bndigits) - (int64)1),&e);
        pe = e.objptr;
L414:;
        for (i=(int64)1;i<=(int64)(e.bndigits);++i) {
L415:;
            (*(*pe).bnptr)[(i)] = (*(*pc).bnptr)[((i + (int64)1))];
L416:;
        }
L417:;
        pc_bigint_freebigint(c);
        (*c) = e;
        return;
    }
}

static void pc_bigint_bn_zero(struct pc_decls_varrec * bn) {
    pc_bigint_makebigint((int64)1,bn);
}

void pc_bigint_bn_mulu(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    int64 awords;
    int64 bwords;
    int64 cwords;
    int64 ax;
    int64 bx;
    int64 cx;
    int64 i;
    int64 cx1;
    int64 p;
    int64 carry;
    int64 x;
    struct pc_decls_varrec d;
    int64 pdquot;
    int64 pdrem;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    struct pc_decls_objrec *  pc;
    struct pc_decls_objrec *  pd;
    int64 av_1;
    pa = (*a).objptr;
    pb = (*b).objptr;
    awords = (int64)((*a).bndigits);
    bwords = (int64)((*b).bndigits);
    cwords = (awords + bwords);
    pc_bigint_makebigint(cwords,c);
    pc = (*c).objptr;
    cx = cwords;
L418:;
    for (bx=bwords;bx>=(int64)1;--bx) {
L419:;
        carry = (int64)0;
        cx1 = cx;
L422:;
        for (ax=awords;ax>=(int64)1;--ax) {
L423:;
            p = (((int64)((*(*pa).bnptr)[(ax)]) * (int64)((*(*pb).bnptr)[(bx)])) + carry);
            pdquot = (p / (int64)1000000);
            x = ((int64)((*(*pc).bnptr)[(cx1)]) + (p % (int64)1000000));
            if ((x > (int64)999999)) {
                carry = (pdquot + (x / (int64)1000000));
                (*(*pc).bnptr)[(cx1--)] = (int32)((x % (int64)1000000));
            }
            else {
                carry = pdquot;
                (*(*pc).bnptr)[(cx1--)] = (int32)(x);
            }
L424:;
        }
L425:;
        (*(*pc).bnptr)[(cx1)] = (int32)(carry);
        --cx;
L420:;
    }
L421:;
    if (((int64)((*(*pc).bnptr)[((int64)1)]) == (int64)0)) {
        pc_bigint_makebigint((cwords - (int64)1),&d);
        pd = d.objptr;
L426:;
        for (i=(int64)1;i<=(int64)(d.bndigits);++i) {
L427:;
            (*(*pd).bnptr)[(i)] = (*(*pc).bnptr)[((i + (int64)1))];
L428:;
        }
L429:;
        pc_bigint_freebigint(c);
        (*c) = d;
        return;
    }
}

void pc_bigint_bn_div(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    struct pc_decls_objrec *  pc;
    pa = (*a).objptr;
    pb = (*b).objptr;
    if (((*(*pa).bnptr)[((int64)0)] != (*(*pb).bnptr)[((int64)0)])) {
        pc_bigint_bn_divu(a,b,c);
        pc = (*c).objptr;
        if ((((int64)((*c).bndigits) > (int64)1) || !!((*(*pc).bnptr)[((int64)1)]))) {
            (*(*pc).bnptr)[((int64)0)] = (int32)0;
        }
        return;
    }
    pc_bigint_bn_divu(a,b,c);
}

void pc_bigint_bn_divu(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    int64 na;
    int64 nb;
    int64 k;
    int64 n;
    int64 i;
    int64 clen;
    int64 xx;
    int64 y;
    struct pc_decls_varrec x;
    struct pc_decls_varrec e;
    struct pc_decls_varrec f;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    struct pc_decls_objrec *  pc;
    static struct pc_decls_objrec *  pe = 0;
    static struct pc_decls_objrec *  px = 0;
    int64 av_1;
    int64 av_2;
    int64 av_3;
    pa = (*a).objptr;
    pb = (*b).objptr;
    if ((((int64)((*b).bndigits) == (int64)1) && ((int64)((*(*pb).bnptr)[((int64)1)]) == (int64)0))) {
        pc_bigint_bn_zero(c);
        return;
    }
    if ((((int64)((*b).bndigits) == (int64)1) && ((int64)((*(*pb).bnptr)[((int64)1)]) == (int64)1))) {
        (*c) = (*a);
        if (!!((*c).hasref)) {
            pc_pcfns_pc_ushare(c);
        }
        return;
    }
    na = (int64)((*a).bndigits);
    nb = (int64)((*b).bndigits);
    if ((nb > na)) {
        pc_bigint_bn_zero(c);
        return;
    }
    n = nb;
    pc_bigint_makebigint(n,&x);
    px = x.objptr;
    e.tagx = (uint32)0u;
L430:;
    for (i=(int64)0;i<=n;++i) {
L431:;
        (*(*px).bnptr)[(i)] = (*(*pa).bnptr)[(i)];
L432:;
    }
L433:;
    pc_bigint_makebigint(na,c);
    pc = (*c).objptr;
    clen = (int64)0;
L434:;
    while (1) {
        k = (int64)0;
L436:;
        while (1) {
            if (((int64)(x.bndigits) < nb)            ) {
                goto L437;
            }
            else if (((int64)(x.bndigits) > nb)) {
                xx = (((int64)((*(*px).bnptr)[((int64)1)]) * (int64)1000000) + (int64)((*(*px).bnptr)[((int64)2)]));
                y = (xx / ((int64)((*(*pb).bnptr)[((int64)1)]) + (int64)1));
            }
            else {
                if (((int64)((*(*px).bnptr)[((int64)1)]) >= ((int64)((*(*pb).bnptr)[((int64)1)]) + (int64)1))) {
                    y = ((int64)((*(*px).bnptr)[((int64)1)]) / ((int64)((*(*pb).bnptr)[((int64)1)]) + (int64)1));
                }
                else {
                    y = (int64)1;
L438:;
                    for (i=(int64)1;i<=nb;++i) {
L439:;
                        if (((*(*px).bnptr)[(i)] < (*(*pb).bnptr)[(i)])                        ) {
                            y = (int64)0;
                            goto L442;
                        }
                        else if (((*(*px).bnptr)[(i)] > (*(*pb).bnptr)[(i)])) {
                            goto L441;
                        }
L440:;
                    }
L441:;
                }
            }
            k += y;
            if ((y > (int64)1)) {
                pc_bigint_muldigit(b,y,(int64)0,&e);
                pc_bigint_bn_subu(&x,&e,&f);
                pc_bigint_freebigint(&e);
                pc_bigint_freebigint(&x);
                x = f;
                f.tag = (uint16)0u;
            }
            else {
                pc_bigint_bn_subu(&x,b,&f);
                pc_bigint_freebigint(&x);
                x = f;
                f.tag = (uint16)0u;
            }
            px = x.objptr;
        }
L437:;
//exit2:
L442:;
        ++clen;
        (*(*pc).bnptr)[(clen)] = (int32)(k);
        if ((n == na)) {
            goto L435;
        }
        ++n;
        if ((((int64)(x.bndigits) == (int64)1) && ((int64)((*(*px).bnptr)[((int64)1)]) == (int64)0))) {
            (*(*px).bnptr)[((int64)1)] = (*(*pa).bnptr)[(n)];
        }
        else {
            pc_bigint_makebigint(((int64)(x.bndigits) + (int64)1),&e);
            pe = e.objptr;
L443:;
            for (i=(int64)0;i<=(int64)(x.bndigits);++i) {
L444:;
                (*(*pe).bnptr)[(i)] = (*(*px).bnptr)[(i)];
L445:;
            }
L446:;
            (*(*pe).bnptr)[((int64)(e.bndigits))] = (*(*pa).bnptr)[(n)];
            pc_bigint_freebigint(&x);
            x = e;
            px = e.objptr;
            e.tag = (uint16)0u;
        }
    }
L435:;
    pc_bigint_freebigint(&e);
    pc_bigint_freebigint(&x);
    if ((clen == (int64)0)) {
        pc_bigint_freebigint(c);
        pc_bigint_bn_zero(c);
        return;
    }
    if (((clen > (int64)1) && ((int64)((*(*pc).bnptr)[((int64)1)]) == (int64)0))) {
        pc_bigint_makebigint((clen - (int64)1),&e);
        pe = e.objptr;
L447:;
        for (i=(int64)1;i<=(int64)(e.bndigits);++i) {
L448:;
            (*(*pe).bnptr)[(i)] = (*(*pc).bnptr)[((i + (int64)1))];
L449:;
        }
L450:;
    }
    else {
        pc_bigint_makebigint(clen,&e);
        pe = e.objptr;
L451:;
        for (i=(int64)1;i<=(int64)(e.bndigits);++i) {
L452:;
            (*(*pe).bnptr)[(i)] = (*(*pc).bnptr)[(i)];
L453:;
        }
L454:;
    }
    pc_bigint_freebigint(c);
    (*c) = e;
}

int64 pc_bigint_bn_equal(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    int64 i;
    int64 n;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    pa = (*a).objptr;
    pb = (*b).objptr;
    n = (int64)((*a).bndigits);
    if ((n != (int64)((*b).bndigits))) {
        return (int64)0;
    }
L455:;
    for (i=(int64)0;i<=n;++i) {
L456:;
        if (((*(*pa).bnptr)[(i)] != (*(*pb).bnptr)[(i)])) {
            return (int64)0;
        }
L457:;
    }
L458:;
    return (int64)1;
}

int64 pc_bigint_bn_cmp(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    int64 i;
    struct pc_decls_varrec c;
    if ((pc_bigint_bn_equal(a,b) == (int64)1)) {
        return (int64)0;
    }
    pc_bigint_bn_sub(a,b,&c);
    if (!!((*(*c.objptr).bnptr)[((int64)0)])) {
        pc_bigint_freebigint(&c);
        return (int64)-1;
    }
    pc_bigint_freebigint(&c);
    return (int64)1;
}

int64 pc_bigint_bn_int(struct pc_decls_varrec * a) {
    int64 i;
    int64 x;
    struct pc_decls_objrec *  pa;
    int64 av_1;
    pa = (*a).objptr;
    x = (int64)0;
L459:;
    for (i=(int64)0;i<=(int64)((*a).bndigits);++i) {
L460:;
        x = ((x * (int64)1000000) + (int64)((*(*pa).bnptr)[(i)]));
L461:;
    }
L462:;
    if (!!((*(*pa).bnptr)[((int64)0)])) {
        return -(x);
    }
    return x;
}

int64 pc_bigint_bn_digits(struct pc_decls_varrec * bn) {
    byte s[31];
    sprintf(s,(byte*)"%d",(*(*(*bn).objptr).bnptr)[((int64)1)]);
    return ((int64)(strlen(s)) + (((int64)((*bn).bndigits) - (int64)1) * (int64)6));
}

void pc_bigint_bn_power(struct pc_decls_varrec * a,int64 n,struct pc_decls_varrec * dest) {
    struct pc_decls_varrec e;
    struct pc_decls_varrec f;
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pdest;
    pa = (*a).objptr;
    if ((n < (int64)0)    ) {
        pc_bigint_bn_zero(dest);
    }
    else if ((n == (int64)0)) {
        pc_bigint_bn_zero(dest);
        (*(*(*dest).objptr).bnptr)[((int64)1)] = (int32)1;
    }
    else if ((n == (int64)1)) {
        (*dest) = (*a);
        if (!!((*dest).hasref)) {
            pc_pcfns_pc_ushare(dest);
        }
    }
    else if (((n & (int64)1) == (int64)0)) {
        pc_bigint_bn_mul(a,a,&e);
        pc_bigint_bn_power(&e,(n / (int64)2),dest);
        pc_bigint_freebigint(&e);
    }
    else {
        pc_bigint_bn_mul(a,a,&e);
        pc_bigint_bn_power(&e,((n - (int64)1) / (int64)2),&f);
        pc_bigint_freebigint(&e);
        pc_bigint_bn_mul(a,&f,dest);
        pc_bigint_freebigint(&f);
    }
}

void pc_bigint_bn_reduce(struct pc_decls_varrec * bn) {
    struct pc_decls_objrec *  p;
    int64 a;
    p = (*bn).objptr;
    if (((int64)((*p).length) == (int64)2)) {
        a = (int64)((*(*p).bnptr)[((int64)1)]);
        if (!!((*(*p).bnptr)[((int64)0)])) {
            a = -(a);
        }
        pc_bigint_freebigint(bn);
        (*bn).tagx = (uint32)1u;
        (*bn).value = a;
    }
}

void pc_print_pch_print(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt) {
    byte str[1024];
    struct pc_decls_varrec v;
    struct pc_decls_varrec emptyfmt;
    if ((fmt == 0)) {
        fmt = &emptyfmt;
        emptyfmt.tagx = (uint32)0u;
    }
    if ((pc_print_mfmtstr == 0)) {
        if (!!(pc_print_mgapneeded)) {
            pc_print_printstr_n((byte*)" ",(int64)1);
        }
        else {
            pc_print_mgapneeded = (uint8)1u;
        }
    }
    else {
        pc_print_printnextfmtchars((int64)0);
    }
    switch ((int64)(pc_decls_ttbasetype[((int64)((*p).tag))])) {
    case 5:;
        if (((fmt == 0) || ((int64)((*fmt).tag) == (int64)0))) {
            pc_print_printstr_n((*(*p).objptr).ptr,(int64)((*(*p).objptr).length));
            return;
        }
        break;
    case 1:;
    case 3:;
    case 4:;
    case 2:;
        pc_print_pch_tostr(p,fmt,&v);
        pc_print_printstr_n((*v.objptr).strptr,(int64)((*v.objptr).length));
        return;
        break;
    default:;
    }
    pc_print_pch_tostr(p,fmt,&v);
    pc_print_printstr_n((*v.objptr).strptr,(int64)((*v.objptr).length));
}

void pc_print_pch_println(void) {
    if (!!(pc_print_mfmtstr)) {
        pc_print_printnextfmtchars((int64)1);
    }
    pc_print_printstrz((byte*)"\r\n");
}

void pc_print_pch_startprintcon(void) {
    struct pc_decls_varrec v;
    v.tagx = (uint32)1u;
    v.value = (int64)0;
    pc_print_pch_startprint(&v);
}

void pc_print_pch_startprint(struct pc_decls_varrec * p) {
    struct pc_decls_objrec *  s;
    switch (++pc_print_noclevels) {
    case 0:;
    case 1:;
        break;
    case 7:;
        pc_print_printerror((byte*)"print #x overflow");
        break;
    default:;
        pc_print_moutdevstack[((pc_print_noclevels - (int64)1))] = (int32)(pc_print_moutdev);
        pc_print_moutchanstack[((pc_print_noclevels - (int64)1))] = pc_print_moutchan;
        pc_print_moutvarstack[((pc_print_noclevels - (int64)1))] = pc_print_moutvar;
        pc_print_mfmtstrstack[((pc_print_noclevels - (int64)1))] = pc_print_mfmtstr;
        pc_print_mfmtcurrstack[((pc_print_noclevels - (int64)1))] = pc_print_mfmtcurr;
        pc_print_mgapstack[((pc_print_noclevels - (int64)1))] = pc_print_mgapneeded;
    }
    pc_print_mfmtstr = (byte *)(0);
    pc_print_mfmtcurr = (byte *)(0);
    if ((p == 0)) {
        goto L463;
    }
    switch ((int64)((*p).tag)) {
    case 1:;
        switch ((*p).value) {
        case 0:;
//doconsole:
L463:;
            pc_print_moutdev = (int64)0;
            pc_print_moutchan = 0;
            break;
        case 1:;
            pc_print_moutdev = (int64)2;
            pc_print_moutchan = 0;
            pc_print_moutvar.tagx = (uint32)(((int64)5 | (int64)65536));
            s = pc_objects_newobject();
            (*s).mutable = (uint8)1u;
            (*s).length = (uint32)0u;
            (*s).elemtag = (uint16)44u;
            pc_print_moutvar.objptr = s;
            break;
        case 2:;
            if ((pc_print_testfilech == 0)) {
                pc_support_prterror((byte*)"@2: file not open");
            }
            pc_print_moutdev = (int64)1;
            pc_print_moutchan = pc_print_testfilech;
            break;
        default:;
            pc_print_moutdev = (int64)1;
            pc_print_moutchan = (void *)((*p).value);
        }
        break;
    case 22:;
        p = (*p).varptr;
        switch ((int64)((*p).tag)) {
        case 5:;
            pc_print_moutdev = (int64)4;
            pc_print_moutchan = 0;
            pc_print_moutvar.tagx = (uint32)22u;
            pc_print_moutvar.varptr = p;
            break;
        default:;
            printf("%s\n",(char*)(pc_decls_ttname[((int64)((*p).tag))]));
            pc_support_prterror((byte*)"Print@^?");
        }
        break;
    default:;
        switch ((int64)(pc_decls_ttbasetype[((int64)((*p).tag))])) {
        case 32:;
        case 33:;
            pc_print_moutdev = (int64)0;
            break;
        default:;
            printf("%s\n",(char*)(pc_decls_ttname[((int64)((*p).tag))]));
            pc_print_printerror((byte*)"Can't do startprint...");
        }
    }
    pc_print_mgapneeded = (uint8)0u;
}

void pc_print_pch_endprint(void) {
    struct pc_decls_varrec *  p;
    if (!!(pc_print_mfmtstr)) {
        pc_print_printnextfmtchars((int64)1);
    }
    switch (pc_print_moutdev) {
    case 4:;
        p = pc_print_moutvar.varptr;
        break;
    default:;
    }
    if ((pc_print_mfmtstr != 0)) {
        mlib_pcm_free((void *)(pc_print_mfmtstr),((int64)(strlen(pc_print_mfmtstr)) + (int64)1));
    }
    if ((--pc_print_noclevels == (int64)-1)) {
        pc_print_printerror((byte*)"resetoc??");
    }
    if ((pc_print_noclevels == (int64)0)) {
        pc_print_moutdev = (int64)0;
    }
    else {
        pc_print_moutdev = (int64)(pc_print_moutdevstack[(pc_print_noclevels)]);
        pc_print_moutchan = pc_print_moutchanstack[(pc_print_noclevels)];
        pc_print_moutvar = pc_print_moutvarstack[(pc_print_noclevels)];
        pc_print_mgapneeded = pc_print_mgapstack[(pc_print_noclevels)];
        pc_print_mfmtstr = pc_print_mfmtstrstack[(pc_print_noclevels)];
        pc_print_mfmtcurr = pc_print_mfmtcurrstack[(pc_print_noclevels)];
    }
}

void pc_print_pch_strstartprint(void) {
    struct pc_decls_varrec p;
    p.tagx = (uint32)1u;
    p.value = (int64)1;
    pc_print_pch_startprint(&p);
}

void pc_print_pch_strendprint(struct pc_decls_varrec * dest) {
    if (!!(pc_print_mfmtstr)) {
        pc_print_printnextfmtchars((int64)1);
    }
    if ((pc_print_moutdev != (int64)2)) {
        pc_support_prterror((byte*)"STRendPRT/NOT STR");
    }
    (*dest) = pc_print_moutvar;
    pc_print_moutvar.tagx = (uint32)0u;
    pc_print_pch_endprint();
}

void pc_print_pch_setformat(struct pc_decls_varrec * p) {
    int64 n;
    byte *  s;
    if (((int64)((*p).tag) != (int64)5)) {
        pc_support_prterror((byte*)"(str)");
    }
    if (!!(pc_print_mfmtstr)) {
        pc_support_prterror((byte*)"Setfmt?");
    }
    n = (int64)((*(*p).objptr).length);
    pc_print_mfmtstr = (byte *)(mlib_pcm_alloc((n + (int64)1)));
    if (!!(n)) {
        memcpy((void *)(pc_print_mfmtstr),(void *)((*(*p).objptr).ptr),(uint64)(n));
    }
    s = (pc_print_mfmtstr + n);
    (*s) = (uint8)0u;
    pc_print_mfmtcurr = pc_print_mfmtstr;
}

void pc_print_pch_setformat2(struct pc_decls_varrec * p) {
    printf("%s\n",(char*)((byte*)"PC/SETFORMAT2"));
}

void pc_print_pch_dprint(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt) {
    pc_print_pch_print(p,fmt);
    switch ((int64)((*p).tag)) {
    case 1:;
        pc_print_printstrz((byte*)"d");
        break;
    case 2:;
        pc_print_printstrz((byte*)"u");
        break;
    default:;
    }
}

void pc_print_pch_printnogap(void) {
    pc_print_mgapneeded = (uint8)0u;
}

static void pc_print_initfmtcode(struct pc_decls_fmtrec * f) {
    (*f) = pc_print_defaultfmt;
}

static int64 pc_print_i64mintostr(byte * s,int64 base,int64 sep) {
    byte t[1024];
    int64 i;
    int64 j;
    int64 k;
    int64 g;
    int64 neg;
    switch (base) {
    case 10:;
        strcpy(&t[((int64)0)],(byte*)"9223372036854775808");
        j = (int64)3;
        break;
    case 16:;
        strcpy(&t[((int64)0)],(byte*)"8000000000000000");
        j = (int64)1;
        break;
    case 2:;
        strcpy(&t[((int64)0)],(byte*)"1000000000000000000000000000000000000000000000000000000000000000");
        j = (int64)7;
        break;
    default:;
        strcpy(&t[((int64)0)],(byte*)"<mindint>");
    }
    i = (int64)(strlen(&t[((int64)0)]));
    s += i;
    if (!!(sep)) {
        s += j;
    }
    (*s) = (uint8)0u;
    k = (int64)0;
    g = ((base == (int64)10)?(int64)3:(int64)4);
L464:;
    while (!!(i)) {
        --s;
        (*s) = t[((i-- - (int64)1))];
        if (((!!(sep) && !!(i)) && (++k == g))) {
            --s;
            (*s) = (byte)(sep);
            k = (int64)0;
        }
L465:;
    }
L466:;
    return (int64)(strlen(s));
}

static int64 pc_print_u64tostr(uint64 aa,byte * s,uint64 base,int64 sep) {
    byte t[1024];
    int64 i;
    int64 j;
    int64 k;
    int64 g;
    int64 dummy;
    byte *  s0;
    i = (int64)0;
    k = (int64)0;
    g = (((int64)(base) == (int64)10)?(int64)3:(int64)4);
L467:;
    do {
        t[(++i)] = pc_print_digits[((int64)((aa % base)))];
        aa = (aa / base);
        if (((!!(sep) && ((int64)(aa) != (int64)0)) && (++k == g))) {
            t[(++i)] = (byte)(sep);
            k = (int64)0;
        }
L468:;
    } while (!((int64)(aa) == (int64)0));;
L469:;
    j = i;
    s0 = s;
L470:;
    while (!!(i)) {
        (*s) = t[(i--)];
        ++s;
L471:;
    }
L472:;
    (*s) = (uint8)0u;
    return j;
}

static int64 pc_print_i64tostrfmt(int64 aa,byte * s,struct pc_decls_fmtrec * fmt,int64 usigned) {
    byte str[1024];
    int64 i;
    int64 j;
    int64 k;
    int64 n;
    int64 w;
    static uint64 mindint = (uint64)9223372036854775808u;
    if (!!((*fmt).usigned)) {
        usigned = (int64)1;
    }
    if (((aa == (int64)(mindint)) && !(!!(usigned)))) {
        str[((int64)0)] = (uint8)45u;
        n = (pc_print_i64mintostr(&str[((int64)1)],(int64)((*fmt).base),(int64)((*fmt).sepchar)) + (int64)1);
    }
    else {
        if (((!(!!(usigned)) && (aa < (int64)0)) || !!((*fmt).plus))) {
            if ((aa < (int64)0)) {
                aa = -(aa);
                str[((int64)0)] = (uint8)45u;
            }
            else {
                str[((int64)0)] = (uint8)43u;
            }
            n = (pc_print_u64tostr((uint64)(aa),&str[((int64)1)],(uint64)((*fmt).base),(int64)((*fmt).sepchar)) + (int64)1);
        }
        else {
            n = pc_print_u64tostr((uint64)(aa),str,(uint64)((*fmt).base),(int64)((*fmt).sepchar));
        }
    }
    if (!!((*fmt).suffix)) {
        str[(n)] = (*fmt).suffix;
        str[(++n)] = (uint8)0u;
    }
    if ((((int64)((*fmt).base) > (int64)10) || (!!((*fmt).suffix) && ((int64)((*fmt).lettercase) == (int64)97)))) {
        mlib_convlcstring(str);
    }
    return pc_print_expandstr(str,s,n,fmt);
}

static int64 pc_print_u64tostrfmt(int64 aa,byte * s,struct pc_decls_fmtrec * fmt) {
    byte str[1024];
    int64 i;
    int64 j;
    int64 k;
    int64 n;
    int64 w;
    n = pc_print_u64tostr((uint64)(aa),str,(uint64)((*fmt).base),(int64)((*fmt).sepchar));
    if (!!((*fmt).suffix)) {
        str[(n)] = (*fmt).suffix;
        str[(++n)] = (uint8)0u;
    }
    if ((((int64)((*fmt).base) > (int64)10) || (!!((*fmt).suffix) && ((int64)((*fmt).lettercase) == (int64)97)))) {
        mlib_convlcstring(str);
    }
    return pc_print_expandstr(str,s,n,fmt);
}

static int64 pc_print_strtostrfmt(byte * s,byte * t,int64 n,struct pc_decls_fmtrec * fmt) {
    byte *  u;
    byte *  v;
    byte str[256];
    int64 w;
    int64 nheap;
    nheap = (int64)0;
    if ((!!((*fmt).quotechar) || !!((*fmt).lettercase))) {
        if ((n < (int64)256)) {
            u = str;
        }
        else {
            nheap = (n + (int64)3);
            u = (byte *)(mlib_pcm_alloc(nheap));
        }
        if (!!((*fmt).quotechar)) {
            v = u;
            (*v) = (*fmt).quotechar;
            ++v;
            if (!!(n)) {
                strcpy(v,s);
                v += n;
            }
            (*v) = (*fmt).quotechar;
            ++v;
            (*v) = (uint8)0u;
            n += (int64)2;
        }
        switch ((int64)((*fmt).lettercase)) {
        case 97:;
            mlib_convlcstring(u);
            break;
        case 65:;
            mlib_convucstring(u);
            break;
        default:;
        }
        s = u;
    }
    w = (int64)((*fmt).minwidth);
    if ((w > n)) {
        n = pc_print_expandstr(s,t,n,fmt);
    }
    else {
        memcpy((void *)(t),(void *)(s),(uint64)(n));
    }
    if (!!(nheap)) {
        mlib_pcm_free((void *)(u),nheap);
    }
    return n;
}

static int64 pc_print_expandstr(byte * s,byte * t,int64 n,struct pc_decls_fmtrec * fmt) {
    int64 i;
    int64 w;
    int64 m;
    int64 av_1;
    int64 av_2;
    int64 av_3;
    int64 av_4;
    int64 av_5;
    w = (int64)((*fmt).minwidth);
    if (((w == (int64)0) || (w <= n))) {
        strncpy(t,s,(uint64)(n));
        (*(t + n)) = (uint8)0u;
        return n;
    }
    if (((int64)((*fmt).justify) == (int64)76)    ) {
        strncpy(t,s,(uint64)(n));
        t += n;
L473:;
        for (i=(int64)1;i<=(w - n);++i) {
L474:;
            (*t) = (*fmt).padchar;
            ++t;
L475:;
        }
L476:;
        (*t) = (uint8)0u;
    }
    else if (((int64)((*fmt).justify) == (int64)82)) {
        if (((((int64)((*fmt).padchar) == (int64)48) && !!((*fmt).base)) && (((int64)((*s)) == (int64)45) || ((int64)((*s)) == (int64)43)))) {
            (*t) = (*s);
            ++t;
            av_2 = (w - n);
            while (av_2-- > 0) {
L477:;
                (*t) = (*fmt).padchar;
                ++t;
L478:;
            }
L479:;
            strncpy(t,(s + (int64)1),(uint64)((n - (int64)1)));
            (*((t + n) - (int64)1)) = (uint8)0u;
        }
        else {
            av_3 = (w - n);
            while (av_3-- > 0) {
L480:;
                (*t) = (*fmt).padchar;
                ++t;
L481:;
            }
L482:;
            strncpy(t,s,(uint64)(n));
            (*(t + n)) = (uint8)0u;
        }
    }
    else {
        m = (((w - n) + (int64)1) / (int64)2);
        av_4 = m;
        while (av_4-- > 0) {
L483:;
            (*t) = (*fmt).padchar;
            ++t;
L484:;
        }
L485:;
        strncpy(t,s,(uint64)(n));
        t += n;
        av_5 = ((w - n) - m);
        while (av_5-- > 0) {
L486:;
            (*t) = (*fmt).padchar;
            ++t;
L487:;
        }
L488:;
        (*t) = (uint8)0u;
    }
    return w;
}

void pc_print_pc_strtofmt(byte * s,int64 slen,struct pc_decls_fmtrec * fmt) {
    byte c;
    byte wset;
    int64 n;
    byte str[100];
    pc_print_initfmtcode(fmt);
    memcpy((void *)(str),(void *)(s),(uint64)(slen));
    str[(slen)] = (uint8)0u;
    s = str;
    wset = (uint8)0u;
L489:;
    while (!!((*s))) {
        c = (*s);
        ++s;
        switch ((int64)(c)) {
        case 66:;
        case 98:;
            (*fmt).base = (uint8)2u;
            break;
        case 72:;
        case 104:;
            (*fmt).base = (uint8)16u;
            break;
        case 79:;
        case 111:;
            (*fmt).base = (uint8)8u;
            break;
        case 88:;
        case 120:;
            c = (*s);
            if (!!(c)) {
                switch ((int64)(c)) {
                case 48:;
                case 49:;
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                case 56:;
                case 57:;
                    c = (byte)(((int64)(c) - (int64)48));
                    break;
                case 65:;
                case 66:;
                case 67:;
                case 68:;
                case 69:;
                case 70:;
                    c = (byte)((((int64)(c) - (int64)65) + (int64)10));
                    break;
                case 97:;
                case 98:;
                case 99:;
                case 100:;
                case 101:;
                case 102:;
                    c = (byte)((((int64)(c) - (int64)97) + (int64)10));
                    break;
                default:;
                    c = (uint8)10u;
                }
                (*fmt).base = c;
                ++s;
            }
            break;
        case 81:;
        case 113:;
            (*fmt).quotechar = (uint8)34u;
            break;
        case 126:;
            (*fmt).quotechar = (uint8)126u;
            break;
        case 74:;
        case 106:;
            (*fmt).justify = (byte)(toupper((int32)((*s))));
            if (!!((*s))) {
                ++s;
            }
            break;
        case 65:;
            (*fmt).lettercase = (uint8)65u;
            break;
        case 97:;
            (*fmt).lettercase = (uint8)97u;
            break;
        case 90:;
        case 122:;
            (*fmt).padchar = (uint8)48u;
            break;
        case 83:;
        case 115:;
            (*fmt).sepchar = (*s);
            if (!!((*s))) {
                ++s;
            }
            break;
        case 80:;
        case 112:;
            (*fmt).padchar = (*s);
            if (!!((*s))) {
                ++s;
            }
            break;
        case 84:;
        case 116:;
            (*fmt).suffix = (*s);
            if (!!((*s))) {
                ++s;
            }
            break;
        case 85:;
        case 117:;
            (*fmt).usigned = (uint8)85u;
            break;
        case 69:;
        case 101:;
            (*fmt).realfmt = (uint8)101u;
            break;
        case 70:;
        case 102:;
            (*fmt).realfmt = (uint8)102u;
            break;
        case 71:;
        case 103:;
            (*fmt).realfmt = (uint8)103u;
            break;
        case 46:;
            wset = (uint8)1u;
            break;
        case 44:;
        case 95:;
            (*fmt).sepchar = c;
            break;
        case 43:;
            (*fmt).plus = (uint8)43u;
            break;
        case 77:;
        case 109:;
            (*fmt).charmode = (uint8)77u;
            break;
        case 67:;
        case 99:;
            (*fmt).charmode = (uint8)67u;
            break;
        case 89:;
        case 121:;
            (*fmt).showtypex = (uint8)89u;
            break;
        default:;
            if ((((int64)(c) >= (int64)48) && ((int64)(c) <= (int64)57))) {
                n = ((int64)(c) - (int64)48);
L492:;
                while (1) {
                    c = (*s);
                    if (((int64)((*s)) == (int64)0)) {
                        goto L493;
                    }
                    if ((((int64)(c) >= (int64)48) && ((int64)(c) <= (int64)57))) {
                        ++s;
                        n = (((n * (int64)10) + (int64)(c)) - (int64)48);
                    }
                    else {
                        goto L493;
                    }
                }
L493:;
                if (!(!!(wset))) {
                    (*fmt).minwidth = (byte)((n<(int64)1023?n:(int64)1023));
                    wset = (uint8)1u;
                }
                else {
                    (*fmt).precision = (int8)((n<(int64)100?n:(int64)100));
                }
            }
        }
L490:;
    }
L491:;
}

static void pc_print_printstrz(byte * s) {
    int64 x;
    switch (pc_print_moutdev) {
    case 0:;
        printf((byte*)"%s",s);
        break;
    case 1:;
        fprintf(pc_print_moutchan,(byte*)"%s",s);
        break;
    case 2:;
        pc_print_addstring(pc_print_moutvar.objptr,s,(int64)-1);
        break;
    case 4:;
        pc_print_printstr_n(s,(int64)(strlen(s)));
        break;
    case 3:;
        break;
    default:;
    }
}

static void pc_print_printstr_n(byte * s,int64 n) {
    struct pc_decls_varrec *  p;
    int64 x;
    if ((n == (int64)-1)) {
        n = (int64)(strlen(s));
    }
    if ((n == (int64)0)) {
        return;
    }
    switch (pc_print_moutdev) {
    case 0:;
        printf((byte*)"%.*s",n,s);
        break;
    case 1:;
        fprintf(pc_print_moutchan,(byte*)"%.*s",n,s);
        break;
    case 2:;
        pc_print_addstring(pc_print_moutvar.objptr,s,n);
        break;
    case 4:;
        p = pc_print_moutvar.varptr;
        if (((int64)((*p).tag) != (int64)5)) {
            pc_support_prterror((byte*)"prtstrn1");
        }
        pc_print_addstring(pc_print_moutvar.objptr,s,n);
        break;
    case 3:;
        break;
    default:;
    }
}

void pc_print_printerror(byte * s) {
    pc_support_prterror(s);
}

void pc_print_addstring(struct pc_decls_objrec * p,byte * t,int64 n) {
    int64 oldlen;
    int64 newlen;
    int64 oldbytes;
    int64 newbytes;
    byte *  newptr;
    if (((n == (int64)0) || ((int64)((*t)) == (int64)0))) {
        return;
    }
    if ((n < (int64)0)) {
        n = (int64)(strlen(t));
    }
    oldlen = (int64)((*p).length);
    if (((int64)((*p).refcount) == (int64)0)) {
        if ((oldlen == (int64)0)) {
            memcpy((void *)((*p).ptr),(void *)(t),(uint64)(n));
            (*p).length = (uint32)(n);
        }
        else {
            memcpy((void *)(((*p).ptr + oldlen)),(void *)(t),(uint64)(n));
            (*p).length = (uint32)((oldlen + n));
        }
        (*p).lower = (int32)1;
        return;
    }
    if ((oldlen == (int64)0)) {
        (*p).ptr = (byte *)(mlib_pcm_alloc(n));
        (*p).length = (uint32)(n);
        (*p).allocated = (uint32)(mlib_allocbytes);
        memcpy((void *)((*p).ptr),(void *)(t),(uint64)(n));
    }
    else {
        newlen = (oldlen + n);
        oldbytes = (int64)((*p).allocated);
        newbytes = (oldlen + n);
        if ((newbytes <= oldbytes)) {
            memcpy((void *)(((*p).ptr + oldlen)),(void *)(t),(uint64)(n));
        }
        else {
            newptr = (byte *)(mlib_pcm_alloc(newbytes));
            memcpy((void *)(newptr),(void *)((*p).ptr),(uint64)(oldlen));
            memcpy((void *)((newptr + oldlen)),(void *)(t),(uint64)(n));
            (*p).allocated = (uint32)(mlib_allocbytes);
            mlib_pcm_free((void *)((*p).ptr),oldbytes);
            (*p).ptr = newptr;
        }
        (*p).length = (uint32)(newlen);
    }
    (*p).lower = (int32)1;
}

void pc_print_j_tostr_i(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    switch ((int64)((*fmt).charmode)) {
    case 77:;
        pc_print_domultichar((byte *)(&(*p).value),(int64)8,str,fmt);
        break;
    case 67:;
        str[((int64)1)] = (byte)((*p).value);
        str[((int64)2)] = (uint8)0u;
        break;
    default:;
        pc_print_i64tostrfmt((*p).value,str,fmt,(int64)0);
    }
    if (!!((*fmt).showtypex)) {
        pc_print_addstring(dest,(byte*)"I:",(int64)2);
    }
    pc_print_addstring(dest,str,(int64)(strlen(str)));
}

void pc_print_j_tostr_r(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    byte str2[1024];
    byte cfmt[10];
    int64 n;
    cfmt[((int64)0)] = (uint8)37u;
    if (!!((*fmt).precision)) {
        cfmt[((int64)1)] = (uint8)46u;
        cfmt[((int64)2)] = (uint8)42u;
        cfmt[((int64)3)] = (*fmt).realfmt;
        cfmt[((int64)4)] = (uint8)0u;
        sprintf(str,cfmt,(*fmt).precision,(*p).xvalue);
    }
    else {
        cfmt[((int64)1)] = (*fmt).realfmt;
        cfmt[((int64)2)] = (uint8)0u;
        sprintf(str,cfmt,(*p).xvalue);
    }
    n = (int64)(strlen(str));
    if ((n < (int64)((*fmt).minwidth))) {
        pc_print_expandstr(str,str2,n,fmt);
        strcpy(str,str2);
    }
    pc_print_addstring(dest,str,(int64)(strlen(str)));
}

void pc_print_j_tostr_w(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    switch ((int64)((*fmt).charmode)) {
    case 77:;
        pc_print_domultichar((byte *)(&(*p).uvalue),(int64)8,str,fmt);
        break;
    case 67:;
        str[((int64)1)] = (byte)((*p).uvalue);
        str[((int64)2)] = (uint8)0u;
        break;
    default:;
        pc_print_u64tostrfmt((*p).value,str,fmt);
    }
    if (!!((*fmt).showtypex)) {
        pc_print_addstring(dest,(byte*)"W:",(int64)2);
    }
    pc_print_addstring(dest,str,(int64)(strlen(str)));
}

void pc_print_j_tostr_n(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    byte str2[1024];
    byte cfmt[10];
    int64 n;
    pc_print_i64tostrfmt((int64)((*p).range_lower),str,fmt,(int64)0);
    strcat(str,(byte*)"..");
    pc_print_addstring(dest,str,(int64)-1);
    pc_print_i64tostrfmt((int64)((*p).range_upper),str,fmt,(int64)0);
    pc_print_addstring(dest,str,(int64)-1);
}

void pc_print_j_tostr_s(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    int64 oldlen;
    int64 newlen;
    byte *  s;
    byte str[100];
    struct pc_decls_objrec *  q;
    q = (*p).objptr;
    oldlen = (int64)((*q).length);
    newlen = oldlen;
    if ((!!((*fmt).quotechar) || ((int64)((*fmt).minwidth) > newlen))) {
        if (!!((*fmt).quotechar)) {
            newlen += (int64)2;
        }
        if (((int64)((*fmt).minwidth) > newlen)) {
            newlen = (int64)((*fmt).minwidth);
        }
        s = (byte *)(mlib_pcm_alloc((newlen + (int64)1)));
        pc_print_strtostrfmt((*q).strptr,s,oldlen,fmt);
        pc_print_addstring(dest,s,newlen);
        mlib_pcm_free((void *)(s),(newlen + (int64)1));
    }
    else {
        pc_print_addstring(dest,(*q).strptr,oldlen);
    }
}

void pc_print_j_tostr_l(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    struct pc_decls_varrec *  q;
    int64 i;
    byte c;
    struct pc_decls_objrec *  r;
    ++pc_print_listdepth;
    r = (*p).objptr;
    if ((((int64)((*r).refcount) < (int64)0) || (pc_print_listdepth > (int64)4))) {
        pc_print_addstring(dest,(byte*)"...",(int64)3);
        --pc_print_listdepth;
        return;
    }
    pc_print_addstring(dest,(byte*)"(",(int64)1);
    (*r).refcount = -((*r).refcount);
    q = (*r).vptr;
L494:;
    for (i=(int64)((*(*p).objptr).length);i>=(int64)1;--i) {
L495:;
        pc_print_calltostrtable(q,fmtstr,fmt,dest);
        ++q;
        if ((i != (int64)1)) {
            pc_print_addstring(dest,(byte*)",",(int64)1);
        }
L496:;
    }
L497:;
    pc_print_addstring(dest,(byte*)")",(int64)1);
    (*r).refcount = -((*r).refcount);
    --pc_print_listdepth;
}

void pc_print_j_tostr_a(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    byte *  q;
    int64 i;
    int64 m;
    int64 elemtype;
    int64 a;
    int64 b;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  pa;
    byte *  ptr;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    }
    m = (int64)((*p).tag);
    pa = (*p).objptr;
    a = (int64)((*pa).lower);
    elemtype = (int64)((*pa).elemtag);
    b = (((int64)((*pa).length) + a) - (int64)1);
    q = (*pa).ptr;
    sprintf(str,(byte*)"%s[%d:%s]",pc_decls_ttname[(m)],(*pa).lower,pc_decls_ttname[(elemtype)]);
    pc_print_addstring(dest,str,(int64)-1);
    pc_print_addstring(dest,(byte*)"A(",(int64)-1);
L498:;
    for (i=a;i<=b;++i) {
L499:;
        pc_pcfns_pc_loadpacked((void *)(q),elemtype,&v,(struct pc_decls_objrec *)(0));
        q += pc_decls_ttsize[(elemtype)];
        pc_print_calltostrtable(&v,fmtstr,fmt,dest);
        if ((i < b)) {
            pc_print_addstring(dest,(byte*)",",(int64)1);
        }
L500:;
    }
L501:;
    pc_print_addstring(dest,(byte*)")",(int64)1);
}

void pc_print_j_tostr_b(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    byte *  q;
    int64 i;
    int64 m;
    int64 elemtype;
    int64 a;
    int64 b;
    int64 offset;
    int64 bitwidthx;
    int64 n;
    struct pc_decls_varrec v;
    byte *  pbyte;
    struct pc_decls_objrec *  pa;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    }
    m = (int64)((*p).tag);
    pa = (*p).objptr;
    a = (int64)((*pa).lower);
    elemtype = (int64)((*pa).elemtag);
    offset = ((int64)((*pa).bitoffset) - (int64)1);
    b = (((int64)((*pa).length) + a) - (int64)1);
    bitwidthx = (int64)(pc_decls_ttbitwidth[(elemtype)]);
    sprintf(str,(byte*)"%s[%d:%s]",pc_decls_ttname[(m)],(*pa).lower,pc_decls_ttname[(elemtype)]);
    pc_print_addstring(dest,str,(int64)-1);
    pc_print_addstring(dest,(byte*)"B(",(int64)-1);
    q = (*pa).ptr;
L502:;
    for (i=a;i<=b;++i) {
L503:;
        pc_pcfns_pc_loadbit(q,offset,elemtype,&v);
        offset += bitwidthx;
        if ((offset >= (int64)8)) {
            offset = (int64)0;
            ++q;
        }
        pc_print_calltostrtable(&v,fmtstr,fmt,dest);
        if ((i < b)) {
            pc_print_addstring(dest,(byte*)",",(int64)1);
        }
L504:;
    }
L505:;
    pc_print_addstring(dest,(byte*)")",(int64)1);
}

void pc_print_j_tostr_e(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    struct pc_decls_varrec *  q;
    int64 i;
    int64 j;
    int64 first;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  s;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    }
    pc_print_addstring(dest,(byte*)"[",(int64)1);
    s = (*p).objptr;
    first = (int64)1;
    i = (int64)0;
L506:;
    while ((i < (int64)((*s).length))) {
        if (!!(pc_support_testelem((byte (*)[])((*s).ptr),i))) {
            j = (i + (int64)1);
L509:;
            while (((j < (int64)((*s).length)) && !!(pc_support_testelem((byte (*)[])((*s).ptr),j)))) {
                ++j;
L510:;
            }
L511:;
            --j;
            if (!(!!(first))) {
                pc_print_addstring(dest,(byte*)",",(int64)1);
            }
            first = (int64)0;
            if ((i == j)) {
                v.tagx = (uint32)1u;
                v.value = i;
            }
            else {
                v.tagx = (uint32)4u;
                v.range_lower = (int32)(i);
                v.range_upper = (int32)(j);
            }
            pc_print_calltostrtable(&v,fmtstr,fmt,dest);
            i = (j + (int64)1);
        }
        else {
            ++i;
        }
L507:;
    }
L508:;
    pc_print_addstring(dest,(byte*)"]",(int64)1);
}

void pc_print_j_tostr_k(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    byte needcomma;
    int64 i;
    int64 j;
    int64 stag;
    int64 ftype;
    int64 offset;
    int64 index;
    byte *  ptr;
    struct pc_decls_varrec v;
    struct pc_decls_objrec *  pa;
    struct pc_decls_strec *  d;
    struct pc_decls_strec *  f;
    int64 fieldtypes[100];
    int64 fieldoffsets[100];
    int64 nfields;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    }
    stag = (int64)((*p).tag);
    if (!(!!(pc_decls_runfrompc))) {
        d = pc_decls_ttnamedef[(stag)];
        nfields = (int64)0;
        f = (*d).deflist;
L512:;
        while (!!(f)) {
            if ((((int64)((*f).nameid) == (int64)13) && !(!!((*f).ax_at)))) {
                ++nfields;
                fieldtypes[(nfields)-1] = (int64)((*f).mode);
                fieldoffsets[(nfields)-1] = (int64)((*f).offset);
            }
            f = (*f).nextdef;
L513:;
        }
L514:;
    }
    else {
        index = (int64)(pc_decls_ttstartfield[(stag)]);
        nfields = (int64)(pc_decls_ttstructfields[(stag)]);
L515:;
        for (i=(int64)1;i<=nfields;++i) {
L516:;
            fieldtypes[(((nfields - i) + (int64)1))-1] = (int64)((*pc_decls_pcfieldtable)[(((index + i) - (int64)1))-1].fieldtype);
            fieldoffsets[(((nfields - i) + (int64)1))-1] = (int64)((*pc_decls_pcfieldtable)[(((index + i) - (int64)1))-1].fieldoffset);
L517:;
        }
L518:;
    }
    pa = (*p).objptr;
    ptr = (*pa).ptr;
    pc_print_addstring(dest,(byte*)"(",(int64)-1);
    needcomma = (uint8)0u;
L519:;
    for (i=nfields;i>=(int64)1;--i) {
L520:;
        ftype = fieldtypes[(i)-1];
        offset = fieldoffsets[(i)-1];
        pc_pcfns_pc_loadpacked((void *)((ptr + offset)),ftype,&v,(struct pc_decls_objrec *)(0));
        if (!!(needcomma)) {
            pc_print_addstring(dest,(byte*)",",(int64)1);
        }
        needcomma = (uint8)1u;
        pc_print_calltostrtable(&v,fmtstr,fmt,dest);
L521:;
    }
L522:;
    pc_print_addstring(dest,(byte*)")",(int64)1);
}

void pc_print_j_tostr_j(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    int64 i;
    int64 w;
    int64 length;
    int64 n;
    int64 onheap;
    int64 g;
    int64 k;
    byte str[1025];
    byte str2[2049];
    byte strtemp[100];
    struct pc_decls_objrec *  pp;
    byte *  s;
    byte *  t;
    byte *  u;
    int64 av_1;
    pp = (*p).objptr;
    goto L523;
    if ((((int64)((*fmt).base) == (int64)10) && (((int64)((*pp).length) * (int64)6) < (int64)1024))) {
        s = str;
        if (!!((*(*pp).bnptr)[((int64)0)])) {
            (*s) = (uint8)45u;
            ++s;
        }
        w = (int64)6;
L524:;
        for (i=(int64)1;i<=(int64)((*p).bndigits);++i) {
L525:;
            if ((i == (int64)1)) {
                n = (int64)(sprintf(strtemp,(byte*)"%d",(*(*pp).bnptr)[((int64)1)]));
            }
            else {
                n = (int64)(sprintf(strtemp,(byte*)"%0*d",w,(*(*pp).bnptr)[(i)]));
            }
            memcpy((void *)(s),(void *)(strtemp),(uint64)(n));
            s += n;
L526:;
        }
L527:;
        (*s) = (uint8)0u;
        length = (s - str);
        s = str;
        onheap = (int64)0;
    }
    else {
//slowprint:
L523:;
        onheap = (int64)1;
        s = pc_print_printbn(p,fmt,&length);
    }
    if ((length >= (int64)1024)) {
        pc_print_addstring(dest,s,length);
        if (!!(onheap)) {
            mlib_pcm_free((void *)(s),(length + (int64)1));
        }
        return;
    }
    if (!!((*fmt).sepchar)) {
        g = (((int64)((*fmt).base) == (int64)10)?(int64)3:(int64)4);
        k = (int64)0;
        t = &str2[((int64)2046)];
        (*t) = (uint8)0u;
        n = (int64)0;
        u = ((s + length) - (int64)1);
L528:;
        for (i=length;i>=(int64)1;--i) {
L529:;
            (*--t) = (*u--);
            ++n;
            if (((++k == g) && (i > (int64)1))) {
                k = (int64)0;
                (*--t) = (*fmt).sepchar;
                ++n;
            }
L530:;
        }
L531:;
        if (!!(onheap)) {
            mlib_pcm_free((void *)(s),(length + (int64)1));
            onheap = (int64)0;
        }
        length = n;
        memcpy((void *)(str),(void *)(t),(uint64)((length + (int64)1)));
        s = str;
    }
    n = pc_print_expandstr(s,str2,length,fmt);
    if (!!(onheap)) {
        mlib_pcm_free((void *)(s),(length + (int64)1));
    }
    pc_print_addstring(dest,str2,n);
}

void pc_print_j_tostr_d(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    byte str[1024];
    struct pc_decls_varrec *  q;
    int64 i;
    int64 length;
    int64 needcomma = (int64)0;
    struct pc_decls_objrec *  pa;
    if ((fmt == 0)) {
        fmt = &pc_print_defaultfmt;
    }
    pc_print_addstring(dest,(byte*)"[",(int64)-1);
    pa = (*p).objptr;
    q = (*pa).vptr;
    length = ((int64)((*pa).length) / (int64)2);
L532:;
    for (i=length;i>=(int64)1;--i) {
L533:;
        if (((int64)((*q).tag) == (int64)0)) {
            q += (int64)2;
            goto L534;
        }
        if (!!(needcomma)) {
            pc_print_addstring(dest,(byte*)",",(int64)1);
        }
        needcomma = (int64)1;
        pc_print_calltostrtable(q,fmtstr,fmt,dest);
        ++q;
        pc_print_addstring(dest,(byte*)":",(int64)1);
        pc_print_calltostrtable(q,fmtstr,fmt,dest);
        ++q;
L534:;
    }
L535:;
    pc_print_addstring(dest,(byte*)"]",(int64)1);
}

void pc_print_j_tostr_z(struct pc_decls_varrec * a,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    int64 i;
    int64 n;
    int64 t;
    int64 u;
    int64 cmd;
    byte str[1024];
    struct pc_decls_varrec *  q;
    static int64 nest;
    switch ((int64)((*a).tag)) {
    case 0:;
        pc_print_addstring(dest,(byte*)"<Void>",(int64)-1);
        break;
    case 23:;
        sprintf(str,(byte*)"Ref %s:%p",pc_decls_ttname[((int64)((*a).refelemtag))],(*a).refptr);
        pc_print_addstring(dest,str,(int64)-1);
        break;
    case 24:;
        sprintf(str,(byte*)"Refbit %s:%p @%d",pc_decls_ttname[((int64)((*a).refelemtag))],(*a).refptr,(*a).refbitoffset);
        pc_print_addstring(dest,str,(int64)-1);
        break;
    case 22:;
        sprintf(str,(byte*)"Refvar:%p",(*a).varptr);
        pc_print_addstring(dest,str,(int64)-1);
        if (!!((*a).varptr)) {
            sprintf(str,(byte*)" <%s>",pc_decls_ttname[((int64)((*(*a).varptr).tag))]);
            pc_print_addstring(dest,str,(int64)-1);
        }
        break;
    case 25:;
        sprintf(str,(byte*)"Link:<%s>",pc_decls_ttname[((int64)((*a).refelemtag))]);
        pc_print_addstring(dest,str,(int64)-1);
        break;
    case 18:;
        sprintf(str,(byte*)"Refproc:%p",(*a).refptr);
        pc_print_addstring(dest,str,(int64)-1);
        break;
    case 20:;
        sprintf(str,(byte*)"Reflabel:%p",(*a).refptr);
        pc_print_addstring(dest,str,(int64)-1);
        break;
    case 13:;
        pc_print_addstring(dest,(pc_decls_ttname[((*a).value)] + (int64)1),(int64)-1);
        break;
    case 14:;
        pc_print_addstring(dest,(byte*)"<OP:",(int64)-1);
        cmd = (*a).value;
        pc_print_addstring(dest,(pq_common_cmdnames[(cmd)] + (int64)1),(int64)-1);
        pc_print_addstring(dest,(((int64)((*a).opdims) == (int64)1)?(byte*)":1":(byte*)":2"),(int64)2);
        pc_print_addstring(dest,(byte*)">",(int64)1);
        break;
    default:;
        pc_support_pcustype((byte*)"tostr_def",a);
    }
}

static void pc_print_printnextfmtchars(int64 last) {
    byte c;
    byte *  pstart;
    int64 n;
    pstart = pc_print_mfmtcurr;
    n = (int64)0;
L536:;
    while (!!((int64)1)) {
        c = (*pc_print_mfmtcurr);
        switch ((int64)(c)) {
        case 35:;
            if (!!(last)) {
                goto L539;
            }
            ++pc_print_mfmtcurr;
            if (!!(n)) {
                pc_print_printstr_n(pstart,n);
            }
            return;
            break;
        case 0:;
            if (!!(n)            ) {
                pc_print_printstr_n(pstart,n);
            }
            else if (!(!!(last))) {
                pc_print_printstr_n((byte*)"|",(int64)1);
            }
            return;
            break;
        case 126:;
            if (!!(n)) {
                pc_print_printstr_n(pstart,n);
                n = (int64)0;
            }
            ++pc_print_mfmtcurr;
            c = (*pc_print_mfmtcurr);
            if (!!(c)) {
                ++pc_print_mfmtcurr;
                pc_print_printstr_n(&c,(int64)1);
            }
            pstart = pc_print_mfmtcurr;
            break;
        default:;
//skip:
L539:;
            ++n;
            ++pc_print_mfmtcurr;
        }
L537:;
    }
L538:;
}

static int64 pc_print_getreadfmtcode(struct pc_decls_varrec * p) {
    byte c;
    if (((p == 0) || ((int64)((*p).tag) == (int64)0))) {
        return (int64)65;
    }
    if (((int64)((*p).tag) != (int64)5)) {
        printf("%s %s\n",(char*)((byte*)"P=%s"),(char*)(pc_decls_ttname[((int64)((*p).tag))]));
        pc_support_prterror((byte*)"Readfmt?");
    }
    if (((int64)((*(*p).objptr).length) == (int64)0)) {
        return (int64)65;
    }
    c = (byte)(toupper((int32)((*(*(*p).objptr).strptr))));
    switch ((int64)(c)) {
    case 73:;
    case 82:;
    case 78:;
    case 83:;
    case 70:;
    case 84:;
    case 90:;
    case 67:;
    case 76:;
    case 72:;
    case 66:;
    case 65:;
    case 69:;
        return (int64)(c);
        break;
    default:;
    }
    pc_support_prterror((byte*)"Readfmt2?");
    return (int64)0;
}

void pc_print_pch_sreadln(struct pc_decls_varrec * dev,struct pc_decls_varrec * dest) {
    pc_print_pch_readln(dev);
    pc_pcfns_pc_makestring(pc_print_kb_start,pc_print_kb_length,dest);
}

void pc_print_pch_strtoval(struct pc_decls_varrec * p,struct pc_decls_varrec * fmt,struct pc_decls_varrec * dest) {
    int64 fmtcode;
    int64 length;
    byte oldmutable;
    struct pc_decls_objrec *  q;
    byte str[1024];
    byte *  s = str;
    q = (*p).objptr;
    if (((int64)((*q).length) < (int64)1024)) {
        memcpy((void *)(s),(void *)((*q).strptr),(uint64)((*q).length));
        str[(((int64)((*q).length) + (int64)1))-1] = (uint8)0u;
    }
    else {
        pc_support_pcerror((byte*)"STRTOVAL/string too long");
    }
    fmtcode = pc_print_getreadfmtcode(fmt);
    if (((int64)((*p).tag) != (int64)5)) {
        pc_support_prterror((byte*)"strval");
    }
    length = (int64)((*(*p).objptr).length);
    switch (fmtcode) {
    case 73:;
        pc_print_readint(s,length,dest);
        break;
    case 82:;
        pc_print_readreal(s,length,dest);
        break;
    case 78:;
        pc_print_readname(s,length,dest);
        break;
    case 83:;
        pc_print_readstring(s,length,dest);
        break;
    case 72:;
        pc_print_readhex(s,length,dest);
        break;
    case 66:;
        pc_print_readbin(s,length,dest);
        break;
    case 65:;
        pc_print_readany(s,length,dest);
        break;
    default:;
        pc_support_prterror((byte*)"strval:fmt?");
    }
}

void pc_print_pch_reread(void) {
    pc_print_kb_pos = pc_print_kb_lastpos;
    pc_print_kb_length = pc_print_kb_lastlength;
}

void pc_print_pch_rereadln(void) {
    pc_print_kb_pos = pc_print_kb_start;
    pc_print_kb_length = pc_print_kb_linelength;
}

static byte * pc_print_readname(byte * s,int64 length,struct pc_decls_varrec * dest) {
    byte *  send;
    byte *  itemstr;
    int64 itemlength;
    send = pc_print_readitem(s,length,&itemstr,&itemlength);
    pc_pcfns_pc_makestring(itemstr,itemlength,dest);
    mlib_iconvlcn((*(*dest).objptr).strptr,(int64)((*(*dest).objptr).length));
    return send;
}

static byte * pc_print_readstring(byte * s,int64 length,struct pc_decls_varrec * dest) {
    byte *  send;
    byte *  itemstr;
    int64 itemlength;
    send = pc_print_readitem(s,length,&itemstr,&itemlength);
    pc_pcfns_pc_makestring(itemstr,itemlength,dest);
    return send;
}

static byte * pc_print_readint(byte * sold,int64 length,struct pc_decls_varrec * dest) {
    byte *  p;
    byte *  s;
    byte *  send;
    byte *  itemstr;
    int64 itemlength;
    int64 numlength;
    send = pc_print_readitem(sold,length,&s,&itemlength);
    pc_print_strtoint(s,itemlength,dest);
    return send;
}

static byte * pc_print_readhex(byte * sold,int64 length,struct pc_decls_varrec * dest) {
    byte str[256];
    byte *  p;
    byte *  s;
    byte res;
    int64 aa;
    int64 a;
    int64 t;
    int64 nalloc;
    byte c;
    if ((length == (int64)0)) {
        (*dest).tagx = (uint32)1u;
        (*dest).value = (int64)0;
        pc_print_termchar = (uint8)0u;
        return sold;
    }
L540:;
    while ((!!(length) && (((int64)((*sold)) == (int64)32) || ((int64)((*sold)) == (int64)9)))) {
        ++sold;
        --length;
L541:;
    }
L542:;
    if ((length <= (int64)256)) {
        s = str;
        nalloc = (int64)0;
    }
    else {
        nalloc = (length + (int64)1);
        s = (byte *)(mlib_pcm_alloc(nalloc));
    }
    p = s;
L543:;
    while (!!(length)) {
        c = (byte)(toupper((int32)((*sold))));
        ++sold;
        --length;
        if ((((int64)(c) >= (int64)48) && ((int64)(c) <= (int64)57))        ) {
            (*p) = c;
            ++p;
        }
        else if ((((int64)(c) >= (int64)65) && ((int64)(c) <= (int64)70))) {
            (*p) = c;
            ++p;
        }
        else if (((int64)(c) == (int64)95)) {
        }
        else {
            pc_print_termchar = c;
            goto L545;
        }
L544:;
    }
L545:;
    (*p) = (uint8)0u;
    length = (p - s);
    if ((length <= (int64)16)) {
        t = (int64)1;
    }
    else {
        t = (int64)7;
    }
    p = s;
    switch (t) {
    case 1:;
        aa = (int64)0;
L546:;
        while (!!((int64)1)) {
            c = (*p);
            ++p;
            if (((int64)(c) == (int64)0)) {
                goto L548;
            }
            if (((int64)(c) < (int64)65)) {
                aa = (((aa * (int64)16) + (int64)(c)) - (int64)48);
            }
            else {
                aa = (((aa * (int64)16) + ((int64)(c) - (int64)65)) + (int64)10);
            }
L547:;
        }
L548:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = aa;
        break;
    default:;
        pc_bigint_bn_makeu_base(s,(int64)(strlen(s)),dest,(int64)16);
    }
    if (!!(nalloc)) {
        mlib_pcm_free((void *)(s),nalloc);
    }
    return sold;
}

static byte * pc_print_readbin(byte * sold,int64 length,struct pc_decls_varrec * dest) {
    byte str[256];
    byte *  p;
    byte *  s;
    byte res;
    int64 aa;
    int64 a;
    int64 t;
    int64 nalloc;
    byte c;
    if ((length == (int64)0)) {
        (*dest).tagx = (uint32)1u;
        (*dest).value = (int64)0;
        pc_print_termchar = (uint8)0u;
        return sold;
    }
L549:;
    while ((!!(length) && (((int64)((*sold)) == (int64)32) || ((int64)((*sold)) == (int64)9)))) {
        ++sold;
        --length;
L550:;
    }
L551:;
    if ((length <= (int64)256)) {
        s = str;
        nalloc = (int64)0;
    }
    else {
        nalloc = (length + (int64)1);
        s = (byte *)(mlib_pcm_alloc(nalloc));
    }
    p = s;
L552:;
    while (!!(length)) {
        c = (byte)(toupper((int32)((*sold))));
        ++sold;
        --length;
        if ((((int64)(c) >= (int64)48) && ((int64)(c) <= (int64)49))        ) {
            (*p) = c;
            ++p;
        }
        else if (((int64)(c) == (int64)95)) {
        }
        else {
            pc_print_termchar = c;
            goto L554;
        }
L553:;
    }
L554:;
    (*p) = (uint8)0u;
    length = (p - s);
    if ((length <= (int64)64)) {
        t = (int64)1;
    }
    else {
        t = (int64)7;
    }
    p = s;
    switch (t) {
    case 1:;
        aa = (int64)0;
L555:;
        while (!!((int64)1)) {
            c = (*p);
            ++p;
            if (((int64)(c) == (int64)0)) {
                goto L557;
            }
            aa = (((aa * (int64)2) + (int64)(c)) - (int64)48);
L556:;
        }
L557:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = aa;
        break;
    default:;
        pc_bigint_bn_makeu_base(s,(int64)(strlen(s)),dest,(int64)2);
    }
    if (!!(nalloc)) {
        mlib_pcm_free((void *)(s),nalloc);
    }
    return sold;
}

static byte * pc_print_readreal(byte * sold,int64 length,struct pc_decls_varrec * dest) {
    byte str[512];
    double x;
    byte *  send;
    byte *  itemstr;
    int64 itemlength;
    int64 numlength;
    send = pc_print_readitem(sold,length,&itemstr,&itemlength);
    pc_print_strtoreal(itemstr,itemlength,dest);
    return send;
}

void pc_print_pch_readln(struct pc_decls_varrec * dev) {
    void *  ch;
    int64 length;
    struct pc_decls_objrec *  pdev;
    if ((pc_print_kb_start == 0)) {
        pc_print_kb_start = (byte *)(mlib_pcm_alloc((int64)262144));
        pc_print_kb_size = (int64)262144;
        pc_print_kb_lastpos = pc_print_kb_start;
        pc_print_kb_pos = pc_print_kb_start;
        pc_print_kb_length = (int64)0;
        pc_print_kb_lastlength = (int64)0;
        pc_print_kb_linelength = (int64)0;
    }
    switch ((int64)((*dev).tag)) {
    case 0:;
//doconsole:
L558:;
        mlib_readlinen(0,pc_print_kb_start,pc_print_kb_size);
        pc_print_kb_length = (int64)(strlen(pc_print_kb_start));
        break;
    case 1:;
        switch ((*dev).value) {
        case 0:;
            goto L558;
            break;
        case 1:;
            if ((pc_print_testfilech == 0)) {
                pc_support_prterror((byte*)"R@2: file not open");
            }
            ch = pc_print_testfilech;
            break;
        default:;
            ch = (void *)((*dev).value);
        }
        pc_print_pc_readlinen(ch,pc_print_kb_start,pc_print_kb_size);
        pc_print_kb_length = (int64)(strlen(pc_print_kb_start));
        break;
    case 5:;
        pdev = (*dev).objptr;
        length = (int64)((*pdev).length);
        if ((length == (int64)0)        ) {
            pc_print_kb_length = (int64)0;
            (*pc_print_kb_start) = (uint8)0u;
        }
        else if ((length >= pc_print_kb_size)) {
            pc_support_prterror((byte*)"KB overflow");
        }
        else {
            pc_print_kb_length = length;
            memcpy((void *)(pc_print_kb_start),(void *)((*pdev).strptr),(uint64)(length));
        }
        break;
    default:;
        printf("%s\n",(char*)(pc_support_gettypename((int64)((*dev).tag))));
        pc_support_prterror((byte*)"readln@");
    }
    pc_print_kb_pos = pc_print_kb_start;
    pc_print_kb_lastpos = pc_print_kb_pos;
    pc_print_kb_linelength = pc_print_kb_length;
}

static void pc_print_stepkbpos(byte * s) {
    int64 newlen;
    newlen = (s - pc_print_kb_pos);
    if ((newlen == (int64)0)) {
        return;
    }
    if ((newlen >= pc_print_kb_length)) {
        pc_print_kb_pos = (pc_print_kb_pos + pc_print_kb_length);
        pc_print_kb_length = (int64)0;
    }
    else {
        pc_print_kb_pos = (pc_print_kb_pos + newlen);
        pc_print_kb_length -= newlen;
    }
}

void pc_print_pch_sread(struct pc_decls_varrec * fmt,struct pc_decls_varrec * dest) {
    int64 fmtcode;
    byte c;
    fmtcode = pc_print_getreadfmtcode(fmt);
    pc_print_kb_lastpos = pc_print_kb_pos;
    pc_print_kb_lastlength = pc_print_kb_length;
    switch (fmtcode) {
    case 73:;
        pc_print_stepkbpos(pc_print_readint(pc_print_kb_pos,pc_print_kb_length,dest));
        break;
    case 82:;
        pc_print_stepkbpos(pc_print_readreal(pc_print_kb_pos,pc_print_kb_length,dest));
        break;
    case 78:;
        pc_print_stepkbpos(pc_print_readname(pc_print_kb_pos,pc_print_kb_length,dest));
        break;
    case 83:;
        pc_print_stepkbpos(pc_print_readstring(pc_print_kb_pos,pc_print_kb_length,dest));
        break;
    case 72:;
        pc_print_stepkbpos(pc_print_readhex(pc_print_kb_pos,pc_print_kb_length,dest));
        break;
    case 66:;
        pc_print_stepkbpos(pc_print_readbin(pc_print_kb_pos,pc_print_kb_length,dest));
        break;
    case 65:;
        pc_print_stepkbpos(pc_print_readany(pc_print_kb_pos,pc_print_kb_length,dest));
        break;
    case 76:;
        if ((pc_print_kb_length == (int64)0)) {
            pc_pcfns_pc_emptystring(dest);
        }
        else {
            pc_pcfns_pc_makestring(pc_print_kb_pos,pc_print_kb_length,dest);
            pc_print_kb_pos += pc_print_kb_length;
            pc_print_kb_length = (int64)0;
        }
        break;
    case 67:;
        if ((pc_print_kb_length == (int64)0)) {
            pc_pcfns_pc_emptystring(dest);
        }
        else {
            pc_print_termchar = (*pc_print_kb_pos);
//dochar:
L559:;
            (*dest).tagx = (uint32)1u;
            (*dest).value = (int64)(pc_print_termchar);
            ++pc_print_kb_pos;
            --pc_print_kb_length;
        }
        break;
    case 90:;
        goto L559;
        break;
    case 69:;
        (*dest).tagx = (uint32)1u;
        (*dest).value = pc_print_itemerror;
        break;
    default:;
        pc_support_prterror((byte*)"SREAD/FMT?");
    }
}

static void pc_print_domultichar(byte * p,int64 n,byte * dest,struct pc_decls_fmtrec * fmt) {
    byte str[20];
    byte *  q;
    int64 i;
    int64 nchars;
    int64 av_1;
    q = str;
    nchars = n;
    av_1 = n;
    while (av_1-- > 0) {
L560:;
        if (((int64)((*p)) == (int64)0)) {
            goto L562;
        }
        (*q) = (*p);
        ++q;
        ++p;
L561:;
    }
L562:;
    (*q) = (uint8)0u;
    pc_print_expandstr(str,dest,nchars,fmt);
}

void pc_print_pch_tostr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    struct pc_decls_fmtrec fmt;
    struct pc_decls_fmtrec *  ifmt;
    struct pc_decls_objrec *  p;
    ifmt = pc_print_pc_getfmt(b,&fmt);
    p = pc_objects_newobject();
    (*p).mutable = (uint8)1u;
    (*p).length = (uint32)0u;
    (*p).elemtag = (uint16)44u;
    pc_print_listdepth = (int64)0;
    pc_print_calltostrtable(a,b,ifmt,p);
    (*result).tagx = (uint32)(((int64)5 | (int64)65536));
    (*result).objptr = p;
}

struct pc_decls_fmtrec * pc_print_pc_getfmt(struct pc_decls_varrec * p,struct pc_decls_fmtrec * fmt) {
    if (((p == 0) || ((int64)((*p).tag) == (int64)0))) {
        return &pc_print_defaultfmt;
    }
    else {
        if (((int64)((*p).tag) != (int64)5)) {
            pc_support_prterror((byte*)"pc_getfmt/not str?");
        }
        if (((*(*p).objptr).strptr == 0)) {
            return &pc_print_defaultfmt;
        }
        else {
            pc_print_pc_strtofmt((*(*p).objptr).strptr,(int64)((*(*p).objptr).length),fmt);
            return fmt;
        }
    }
}

static void pc_print_pc_readlinen(void * handlex,byte * buffer,int64 size) {
    byte *  p;
    int64 n;
    int64 x;
    byte buff[100];
    byte crseen;
    int64 oldpos;
    (*buffer) = (uint8)0u;
    fgets(buffer,(size - (int64)2),handlex);
    n = (int64)(strlen(buffer));
    if ((n == (int64)0)) {
        return;
    }
    p = ((buffer + n) - (int64)1);
    crseen = (uint8)0u;
L563:;
    while (((p >= buffer) && (((int64)((*p)) == (int64)13) || ((int64)((*p)) == (int64)10)))) {
        if ((((int64)((*p)) == (int64)13) || ((int64)((*p)) == (int64)10))) {
            crseen = (uint8)1u;
        }
        (*p--) = (uint8)0u;
L564:;
    }
L565:;
    if ((!(!!(crseen)) && ((n + (int64)4) > size))) {
        printf("%lld %lld\n",(int64)size,(int64)n);
        mlib_abortprogram((byte*)"line too long");
    }
}

static byte * pc_print_readitem(byte * s,int64 length,byte * * itemstr,int64 * itemlength) {
    byte *  p;
    byte quotechar;
    byte c;
L566:;
    while ((!!(length) && (((int64)((*s)) == (int64)32) || ((int64)((*s)) == (int64)9)))) {
        ++s;
        --length;
L567:;
    }
L568:;
    (*itemstr) = s;
    if ((length == (int64)0)) {
        pc_print_termchar = (uint8)0u;
        (*itemlength) = (int64)0;
        return s;
    }
    quotechar = (uint8)0u;
    if (((int64)((*s)) == (int64)34)    ) {
        quotechar = (uint8)34u;
        ++s;
        --length;
    }
    else if (((int64)((*s)) == (int64)39)) {
        quotechar = (uint8)39u;
        ++s;
        --length;
    }
    p = ((*itemstr) = s);
L569:;
    while (!!(length)) {
        c = (*s++);
        --length;
        switch ((int64)(c)) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
            if ((!!(quotechar) || (p == s))) {
                goto L572;
            }
            pc_print_termchar = c;
            goto L571;
            break;
        default:;
//normalchar:
L572:;
            if ((c == quotechar)) {
                if ((!!(length) && ((*s) == quotechar))) {
                    (*p) = c;
                    ++s;
                    ++p;
                }
                else {
                    pc_print_termchar = (*s);
                    if ((((int64)(pc_print_termchar) == (int64)44) || ((int64)(pc_print_termchar) == (int64)61))) {
                        ++s;
                        pc_print_termchar = (*s);
                    }
                    goto L571;
                }
            }
            else {
                (*p) = c;
                ++p;
            }
        }
L570:;
    }
L571:;
    if ((length == (int64)0)) {
        pc_print_termchar = (uint8)0u;
    }
    (*itemlength) = (p - (*itemstr));
    return s;
}

static byte * pc_print_readany(byte * sold,int64 length,struct pc_decls_varrec * dest) {
    byte str[256];
    byte *  p;
    byte *  s;
    byte signd;
    byte res;
    int64 aa;
    int64 digits;
    int64 expon;
    int64 other;
    int64 t;
    int64 nalloc;
    byte c;
    byte *  send;
    byte *  itemstr;
    int64 itemlength;
    int64 numlength;
    int64 av_1;
    pc_print_itemerror = (int64)0;
    send = pc_print_readitem(sold,length,&s,&itemlength);
    p = s;
    digits = (expon = (other = (int64)0));
    av_1 = itemlength;
    while (av_1-- > 0) {
L573:;
        switch ((int64)((*p++))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 43:;
        case 45:;
        case 95:;
            digits = (int64)1;
            break;
        case 69:;
        case 101:;
        case 46:;
            expon = (int64)1;
            break;
        default:;
            other = (int64)1;
        }
L574:;
    }
L575:;
    (*dest).tagx = (uint32)1u;
    if ((!!(other) || (itemlength == (int64)0))    ) {
        (*dest).value = (int64)5395539;
        pc_pcfns_pc_makestring(s,itemlength,dest);
    }
    else if (!!(expon)) {
        pc_print_strtoreal(s,itemlength,dest);
    }
    else {
        pc_print_strtoint(s,itemlength,dest);
    }
    return send;
}

static void pc_print_strtoreal(byte * s,int64 length,struct pc_decls_varrec * dest) {
    byte str[512];
    double x;
    int32 numlength;
    (*dest).tagx = (uint32)3u;
    if ((length >= (int64)512)) {
        (*dest).xvalue = (float)0.000000;
        return;
    }
    memcpy((void *)(str),(void *)(s),(uint64)(length));
    str[((length + (int64)1))-1] = (uint8)0u;
    pc_print_itemerror = (int64)0;
    if ((((int64)(sscanf(str,(byte*)"%lf%n",&x,&numlength)) == (int64)0) || ((int64)(numlength) != length))) {
        if (((int64)(numlength) == length)) {
            x = (float)0.000000;
        }
        pc_print_itemerror = (int64)1;
    }
    (*dest).xvalue = x;
}

static void pc_print_strtoint(byte * s,int64 length,struct pc_decls_varrec * dest) {
    byte str[256];
    byte *  p;
    byte *  q;
    byte signd;
    int64 aa;
    int64 a;
    int64 res;
    int64 cat;
    int64 t;
    int64 nalloc;
    byte c;
    pc_print_itemerror = (int64)0;
    signd = (uint8)0u;
    if ((!!(length) && ((int64)((*s)) == (int64)45))    ) {
        signd = (uint8)1u;
        ++s;
        --length;
    }
    else if ((!!(length) && ((int64)((*s)) == (int64)43))) {
        ++s;
        --length;
    }
L576:;
    while ((((int64)((*s)) == (int64)48) && (length > (int64)1))) {
        ++s;
        --length;
L577:;
    }
L578:;
    p = (q = s);
L579:;
    while (!!(length)) {
        c = (*q++);
        --length;
        if (!!((c>=(int64)48 && c<=(int64)57))) {
            (*p) = c;
            ++p;
        }
        else {
            if (((int64)(c) == (int64)95)) {
            }
            else {
                pc_print_itemerror = (int64)1;
                goto L581;
            }
        }
L580:;
    }
L581:;
    (*p) = (uint8)0u;
    length = (p - s);
    if ((length <= (int64)18)    ) {
        cat = (int64)65;
    }
    else if ((length == (int64)19)) {
        if ((mlib_cmpstring(s,(byte*)"9223372036854775808")==(int64)-1)) {
            cat = (int64)65;
        } else if ((mlib_cmpstring(s,(byte*)"9223372036854775808")==(int64)0)) {
            cat = (int64)66;
        }
        else {
            cat = (int64)67;
        }
    }
    else if ((length == (int64)20)) {
        if ((mlib_cmpstring(s,(byte*)"18446744073709551615") <= (int64)0)) {
            cat = (int64)67;
        }
        else {
            cat = (int64)68;
        }
    }
    else {
        cat = (int64)68;
    }
    if (!!(signd)) {
        if ((cat==(int64)66)) {
            cat = (int64)65;
        } else if ((cat==(int64)67)) {
            cat = (int64)68;
        }
    }
    if ((cat==(int64)65)) {
        t = (int64)1;
    } else if ((cat==(int64)66) || (cat==(int64)67)) {
        t = (int64)2;
    }
    else {
        t = (int64)7;
    }
    p = s;
    if ((t != (int64)7)) {
        aa = (int64)0;
L582:;
        while (1) {
            c = (*p);
            ++p;
            if (((int64)(c) == (int64)0)) {
                goto L583;
            }
            aa = ((aa * (int64)10) + ((int64)(c) - (int64)48));
        }
L583:;
        if (!!(signd)) {
            aa = -(aa);
        }
        (*dest).tagx = (uint32)(t);
        (*dest).value = aa;
    }
    else {
        pc_bigint_bn_makestr(s,length,dest);
    }
}

static void pc_print_calltostrtable(struct pc_decls_varrec * q,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    struct pc_decls_varrec v;
    pc_decls_overloadtype = (int64)((*q).tag);
    if (((int64)((*fmtstr).tag) == (int64)0)) {
        pc_pcfns_pc_emptystring(&v);
        fmtstr = &v;
    }
    ((*pc_decls_tostr_table[(pc_decls_overloadtype)]))(q,fmtstr,fmt,dest);
}

static byte * pc_print_printbn(struct pc_decls_varrec * a0,struct pc_decls_fmtrec * fmt,int64 * length) {
    static struct mlib_strbuffer destx;
    static struct mlib_strbuffer *  dest = &destx;
    struct pc_decls_varrec a;
    struct pc_decls_varrec b;
    struct pc_decls_varrec b10;
    struct pc_decls_varrec vbase;
    int64 d;
    int64 base;
    int64 alen;
    int64 b10len;
    int64 n;
    byte *  s;
    int64 i;
    base = (int64)((*fmt).base);
    mlib_gs_init(dest);
    pc_pcfns_pc_ushare(a0);
    a = (*a0);
    pc_bigint_bn_makeint(base,&vbase);
    if (!!((*fmt).suffix)) {
        mlib_gs_char(dest,(*fmt).suffix);
    }
L584:;
    while (1) {
        pc_bigint_bn_divu(&a,&vbase,&b);
        pc_bigint_muldigit(&b,base,(int64)0,&b10);
        alen = (int64)((*a.objptr).length);
        b10len = (int64)((*b10.objptr).length);
        d = (int64)(((*(*a.objptr).bnptr)[((alen - (int64)1))] - (*(*b10.objptr).bnptr)[((b10len - (int64)1))]));
        mlib_gs_char(dest,pc_print_digits[(d)]);
        pc_bigint_freebigint(&a);
        pc_bigint_freebigint(&b10);
        if ((((int64)((*b.objptr).length) == (int64)2) && ((int64)((*(*b.objptr).bnptr)[((int64)1)]) == (int64)0))) {
            goto L585;
        }
        a = b;
    }
L585:;
    pc_bigint_freebigint(&b);
    if (((int64)((*(*(*a0).objptr).bnptr)[((int64)0)]) == (int64)1)) {
        mlib_gs_char(dest,(uint8)45u);
    }
    if (!!((*fmt).showtypex)) {
        mlib_gs_str(dest,(byte*)":L");
    }
    n = ((*length) = (int64)((*dest).length));
    s = (byte *)(mlib_pcm_alloc(((*length) + (int64)1)));
L586:;
    for (i=(int64)1;i<=n;++i) {
L587:;
        (*((s + n) - i)) = (*(((*dest).strptr + i) - (int64)1));
L588:;
    }
L589:;
    (*(s + n)) = (uint8)0u;
    mlib_gs_free(dest);
    return s;
}

void pc_jhandlers_initcalltables(void) {
    int64 n;
    int64 i;
    int64 j;
    int64 ttdefault;
    int64 slen;
    byte *  name;
    void *  fnaddr;
    void * (*stable)[];
    void * (*dtable)[];
    byte localmixedmap[301];
    int64 av_1;
    pc_jhandlers_mixedmap = &localmixedmap;
    memset((void *)(pc_jhandlers_mixedmap),(int32)0,(uint64)((int64)301));
    n = msysc_m_getnprocs();
L590:;
    for (i=(int64)1;i<=n;++i) {
L591:;
        name = msysc_m_getprocname(i);
        if ((((int64)((*name)) == (int64)106) && ((int64)((*(name + (int64)1))) == (int64)95))) {
            pc_jhandlers_initjhandler(name,msysc_m_getprocaddr(i));
        }
L592:;
    }
L593:;
L594:;
    for (i=(int64)1;i<=(int64)66;++i) {
L595:;
        stable = (void * (*)[])(pc_jhandlers_singletable[(i)-1]);
        dtable = (void * (*)[])(pc_jhandlers_doubletable[(i)-1]);
        if (!!(stable)) {
            fnaddr = (*stable)[((int64)0)];
            if ((fnaddr == 0)) {
                fnaddr = (void *)(&pc_jhandlers_def_handler);
            }
L598:;
            for (j=(int64)0;j<=(int64)300;++j) {
L599:;
                if (((*stable)[(j)] == 0)) {
                    (*stable)[(j)] = fnaddr;
                }
L600:;
            }
L601:;
        }
        if (!!(dtable)) {
            fnaddr = (*dtable)[((int64)0)];
            if ((fnaddr == 0)) {
                fnaddr = (void *)(&pc_jhandlers_ddef_handler);
            }
L602:;
            for (j=(int64)0;j<=(int64)300;++j) {
L603:;
                if (((*dtable)[(j)] == 0)) {
                    if (!!(localmixedmap[(j)])) {
                        name = pc_jhandlers_tabnames[(i)-1];
                        slen = (int64)(strlen(name));
                        if (!!(mlib_eqstring(((name + slen) - (int64)2),(byte*)"to"))) {
                            goto L606;
                        }
                        (*dtable)[(j)] = (void *)(pc_decls_mixed_dtable[(j)]);
                    }
                    else {
//donormal:
L606:;
                        (*dtable)[(j)] = fnaddr;
                    }
                }
L604:;
            }
L605:;
        }
L596:;
    }
L597:;
}

static void pc_jhandlers_initjhandler(byte * p,void * fnaddr) {
    byte opname[32];
    byte *  q;
    byte c;
    byte d;
    int64 t;
    int64 u;
    int64 i;
    void * (*stable)[];
    void * (*dtable)[];
    int64 av_1;
    p += (int64)2;
    q = p;
L607:;
    while ((((int64)((*q)) != (int64)95) && ((int64)((*q)) != (int64)0))) {
        ++q;
L608:;
    }
L609:;
    memcpy((void *)(opname),(void *)(p),(uint64)((q - p)));
    opname[(((q - p) + (int64)1))-1] = (uint8)0u;
    if (((int64)((*q)) == (int64)0)) {
        return;
    }
L610:;
    for (i=(int64)1;i<=(int64)66;++i) {
L611:;
        if (!!(mlib_eqstring(pc_jhandlers_tabnames[(i)-1],opname))) {
            stable = (void * (*)[])(pc_jhandlers_singletable[(i)-1]);
            dtable = (void * (*)[])(pc_jhandlers_doubletable[(i)-1]);
            goto L613;
        }
L612:;
    }
    pc_support_loaderror((byte*)"Init: Can't find Jhandler op:",opname);
    exit(0);
L613:;
L614:;
    while (((int64)((*q)) == (int64)95)) {
        c = (*++q);
        if ((((int64)(c) < (int64)97) || ((int64)(c) > (int64)122))) {
            return;
        }
        d = (*++q);
        if ((((int64)(d) >= (int64)97) && ((int64)(d) <= (int64)122))) {
            ++q;
        }
        else {
            d = (uint8)0u;
        }
        t = (int64)(pc_jhandlers_typemap[((int64)(c))-97]);
        if (!!(d)) {
            u = (int64)(pc_jhandlers_typemap[((int64)(d))-97]);
        }
        else {
            u = (int64)0;
        }
        if (!!(d)) {
            if ((dtable == 0)) {
                pc_support_loaderror((byte*)"No d-calltable for:",(p - (int64)2));
            }
            pc_jhandlers_add_dtable_entry((uint64 * (*(*)[])(void))(dtable),t,u,fnaddr);
        }
        else {
            if ((stable == 0)) {
                pc_support_loaderror((byte*)"No s-calltable for:",(p - (int64)2));
            }
            pc_jhandlers_add_stable_entry(stable,t,fnaddr);
        }
L615:;
    }
L616:;
}

static void pc_jhandlers_add_stable_entry(void * (*table)[],int64 t,void * fnaddr) {
    int64 i;
    if ((t == (int64)35)) {
        t = (int64)0;
    }
    (*table)[(t)] = fnaddr;
}

static void pc_jhandlers_add_dtable_entry(uint64 * (*(*table)[])(void),int64 s,int64 t,void * fnaddr) {
    int64 i;
    int64 j;
    int64 typesig;
    if ((s == (int64)35)) {
        typesig = (int64)0;
    }
    else {
        typesig = pc_support_gettypesig(s,t);
        if ((table == &pc_decls_mixed_dtable)) {
            (*pc_jhandlers_mixedmap)[(typesig)] = (uint8)1u;
        }
    }
    (*table)[(typesig)] = (uint64 * (*)(void))(fnaddr);
}

static void pc_jhandlers_def_handler(void) {
    pc_support_pcerror((byte*)"Single disp: no handler");
}

static void pc_jhandlers_ddef_handler(void) {
    pc_support_pcerror((byte*)"Double disp: no handler");
}

uint64 * pc_jhandlers_j_add_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value += (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_add_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue += (*y).xvalue;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_add_s(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_objrec *  z;
    int64 xlen;
    int64 ylen;
    int64 newlen;
    byte *  s;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    xlen = (int64)((*(*x).objptr).length);
    ylen = (int64)((*(*y).objptr).length);
    if ((xlen == (int64)0)    ) {
        if (!!(ylen)) {
            (*pc_decls_sptr) = (*y);
        }
    }
    else if ((ylen == (int64)0)) {
    }
    else {
        newlen = (xlen + ylen);
        s = (byte *)(mlib_pcm_alloc(newlen));
        memcpy((void *)(s),(void *)((*(*x).objptr).strptr),(uint64)(xlen));
        memcpy((void *)((s + xlen)),(void *)((*(*y).objptr).strptr),(uint64)(ylen));
        pc_pcfns_pc_ufree(x);
        pc_pcfns_pc_ufree(y);
        pc_pcfns_pc_makestringx(s,newlen,mlib_allocbytes,pc_decls_sptr);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_add_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bigint_bn_add(x,y,&result);
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_add_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_dxfns_dx_iorset(x,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_add_z(void) {
    pc_support_pcmxtypes((byte*)"add_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_add_iw_wi(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value += (*y).value;
    (*pc_decls_sptr).tag = (uint16)1u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_add_zz(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    y = pc_decls_sptr++;
    yt = (int64)((*y).tag);
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 23:;
        switch (yt) {
        case 1:;
            (*pc_decls_sptr).refptr = ((*pc_decls_sptr).refptr + ((*y).value * pc_decls_ttsize[((int64)((*pc_decls_sptr).refelemtag))]));
            return (pc_decls_pcptr + (int64)1);
            break;
        default:;
        }
        break;
    case 22:;
        switch (yt) {
        case 1:;
            (*pc_decls_sptr).varptr = ((*pc_decls_sptr).varptr + (*y).value);
            return (pc_decls_pcptr + (int64)1);
            break;
        default:;
        }
        break;
    default:;
    }
    pc_support_pcmxtypes((byte*)"add/mixed_def",pc_decls_sptr,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_sub_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value -= (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_sub_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue -= (*y).xvalue;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_sub_p(void) {
    struct pc_decls_varrec *  y;
    byte *  p;
    byte *  q;
    int64 elemsize;
    y = pc_decls_sptr++;
    p = (*pc_decls_sptr).refptr;
    q = (*y).refptr;
    if (((elemsize = pc_decls_ttsize[((int64)((*pc_decls_sptr).refelemtag))])==(int64)1)) {
        (*pc_decls_sptr).value = (p - q);
    } else if (((elemsize = pc_decls_ttsize[((int64)((*pc_decls_sptr).refelemtag))])==(int64)2)) {
        (*pc_decls_sptr).value = ((p - q) >> (int64)1);
    } else if (((elemsize = pc_decls_ttsize[((int64)((*pc_decls_sptr).refelemtag))])==(int64)4)) {
        (*pc_decls_sptr).value = ((p - q) >> (int64)2);
    }
    else {
        (*pc_decls_sptr).value = ((p - q) / elemsize);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_sub_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bigint_bn_sub(x,y,&result);
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_sub_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_dxfns_dx_subset(x,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_sub_z(void) {
    pc_support_pcmxtypes((byte*)"sub_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_sub_zz(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    y = pc_decls_sptr++;
    yt = (int64)((*y).tag);
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 23:;
        switch (yt) {
        case 1:;
            (*pc_decls_sptr).refptr = ((*pc_decls_sptr).refptr - ((*y).value * pc_decls_ttsize[((int64)((*pc_decls_sptr).refelemtag))]));
            return (pc_decls_pcptr + (int64)1);
            break;
        default:;
        }
        break;
    case 22:;
        switch (yt) {
        case 1:;
            (*pc_decls_sptr).varptr = ((*pc_decls_sptr).varptr - (*y).value);
            return (pc_decls_pcptr + (int64)1);
            break;
        default:;
        }
        break;
    default:;
    }
    pc_support_pcmxtypes((byte*)"sub/mixed_def",pc_decls_sptr,y);
    return (pc_decls_pcptr + (int64)1);
}

static uint64 * pc_jhandlers_j_mixed_iw_wi(void) {
    (*pc_decls_sptr).tag = (uint16)1u;
    return ((*(*pc_decls_opc_tableptr)[((int64)1)]))();
}

static uint64 * pc_jhandlers_j_mixed_ir(void) {
    struct pc_decls_varrec *  x;
    x = (pc_decls_sptr + (int64)1);
    (*x).tag = (uint16)3u;
    (*x).xvalue = (double)((*x).value);
    return ((*(*pc_decls_opc_tableptr)[((int64)3)]))();
}

static uint64 * pc_jhandlers_j_mixed_ri(void) {
    (*pc_decls_sptr).tag = (uint16)3u;
    (*pc_decls_sptr).xvalue = (double)((*pc_decls_sptr).value);
    return ((*(*pc_decls_opc_tableptr)[((int64)3)]))();
}

static uint64 * pc_jhandlers_j_mixed_ij(void) {
    pc_bigint_bn_makeint((*(pc_decls_sptr + (int64)1)).value,(pc_decls_sptr + (int64)1));
    return ((*(*pc_decls_opc_tableptr)[((int64)7)]))();
}

static uint64 * pc_jhandlers_j_mixed_ji(void) {
    pc_bigint_bn_makeint((*pc_decls_sptr).value,pc_decls_sptr);
    return ((*(*pc_decls_opc_tableptr)[((int64)7)]))();
}

uint64 * pc_jhandlers_j_mul_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value = ((*pc_decls_sptr).value * (*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_mul_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue *= (*y).xvalue;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_mul_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bigint_bn_mul(x,y,&result);
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_mul_z(void) {
    pc_support_pcmxtypes((byte*)"mul_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_mul_li(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_mul_listi(x,y,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_mul_si(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_mul_stri(x,y,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_mul_e(void) {
    return pc_jhandlers_j_iand_e();
}

uint64 * pc_jhandlers_j_mul_zz(void) {
    pc_support_pcmxtypes((byte*)"mul/zz",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_div_i(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue = ((double)((*pc_decls_sptr).value) / (double)((*y).value));
    (*pc_decls_sptr).tagx = (uint32)3u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_div_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue = ((*pc_decls_sptr).xvalue / (*y).xvalue);
    (*pc_decls_sptr).tagx = (uint32)3u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_div_z(void) {
    pc_support_pcmxtypes((byte*)"div_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_jumple_i(void) {
    if (((*(pc_decls_sptr + (int64)1)).value <= (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumple_r(void) {
    if (((*(pc_decls_sptr + (int64)1)).xvalue <= (*pc_decls_sptr).xvalue)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumple_s(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    px = (*x).objptr;
    py = (*y).objptr;
    res = pc_pcfns_cmpstringlen((*px).strptr,(*py).strptr,(int64)((*px).length),(int64)((*py).length));
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    if ((res <= (int64)0)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumple_z(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    printf("%s\n",(char*)((byte*)"JUMPLE/Z"));
    res = pc_pcfns_pc_compare(x,y);
    if ((res <= (int64)0)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpeq_i_r_t_o(void) {
    if (((*(pc_decls_sptr + (int64)1)).value == (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpeq_v_p_f_g(void) {
    if (((*(pc_decls_sptr + (int64)1)).refptr == (*pc_decls_sptr).refptr)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpeq_s(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_eqstring(x,y);
    if (!!(res)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpeq_z(void) {
    int64 res;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_equal(x,y,(int64)0);
    if (!!(res)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpeq_zz(void) {
    int64 res;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    return pc_jhandlers_j_jumpeq_z();
}

uint64 * pc_jhandlers_j_jumpne_i_r_t_o(void) {
    if (((*(pc_decls_sptr + (int64)1)).value != (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpne_v_p_f_g(void) {
    if (((*(pc_decls_sptr + (int64)1)).refptr != (*pc_decls_sptr).refptr)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpne_s(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    int64 res;
    int64 n;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    px = (*x).objptr;
    py = (*y).objptr;
    res = (int64)0;
    n = (int64)((*px).length);
    if ((n != (int64)((*py).length))    ) {
    }
    else if ((n == (int64)0)) {
        res = (int64)1;
    }
    else {
        if ((mlib_cmpstringn((*px).strptr,(*py).strptr,n) == (int64)0)) {
            res = (int64)1;
        }
    }
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    if ((res == (int64)0)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpne_z(void) {
    int64 res;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_equal(x,y,(int64)0);
    if (!(!!(res))) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpne_zz(void) {
    int64 res;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    return pc_jhandlers_j_jumpne_z();
}

uint64 * pc_jhandlers_j_jumpge_i(void) {
    if (((*(pc_decls_sptr + (int64)1)).value >= (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpge_w(void) {
    if (((*(pc_decls_sptr + (int64)1)).uvalue >= (*pc_decls_sptr).uvalue)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpge_r(void) {
    if (((*(pc_decls_sptr + (int64)1)).xvalue >= (*pc_decls_sptr).xvalue)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpge_z(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_compare(x,y);
    if ((res >= (int64)0)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpgt_i(void) {
    if (((*(pc_decls_sptr + (int64)1)).value > (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpgt_w(void) {
    if (((*(pc_decls_sptr + (int64)1)).uvalue > (*pc_decls_sptr).uvalue)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpgt_r(void) {
    if (((*(pc_decls_sptr + (int64)1)).xvalue > (*pc_decls_sptr).xvalue)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpgt_z(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_compare(x,y);
    if ((res > (int64)0)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumplt_i(void) {
    if (((*(pc_decls_sptr + (int64)1)).value < (*pc_decls_sptr).value)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumplt_v_p(void) {
    if (((*(pc_decls_sptr + (int64)1)).refptr < (*pc_decls_sptr).refptr)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumplt_r(void) {
    if (((*(pc_decls_sptr + (int64)1)).xvalue < (*pc_decls_sptr).xvalue)) {
        pc_decls_sptr += (int64)2;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    pc_decls_sptr += (int64)2;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumplt_z(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr++;
    x = pc_decls_sptr++;
    res = pc_pcfns_pc_compare(x,y);
    if ((res < (int64)0)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_pushix_li_mi(void) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec va;
    int64 index;
    int64 length;
    int64 acopy;
    va = (*(pc_decls_sptr + (int64)1));
    p = va.objptr;
    index = ((*pc_decls_sptr).value - (int64)((*p).lower));
    if (((uint32)(index) >= (*p).length)) {
        pc_support_pcerror((byte*)"list[int] bounds");
    }
    (*++pc_decls_sptr) = (*((*p).vptr + index));
    if (!!((*pc_decls_sptr).hasref)) {
        ++(*(*pc_decls_sptr).objptr).refcount;
    }
    if (!!(va.hasref)) {
        pc_pcfns_pc_ufree(&va);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_vi(void) {
    struct pc_decls_objrec *  p;
    int64 index;
    int64 length;
    index = (*pc_decls_sptr).value;
    ++pc_decls_sptr;
    (*pc_decls_sptr) = (*((*pc_decls_sptr).varptr + index));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_ln(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64 i;
    int64 j;
    int64 alower;
    int64 ahasref;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (int64)((*x).range_lower);
    j = (int64)((*x).range_upper);
    alower = (int64)((*p).lower);
    if ((((i < alower) || (j > (((int64)((*p).length) + alower) - (int64)1))) || (i > j))) {
        pc_support_pcerror((byte*)"list/slice bounds");
    }
    (*pc_decls_sptr).tagx = (uint32)(((int64)29 | (int64)65536));
    q = pc_objects_newobject();
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint8)1u;
    (*q).mutable = (*p).mutable;
    (*q).lower = (int32)1;
    if (((int64)((*p).objtype)==(int64)1)) {
        (*q).objptr2 = (*p).objptr2;
        ++(*(*q).objptr2).refcount;
        (*q).vptr = (((*p).vptr + i) - alower);
        v.tagx = (uint32)(((int64)29 | (int64)65536));
        v.objptr = p;
        pc_pcfns_pc_ufree(&v);
    } else if (((int64)((*p).objtype)==(int64)2)) {
        (*q).objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint8)2u;
        (*q).vptr = (((*p).vptr + i) - alower);
    }
    else {
        (*q).objptr2 = p;
        (*q).vptr = (((*p).vptr + i) - alower);
    }
    (*q).length = (uint32)(((j - i) + (int64)1));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_ll(void) {
    pc_support_junimpl((byte*)"pushix_listlist");
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_le(void) {
    pc_support_junimpl((byte*)"pushix_list_set");
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_ai(void) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  a;
    int64 index;
    int64 length;
    int64 elemtype;
    byte *  q;
    struct pc_decls_varrec va;
    va = (*(pc_decls_sptr + (int64)1));
    p = va.objptr;
    index = ((*pc_decls_sptr).value - (int64)((*p).lower));
    if (((uint32)(index) >= (*p).length)) {
        pc_support_pcerror((byte*)"ax[int] bounds");
    }
    if (((elemtype = (int64)((*p).elemtag)) == (int64)44)) {
        ++pc_decls_sptr;
        (*pc_decls_sptr).value = (int64)((*((*p).ptr + index)));
        (*pc_decls_sptr).tagx = (uint32)1u;
    }
    else {
        pc_pcfns_pc_loadpacked((void *)(((*p).ptr + (index * pc_decls_ttsize[(elemtype)]))),elemtype,++pc_decls_sptr,p);
    }
    if (!!(va.hasref)) {
        pc_pcfns_pc_ufree(&va);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_bi_ei(void) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  a;
    int64 index;
    int64 length;
    int64 elemtype;
    int64 offset;
    int64 shift;
    byte *  q;
    struct pc_decls_varrec va;
    va = (*(pc_decls_sptr + (int64)1));
    p = va.objptr;
    index = ((*pc_decls_sptr).value - (int64)((*p).lower));
    offset = ((int64)((*p).bitoffset) - (int64)1);
    q = (*p).ptr;
    if (((uint32)(index) >= (*p).length)) {
        pc_support_pcerror((byte*)"bits[int] bounds");
    }
    ++pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)1u;
    switch ((int64)((*p).elemtag)) {
    case 41:;
        index += offset;
        (*pc_decls_sptr).value = !!(((int64)((*(q + (index >> (int64)3)))) & ((int64)1 << (index & (int64)7))));
        break;
    case 42:;
        index += (offset >> (int64)1);
        shift = ((index & (int64)3) * (int64)2);
        (*pc_decls_sptr).value = (((int64)((*(q + (index >> (int64)2)))) & ((int64)3 << shift)) >> shift);
        break;
    case 43:;
        index += (offset >> (int64)2);
        shift = ((index & (int64)1) * (int64)4);
        (*pc_decls_sptr).value = (((int64)((*(q + (index >> (int64)1)))) & ((int64)15 << shift)) >> shift);
        break;
    default:;
        pc_support_pcustypet((byte*)"bitix",(int64)((*p).elemtag));
    }
    if (!!(va.hasref)) {
        pc_pcfns_pc_ufree(&va);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_an(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64 i;
    int64 j;
    int64 value;
    int64 offset;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (int64)((*x).range_lower);
    j = (int64)((*x).range_upper);
    if ((((i < (int64)((*p).lower)) || (j > (int64)((*p).length))) || (i > j))) {
        pc_support_pcerror((byte*)"ax[slice] bounds");
    }
    (*pc_decls_sptr).tagx = (*a).tagx;
    q = pc_objects_newobject();
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint8)1u;
    (*q).mutable = (*p).mutable;
    (*q).elemtag = (*p).elemtag;
    (*q).lower = (*p).lower;
    offset = ((i - (int64)((*p).lower)) * pc_decls_ttsize[((int64)((*p).elemtag))]);
    if (((int64)((*p).objtype)==(int64)1)) {
        (*q).objptr2 = (*p).objptr2;
        ++(*(*q).objptr2).refcount;
        (*q).strptr = ((*p).strptr + offset);
        v.tagx = (uint32)(((int64)5 | (int64)65536));
        v.objptr = p;
        pc_pcfns_pc_ufree(&v);
    } else if (((int64)((*p).objtype)==(int64)2)) {
        (*q).objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint8)2u;
        (*q).strptr = ((*p).strptr + offset);
    }
    else {
        (*q).objptr2 = p;
        (*q).strptr = ((*p).strptr + offset);
    }
    (*q).length = (uint32)(((j - i) + (int64)1));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_si(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64 index;
    int64 length;
    int64 i;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = ((*x).value - (int64)1);
    if (((uint32)(i) >= (*p).length)) {
        pc_support_pcerror((byte*)"string[int] bounds");
    }
    (*pc_decls_sptr).tagx = (uint32)(((int64)5 | (int64)65536));
    q = pc_objects_newobject();
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint8)1u;
    (*q).mutable = (*p).mutable;
    (*q).lower = (int32)1;
    if (((int64)((*p).objtype)==(int64)1)) {
        (*q).objptr2 = (*p).objptr2;
        ++(*(*q).objptr2).refcount;
        (*q).strptr = ((*p).strptr + i);
        v.tagx = (uint32)(((int64)5 | (int64)65536));
        v.objptr = p;
        pc_pcfns_pc_ufree(&v);
    } else if (((int64)((*p).objtype)==(int64)2)) {
        (*q).objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint8)2u;
        (*q).strptr = ((*p).strptr + i);
    }
    else {
        (*q).objptr2 = p;
        (*q).strptr = ((*p).strptr + i);
    }
    (*q).length = (uint32)1u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_sn(void) {
    return pc_jhandlers_j_pushdotix_sn();
}

uint64 * pc_jhandlers_j_pushix_bn(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64 i;
    int64 j;
    int64 value;
    int64 bitoffset;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    byte *  pbits;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (int64)((*x).range_lower);
    j = (int64)((*x).range_upper);
    if ((((i < (int64)((*p).lower)) || (j > (int64)((*p).length))) || (i > j))) {
        pc_support_pcerror((byte*)"bits[slice] bounds");
    }
    (*pc_decls_sptr).tagx = (*a).tagx;
    q = pc_objects_newobject();
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint8)1u;
    (*q).mutable = (*p).mutable;
    (*q).elemtag = (*p).elemtag;
    (*q).lower = (*p).lower;
    (*q).strptr = pc_pcfns_getbitoffset((*p).strptr,((int64)((*p).bitoffset) - (int64)1),(i - (int64)((*p).lower)),(int64)((*p).elemtag),&(*q).bitoffset);
    ++(*q).bitoffset;
    if (((int64)((*p).objtype)==(int64)1)) {
        (*q).objptr2 = (*p).objptr2;
        ++(*(*q).objptr2).refcount;
        v.tagx = (uint32)(((int64)5 | (int64)65536));
        v.objptr = p;
        pc_pcfns_pc_ufree(&v);
    } else if (((int64)((*p).objtype)==(int64)2)) {
        (*q).objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint8)2u;
    }
    else {
        (*q).objptr2 = p;
    }
    (*q).length = (uint32)(((j - i) + (int64)1));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_di(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64 i;
    int64 j;
    int64 alower;
    int64 ahasref;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (*x).value;
    j = (int64)((*x).range_upper);
    alower = (int64)((*p).lower);
    if (((i < (int64)1) || (j > (int64)((*p).allocated)))) {
        pc_support_pcerror((byte*)"dict[] bounds");
    }
    (*pc_decls_sptr).tagx = (uint32)(((int64)29 | (int64)65536));
    q = pc_objects_newobject();
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint8)1u;
    (*q).lower = (int32)1;
    (*q).length = (uint32)2u;
    (*q).objptr2 = p;
    (*q).vptr = ((*p).vptr + ((i - (int64)1) * (int64)2));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushix_zz(void) {
    struct pc_decls_varrec *  sptr1;
    pc_support_pcmxtypes((byte*)"pushix/def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (uint64 *)(0);
}

uint64 * pc_jhandlers_j_pushixref_li(void) {
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  a;
    int64 index;
    a = (*(pc_decls_sptr + (int64)1)).varptr;
    p = (*a).objptr;
    if (!(!!((*p).mutable))) {
        p = ((*a).objptr = pc_objects_copyonwrite(p,(int64)29));
    }
    index = ((*pc_decls_sptr).value - (int64)((*p).lower));
    if (((uint32)(index) >= (*p).length)) {
        if ((index < (int64)0)) {
            pc_support_pcerror((byte*)"LWB");
        }
        else {
            if ((((uint32)(index) == (*p).length) && ((int64)((*a).tag) == (int64)29))) {
                pc_pcfns_pc_iappendlist(a,(struct pc_decls_varrec *)(0));
                p = (*a).objptr;
            }
            else {
                pc_support_pcerror((byte*)"&pushix list[i] bounds");
            }
        }
    }
    (*++pc_decls_sptr).tagx = (uint32)22u;
    (*pc_decls_sptr).varptr = ((*p).vptr + index);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushixref_ln(void) {
    pc_support_junimpl((byte*)"pushixref_list_range");
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushixref_ai(void) {
    int64 index;
    int64 elemtype;
    int64 elemsize;
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  a;
    a = (*(pc_decls_sptr + (int64)1)).varptr;
    p = (*a).objptr;
    index = ((*pc_decls_sptr).value - (int64)((*p).lower));
    if (((uint32)(index) >= (*p).length)) {
        if ((index < (int64)0)) {
            pc_support_pcerror((byte*)"&AXLWB");
        }
        else {
            if (((uint32)(index) == (*p).length)) {
                pc_pcfns_pc_iappendarray(a,(struct pc_decls_varrec *)(0));
                p = (*a).objptr;
            }
            else {
                pc_support_pcerror((byte*)"&AXBOUNDS");
            }
        }
    }
    elemtype = (int64)((*p).elemtag);
    ++pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)23u;
    (*pc_decls_sptr).refelemtag = (uint16)(elemtype);
    (*pc_decls_sptr).refptr = ((*p).ptr + (index * pc_decls_ttsize[(elemtype)]));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushixref_si(void) {
    struct pc_decls_varrec *  a;
    int64 index;
    int64 newlength;
    int64 newbytes;
    struct pc_decls_objrec *  pa;
    a = (*(pc_decls_sptr + (int64)1)).varptr;
    pa = (*a).objptr;
    index = ((*pc_decls_sptr).value - (int64)1);
    if (!(!!((*pa).mutable))) {
        (*a).objptr = (pa = pc_objects_copyonwrite(pa,(int64)5));
    }
    if (((uint32)(index) >= (*pa).length)) {
        pc_support_pcerror((byte*)"&str[int] bounds");
    }
    (*++pc_decls_sptr).tagx = (uint32)23u;
    (*pc_decls_sptr).refelemtag = (uint16)5u;
    (*pc_decls_sptr).refptr = ((*pa).strptr + index);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushixref_bi_ei(void) {
    int64 index;
    int64 elemtype;
    int64 elemsize;
    int64 offset;
    struct pc_decls_objrec *  p;
    struct pc_decls_varrec *  a;
    a = (*(pc_decls_sptr + (int64)1)).varptr;
    p = (*a).objptr;
    index = ((*pc_decls_sptr).value - (int64)((*p).lower));
    if (((uint32)(index) >= (*p).length)) {
        if ((index < (int64)0)) {
            pc_support_pcerror((byte*)"&BITSLWB");
        }
        else {
            if (((uint32)(index) == (*p).length)) {
                pc_pcfns_pc_iappendbits(a,(struct pc_decls_varrec *)(0));
                p = (*a).objptr;
            }
            else {
                pc_support_pcerror((byte*)"&BITSBOUNDS");
            }
        }
    }
    elemtype = (int64)((*p).elemtag);
    ++pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)24u;
    (*pc_decls_sptr).refelemtag = (uint16)(elemtype);
    (*pc_decls_sptr).packptr = pc_pcfns_getbitoffset((*p).strptr,((int64)((*p).bitoffset) - (int64)1),index,elemtype,&(*pc_decls_sptr).refbitoffset);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushixref_zz(void) {
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  sptr1;
    pc_support_pcerror((byte*)"JPUSHIXREF/DEF");
    return (uint64 *)(0);
}

uint64 * pc_jhandlers_j_pushdotix_si(void) {
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64 index;
    int64 value;
    struct pc_decls_objrec *  p;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    index = ((*x).value - (int64)1);
    if (((uint32)(index) >= (*p).length)) {
        printf("%s %lld %s %u\n",(char*)((byte*)"INDEX="),(int64)index,(char*)((byte*)"P^.LENGTH="),(*p).length);
        pc_support_pcerror((byte*)"string.[int] bounds");
    }
    value = (int64)((*((*p).strptr + index)));
    if (!!((*a).hasref)) {
        pc_pcfns_pc_ufree(a);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushdotix_sn(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    int64 i;
    int64 j;
    int64 value;
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    x = pc_decls_sptr++;
    a = pc_decls_sptr;
    p = (*a).objptr;
    i = (int64)((*x).range_lower);
    j = (int64)((*x).range_upper);
    if ((((i < (int64)1) || (j > (int64)((*p).length))) || (i > j))) {
        pc_support_pcerror((byte*)"string[slice] bounds");
    }
    (*pc_decls_sptr).tagx = (uint32)(((int64)5 | (int64)65536));
    q = pc_objects_newobject();
    (*pc_decls_sptr).objptr = q;
    (*q).objtype = (uint8)1u;
    (*q).mutable = (*p).mutable;
    (*q).lower = (int32)1;
    if (((int64)((*p).objtype)==(int64)1)) {
        (*q).objptr2 = (*p).objptr2;
        ++(*(*q).objptr2).refcount;
        (*q).strptr = (((*p).strptr + i) - (int64)1);
        v.tagx = (uint32)(((int64)5 | (int64)65536));
        v.objptr = p;
        pc_pcfns_pc_ufree(&v);
    } else if (((int64)((*p).objtype)==(int64)2)) {
        (*q).objptr2 = (struct pc_decls_objrec *)(0);
        (*q).objtype = (uint8)2u;
        (*q).strptr = (((*p).strptr + i) - (int64)1);
    }
    else {
        (*q).objptr2 = p;
        (*q).strptr = (((*p).strptr + i) - (int64)1);
    }
    (*q).length = (uint32)(((j - i) + (int64)1));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushdotix_ii(void) {
    int64 index;
    index = (*pc_decls_sptr).value;
    ++pc_decls_sptr;
    if (((index < (int64)0) || (index >= (int64)64))) {
        pc_support_pcerror((byte*)"int.[int] bounds");
    }
    (*pc_decls_sptr).value = (((*pc_decls_sptr).value >> index) & (int64)1);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushdotix_in(void) {
    int64 i;
    int64 j;
    i = (int64)((*pc_decls_sptr).range_lower);
    j = (int64)((*pc_decls_sptr).range_upper);
    ++pc_decls_sptr;
    if ((j < i)) {
        {	int64 temp;
            temp = i;
            i = j;
            j = temp;
        }
    }
    if (((i >= (int64)64) || (j >= (int64)64))) {
        pc_support_pcerror((byte*)"int.[slice] bounds");
    }
    (*pc_decls_sptr).value = (((*pc_decls_sptr).value >> i) & (int64)(~(((uint64)18446744073709551615u << ((j - i) + (int64)1)))));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushdotix_ei(void) {
    return pc_jhandlers_j_pushix_bi_ei();
}

uint64 * pc_jhandlers_j_pushdotix_mi(void) {
    return pc_jhandlers_j_pushix_li_mi();
}

uint64 * pc_jhandlers_j_pushdotix_zz(void) {
    pc_support_pcmxtypes((byte*)"pushdotix/def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (uint64 *)(0);
}

uint64 * pc_jhandlers_j_pushdotixref_si(void) {
    struct pc_decls_varrec *  a;
    int64 index;
    int64 newlength;
    int64 newbytes;
    struct pc_decls_objrec *  pa;
    a = (*(pc_decls_sptr + (int64)1)).varptr;
    pa = (*a).objptr;
    index = ((*pc_decls_sptr).value - (int64)1);
    if (((uint32)(index) >= (*pa).length)) {
        pc_support_pcerror((byte*)"&str.[int] bounds");
    }
    (*++pc_decls_sptr).tagx = (uint32)23u;
    (*pc_decls_sptr).refelemtag = (uint16)44u;
    (*pc_decls_sptr).refptr = ((*pa).strptr + index);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushdotixref_sn(void) {
    struct pc_decls_varrec *  a;
    struct pc_decls_varrec *  x;
    byte *  p;
    int64 i;
    int64 j;
    int64 length;
    pc_support_pcerror((byte*)"JPUSHDOTIXREF/SRANGE");
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushdotixref_ii(void) {
    int64 index;
    byte *  p;
    index = (*pc_decls_sptr).value;
    ++pc_decls_sptr;
    if (((index < (int64)0) || (index >= (int64)64))) {
        pc_support_pcerror((byte*)"int.[int] bounds");
    }
    p = (*pc_decls_sptr).refptr;
    (*pc_decls_sptr).tagx = (uint32)24u;
    (*pc_decls_sptr).refelemtag = (uint16)41u;
    (*pc_decls_sptr).refbitoffset = (byte)((index & (int64)7));
    (*pc_decls_sptr).packptr = ((p + (int64)8) + (index >> (int64)3));
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_pushdotixref_ei(void) {
    return pc_jhandlers_j_pushixref_bi_ei();
}

uint64 * pc_jhandlers_j_pushdotixref_zz(void) {
    pc_support_pcmxtypes((byte*)"pushdotixref/def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (uint64 *)(0);
}

uint64 * pc_jhandlers_j_addto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value += (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_addto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue += (*y).xvalue;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_addto_s(void) {
    int64 xlen;
    int64 ylen;
    int64 newlen;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    px = (*x).objptr;
    py = (*y).objptr;
    if (!(!!((*px).mutable))) {
        (*x).objptr = (px = pc_objects_copyonwrite(px,(int64)5));
    }
    if (((int64)((*px).objtype) != (int64)0)) {
        pc_support_pcerror((byte*)"extending string slice");
    }
    xlen = (int64)((*px).length);
    ylen = (int64)((*py).length);
    if ((xlen == (int64)0)    ) {
        if (!!(ylen)) {
            (*px).strptr = (byte *)(mlib_pcm_alloc(ylen));
            (*px).allocated = (uint32)(mlib_allocbytes);
            (*px).length = (uint32)(ylen);
            memcpy((void *)((*px).strptr),(void *)((*py).strptr),(uint64)(ylen));
        }
    }
    else if ((ylen == (int64)1)) {
        if ((++xlen > (int64)((*px).allocated))) {
            pc_dxfns_resize_stringobj(px,xlen);
        }
        (*px).length = (uint32)(xlen);
        (*(((*px).strptr + xlen) - (int64)1)) = (*(*py).strptr);
    }
    else if (!!(ylen)) {
        newlen = (xlen + ylen);
        if ((newlen > (int64)((*px).allocated))) {
            pc_dxfns_resize_stringobj(px,newlen);
        }
        (*px).length = (uint32)(newlen);
        memcpy((void *)(((*px).strptr + xlen)),(void *)((*py).strptr),(uint64)(ylen));
    }
    pc_pcfns_pc_ufree(y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_addto_p(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    pc_support_pcerror((byte*)"ADDTO REF PACK");
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_addto_z(void) {
    pc_support_pcmxtypes((byte*)"addto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_addto_si(void) {
    int64 ch;
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 xlen;
    struct pc_decls_objrec *  px;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    ch = (*y).value;
    px = (*x).objptr;
    if (!(!!((*px).mutable))) {
        (*x).objptr = (px = pc_objects_copyonwrite(px,(int64)5));
    }
    xlen = (int64)((*px).length);
    if ((xlen == (int64)0)) {
        (*px).strptr = (byte *)(mlib_pcm_alloc((int64)1));
        (*px).allocated = (uint32)(mlib_allocbytes);
        (*px).length = (uint32)1u;
        (*(*px).strptr) = (byte)(ch);
    }
    else {
        if ((++xlen > (int64)((*px).allocated))) {
            pc_dxfns_resize_stringobj(px,xlen);
        }
        (*px).length = (uint32)(xlen);
        (*(((*px).strptr + xlen) - (int64)1)) = (byte)(ch);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_addto_ir(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value += (int64)((*y).xvalue);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_addto_ri(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue += (double)((*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_addto_zz(void) {
    pc_support_pcmxtypes((byte*)"addto_zz",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_subto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value -= (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_subto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue -= (*y).xvalue;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_subto_z(void) {
    pc_support_pcmxtypes((byte*)"subto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_multo_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value *= (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_multo_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue *= (*y).xvalue;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_multo_z(void) {
    pc_support_pcmxtypes((byte*)"multo_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_divto_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    pc_support_pcerror((byte*)"divto int?");
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_divto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue /= (*y).xvalue;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_divto_z(void) {
    pc_support_pcmxtypes((byte*)"divto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_idivto_i(void) {
    struct pc_decls_varrec *  y;
    pc_support_pcustype((byte*)"idivto",pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_idivto_z(void) {
    pc_support_pcmxtypes((byte*)"idivto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_iand_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value &= (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_iand_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_dxfns_dx_iandset(x,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_iand_z(void) {
    pc_support_pcmxtypes((byte*)"iand_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_ior_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value |= (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_ior_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    return pc_jhandlers_j_add_e();
}

uint64 * pc_jhandlers_j_ior_z(void) {
    pc_support_pcmxtypes((byte*)"ior_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_ixor_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value ^= (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_ixor_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_dxfns_dx_ixorset(x,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_ixor_z(void) {
    pc_support_pcmxtypes((byte*)"ixor_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_iandto_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value &= (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_iandto_z(void) {
    pc_support_pcmxtypes((byte*)"iandto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_iorto_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value |= (*y).value;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_iorto_z(void) {
    pc_support_pcmxtypes((byte*)"iorto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_ixorto_i_w(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value ^= (*y).value;
    return (pc_decls_pcptr + (int64)1);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_ixorto_z(void) {
    pc_support_pcmxtypes((byte*)"ixorto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shlto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value = ((*x).value << (*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shlto_z(void) {
    pc_support_pcmxtypes((byte*)"shlto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shrto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value = ((*x).value >> (*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shrto_z(void) {
    pc_support_pcmxtypes((byte*)"shrto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_concat_s(void) {
    return pc_jhandlers_j_add_s();
}

uint64 * pc_jhandlers_j_concat_l(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_duplvar(x);
    pc_pcfns_pc_iconcatlist(x,y);
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_concat_z(void) {
    pc_support_pcmxtypes((byte*)"concat_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_concatto_s(void) {
    pc_support_junimpl((byte*)"concatto_string");
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_concatto_l(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    pc_pcfns_pc_iconcatlist(x,y);
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_concatto_z(void) {
    pc_support_pcmxtypes((byte*)"concatto_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_append_s(void) {
    if (((int64)((*pc_decls_sptr).tag) != (int64)5)) {
        pc_support_pcustype((byte*)"append/s",pc_decls_sptr);
    }
    return pc_jhandlers_j_add_s();
}

uint64 * pc_jhandlers_j_append_l(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_duplvar(x);
    pc_pcfns_pc_iappendlist(x,y);
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_append_a(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_duplvar(x);
    pc_pcfns_pc_iappendarray(x,y);
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_append_b(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    pc_pcfns_pc_duplvar(x);
    pc_pcfns_pc_iappendbits(x,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_append_z(void) {
    pc_support_pcmxtypes((byte*)"append_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_appendto_s(void) {
    return pc_jhandlers_j_addto_s();
}

uint64 * pc_jhandlers_j_appendto_l(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    pc_pcfns_pc_iappendlist(x,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_appendto_a(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    pc_pcfns_pc_iappendarray(x,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_appendto_b_e(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    pc_pcfns_pc_iappendbits(x,y);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_appendto_z(void) {
    pc_support_pcmxtypes((byte*)"appendto_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_max_i(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value=((*pc_decls_sptr).value>(*y).value?(*pc_decls_sptr).value:(*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_max_r(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).xvalue=((*pc_decls_sptr).xvalue>(*y).xvalue?(*pc_decls_sptr).xvalue:(*y).xvalue);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_max_z(void) {
    int64 res;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    res = pc_pcfns_pc_compare_nf(pc_decls_sptr,y);
    if ((res >= (int64)0)) {
        pc_pcfns_pc_cfree(y);
    }
    else {
        pc_pcfns_pc_cfree(pc_decls_sptr);
        (*pc_decls_sptr) = (*y);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_min_z(void) {
    int64 res;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    res = pc_pcfns_pc_compare_nf(pc_decls_sptr,y);
    if ((res <= (int64)0)) {
        pc_pcfns_pc_cfree(y);
    }
    else {
        pc_pcfns_pc_cfree(pc_decls_sptr);
        (*pc_decls_sptr) = (*y);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_len_l_a_e_s_b_m_k_d(void) {
    int64 length;
    length = (int64)((*(*pc_decls_sptr).objptr).length);
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = length;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_len_n(void) {
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = ((int64)(((*pc_decls_sptr).range_upper - (*pc_decls_sptr).range_lower)) + (int64)1);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_len_z(void) {
    if (((int64)((*pc_decls_sptr).tag)==(int64)7)) {
        (*pc_decls_sptr).value = (((int64)((*(*pc_decls_sptr).objptr).length) - (int64)1) * (int64)6);
    } else if (((int64)((*pc_decls_sptr).tag)==(int64)10)) {
        (*pc_decls_sptr).value = ((int64)((*(*pc_decls_sptr).objptr).allocated) / (int64)2);
    }
    else {
        pc_support_pcustype((byte*)"len_def",pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_lwb_l_a_b(void) {
    int64 n;
    struct pc_decls_objrec *  p;
    p = (*pc_decls_sptr).objptr;
    n = (int64)((*p).lower);
    pc_pcfns_pc_ufree(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_lwb_s_m_k_d(void) {
    pc_pcfns_pc_ufree(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (int64)1;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_lwb_e(void) {
    struct pc_decls_objrec *  p;
    pc_pcfns_pc_ufree(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (int64)0;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_lwb_n(void) {
    (*pc_decls_sptr).value = (int64)((*pc_decls_sptr).range_lower);
    (*pc_decls_sptr).tagx = (uint32)1u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_lwb_z(void) {
    if (((int64)((*pc_decls_sptr).tag)==(int64)1)) {
        (*pc_decls_sptr).value = (int64)0;
        (*pc_decls_sptr).tagx = (uint32)1u;
    }
    else {
        pc_support_pcustype((byte*)"lwb_def",pc_decls_sptr);
    }
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_upb_l_a_b(void) {
    int64 n;
    struct pc_decls_objrec *  p;
    p = (*pc_decls_sptr).objptr;
    n = (int64)((uint32)(((int64)(((int32)((*p).length) + (*p).lower)) - (int64)1)));
    pc_pcfns_pc_ufree(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_upb_s_m_k_d(void) {
    int64 n;
    n = (int64)((*(*pc_decls_sptr).objptr).length);
    pc_pcfns_pc_ufree(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_upb_e(void) {
    int64 n;
    n = ((int64)((*(*pc_decls_sptr).objptr).length) - (int64)1);
    pc_pcfns_pc_ufree(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_upb_n(void) {
    (*pc_decls_sptr).value = (int64)((*pc_decls_sptr).range_upper);
    (*pc_decls_sptr).tagx = (uint32)1u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_upb_z(void) {
    if (((int64)((*pc_decls_sptr).tag)==(int64)10)) {
        (*pc_decls_sptr).value = ((int64)((*(*pc_decls_sptr).objptr).allocated) / (int64)2);
    } else if (((int64)((*pc_decls_sptr).tag)==(int64)1)) {
        (*pc_decls_sptr).value = (int64)63;
    }
    else {
        pc_support_pcustype((byte*)"upb_def",pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_bounds_l_a_b_s_m_k_e(void) {
    int64 a;
    int64 b;
    struct pc_decls_objrec *  r;
    r = (*pc_decls_sptr).objptr;
    if (((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])==(int64)5) || ((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])==(int64)32) || ((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])==(int64)33)) {
        a = (int64)1;
    } else if (((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])==(int64)9)) {
        a = (int64)0;
    }
    else {
        a = (int64)((*r).lower);
    }
    b = (((int64)((*r).length) + a) - (int64)1);
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)4u;
    (*pc_decls_sptr).range_lower = (int32)(a);
    (*pc_decls_sptr).range_upper = (int32)(b);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_bounds_n(void) {
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_bounds_z(void) {
    pc_support_pcustype((byte*)"bounds_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_minto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value=((*x).value<(*y).value?(*x).value:(*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_minto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue=((*x).xvalue<(*y).xvalue?(*x).xvalue:(*y).xvalue);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_minto_z(void) {
    pc_support_pcmxtypes((byte*)"minto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_maxto_i(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).value=((*x).value>(*y).value?(*x).value:(*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_maxto_r(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    x = (*pc_decls_sptr).varptr;
    ++pc_decls_sptr;
    (*x).xvalue=((*x).xvalue>(*y).xvalue?(*x).xvalue:(*y).xvalue);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_maxto_z(void) {
    pc_support_pcmxtypes((byte*)"maxto_def",(*(pc_decls_sptr + (int64)1)).varptr,pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_neg_i_w(void) {
    (*pc_decls_sptr).value = -((*pc_decls_sptr).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_neg_r(void) {
    (*pc_decls_sptr).xvalue = -((*pc_decls_sptr).xvalue);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_neg_j(void) {
    pc_pcfns_pc_duplvar(pc_decls_sptr);
    (*(*(*pc_decls_sptr).objptr).bnptr)[((int64)0)] ^= (int32)1;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_neg_e(void) {
    pc_dxfns_dx_inotset(pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_neg_z(void) {
    pc_support_pcustype((byte*)"neg_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_abs_i_w(void) {
    (*pc_decls_sptr).value = abs((*pc_decls_sptr).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_abs_r(void) {
    (*pc_decls_sptr).xvalue = fabs((*pc_decls_sptr).xvalue);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_abs_j(void) {
    pc_pcfns_pc_duplvar(pc_decls_sptr);
    (*(*(*pc_decls_sptr).objptr).bnptr)[((int64)0)] = (int32)0;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_abs_z(void) {
    pc_support_pcustype((byte*)"abs_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_inot_i_w(void) {
    (*pc_decls_sptr).value = ~((*pc_decls_sptr).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_inot_e(void) {
    pc_dxfns_dx_inotset(pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_inot_z(void) {
    pc_support_pcustype((byte*)"inot_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_istrue_i_w_r(void) {
    (*pc_decls_sptr).tag = (uint16)1u;
    (*pc_decls_sptr).value = !!((*pc_decls_sptr).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_istrue_l_a_e_s_b(void) {
    int64 res;
    res = (int64)(((int64)((*(*pc_decls_sptr).objptr).length) != (int64)0));
    pc_pcfns_pc_ufree(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = res;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_istrue_k_m_h(void) {
    pc_pcfns_pc_cfree(pc_decls_sptr);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (int64)1;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_istrue_j(void) {
    pc_support_junimpl((byte*)"istrue_longint");
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_istrue_z(void) {
    pc_support_pcustype((byte*)"istrue_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_jumpfalse_i_w_r_v_p_f(void) {
    if (!(!!((*pc_decls_sptr).value))) {
        ++pc_decls_sptr;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    ++pc_decls_sptr;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpfalse_s_l_e_a_b(void) {
    int64 n;
    n = (int64)((*(*pc_decls_sptr).objptr).length);
    pc_pcfns_pc_ufree(pc_decls_sptr);
    ++pc_decls_sptr;
    if ((n == (int64)0)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumpfalse_z(void) {
    switch ((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])) {
    case 32:;
    case 33:;
    case 25:;
        ++pc_decls_sptr;
        return (pc_decls_pcptr + (int64)2);
        break;
    default:;
    }
    pc_support_pcustype((byte*)"jumpfalse_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumptrue_i_r_w_v_p_f(void) {
    if (!!((*pc_decls_sptr).value)) {
        ++pc_decls_sptr;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    ++pc_decls_sptr;
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumptrue_s_l_e_a_b(void) {
    int64 n;
    n = (int64)((*(*pc_decls_sptr).objptr).length);
    pc_pcfns_pc_ufree(pc_decls_sptr);
    ++pc_decls_sptr;
    if (!!(n)) {
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
    }
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_jumptrue_z(void) {
    switch ((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])) {
    case 32:;
    case 33:;
    case 25:;
        ++pc_decls_sptr;
        return (uint64 *)((*(pc_decls_pcptr + (int64)1)));
        break;
    default:;
    }
    pc_support_pcustype((byte*)"jumptrue_def",pc_decls_sptr);
    return (pc_decls_pcptr + (int64)2);
}

uint64 * pc_jhandlers_j_shl_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value = ((*pc_decls_sptr).value << (*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shl_z(void) {
    pc_support_pcmxtypes((byte*)"shl_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shr_i(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value = ((*pc_decls_sptr).value >> (*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shr_z(void) {
    pc_support_pcmxtypes((byte*)"shr_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shr_wi(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).uvalue = ((*pc_decls_sptr).uvalue >> (*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_shr_zz(void) {
    struct pc_decls_varrec *  y;
    return pc_support_pcmxtypes((byte*)"shr_zz",(pc_decls_sptr + (int64)1),pc_decls_sptr);
}

uint64 * pc_jhandlers_j_idiv_i_w(void) {
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    (*pc_decls_sptr).value = ((*pc_decls_sptr).value / (*y).value);
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_idiv_j(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec result;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    pc_bigint_bn_div(x,y,&result);
    if (!!((*x).hasref)) {
        pc_pcfns_pc_ufree(x);
    }
    if (!!((*y).hasref)) {
        pc_pcfns_pc_ufree(y);
    }
    (*pc_decls_sptr) = result;
    return (pc_decls_pcptr + (int64)1);
}

uint64 * pc_jhandlers_j_idiv_z(void) {
    pc_support_pcmxtypes((byte*)"idiv_def",(pc_decls_sptr + (int64)1),pc_decls_sptr);
    return (pc_decls_pcptr + (int64)1);
}

int64 pc_oslayer_runproc_m(void * amsg) {
    struct pc_decls_varrec a;
    struct pc_decls_varrec b;
    struct pc_decls_varrec dest;
    static int64 rmsg_typeno;
    int64 i;
    int64 result;
    struct pc_decls_objrec obj;
    if ((rmsg_typeno == (int64)0)) {
L617:;
        for (i=(int64)1;i<=pc_decls_ntypes;++i) {
L618:;
            if (!!(mlib_eqstring(pc_decls_ttname[(i)],(byte*)"ws_msg64"))) {
                rmsg_typeno = i;
                goto L620;
            }
L619:;
        }
L620:;
    }
    if ((rmsg_typeno == (int64)0)) {
        mlib_abortprogram((byte*)"mainwndproc: can't find rmsg");
    }
    memset((void *)(&obj),(int32)0,(uint64)((int64)32));
    obj.refcount = (uint32)99u;
    obj.ptr = (byte *)(amsg);
    a.tagx = (uint32)((rmsg_typeno | (int64)65536));
    a.objptr = &obj;
    pc_runproc((void *)(pc_decls_pcl_callbackfn),&a,(struct pc_decls_varrec *)(0),&dest);
    result = dest.value;
    result = (int64)0;
    return result;
}

void pc_oslayer_os_getconsize(struct pc_decls_varrec * result) {
    uint64 aa;
    pc_support_pcerror((byte*)"GETCONSIZE");
}

void pc_oslayer_pch_setmesshandler(struct pc_decls_varrec * fn) {
    if (((int64)((*fn).tag) != (int64)18)) {
        pc_support_pcerror((byte*)"Not refproc");
    }
    pc_decls_pcl_callbackfn = (void (*)(void))((*fn).refptr);
    osnos_os_setmesshandler((void *)(&pc_oslayer_runproc_m));
}

void pc_oslayer_pch_gethostname(struct pc_decls_varrec * result) {
    static byte name[256];
    strcpy(name,osnos_os_gethostname());
    pc_pcfns_pc_makestring(name,(int64)-1,result);
}

void pc_oslayer_os_initdllmodules(void) {
    int64 i;
    int64 hinst;
    byte *  dllname;
L621:;
    for (i=(int64)1;i<=pc_decls_ndlltable;++i) {
L622:;
        dllname = pc_decls_dlltable[(i)-1];
        hinst = pc_oslayer_os_loaddllmodule(dllname);
        if ((hinst == (int64)0)) {
        }
        pc_decls_dllinsttable[(i)-1] = (uint64)(hinst);
L623:;
    }
L624:;
}

int64 pc_oslayer_os_loaddllmodule(byte * dllname) {
    int64 hinst;
    if (!!(mlib_eqstring(dllname,(byte*)"jpeglib"))    ) {
        dllname = (byte*)"jpeglib64";
    }
    else if (!!(mlib_eqstring(dllname,(byte*)"jpeglibc"))) {
        dllname = (byte*)"jpeglibc64";
    }
    hinst = (int64)(osnos_os_getdllinst(dllname));
    return hinst;
}

void pc_oslayer_os_initdllfunctions(void) {
    void (*fnaddr)(void);
    int64 hinst;
    int64 i;
    int64 dllmodno;
L625:;
    for (i=(int64)1;i<=pc_decls_ndllproctable;++i) {
L626:;
        dllmodno = (int64)(pc_decls_dllproctable[(i)-1].dllindex);
        hinst = (int64)(pc_decls_dllinsttable[(dllmodno)-1]);
        fnaddr = osnos_os_getdllprocaddr(hinst,pc_decls_dllproctable[(i)-1].name);
        if ((fnaddr == 0)) {
            if ((hinst == (int64)0)) {
                goto L627;
            }
            printf("%s %s %s %s\n",(char*)((byte*)"dllfns: fnaddr=0:"),(char*)(pc_decls_dllproctable[(i)-1].name),(char*)((byte*)"from"),(char*)(pc_decls_dlltable[(dllmodno)-1]));
        }
        pc_decls_dllproctable[(i)-1].address = fnaddr;
L627:;
    }
L628:;
}

void * pc_oslayer_os_loaddllfunction(int64 fnindex) {
    int64 dllmodno;
    int64 hinst;
    void (*fnaddr)(void);
    dllmodno = (int64)(pc_decls_dllproctable[(fnindex)-1].dllindex);
    hinst = (int64)(pc_decls_dllinsttable[(dllmodno)-1]);
    if (!(!!(hinst))) {
        hinst = pc_oslayer_os_loaddllmodule(pc_decls_dlltable[(dllmodno)-1]);
        if (!(!!(hinst))) {
        }
        else {
            pc_decls_dllinsttable[(dllmodno)-1] = (uint64)(hinst);
        }
    }
    fnaddr = osnos_os_getdllprocaddr(hinst,pc_decls_dllproctable[(fnindex)-1].name);
    if (!(!!(fnaddr))) {
        printf("%s\n",(char*)(pc_decls_dllproctable[(fnindex)-1].name));
        pc_support_pcerror((byte*)"Can't find DLL function");
        exit((int64)1);
    }
    else {
        pc_decls_dllproctable[(fnindex)-1].address = fnaddr;
    }
    return (void *)(fnaddr);
}

void pc_oslayer_pch_getos(struct pc_decls_varrec * result) {
    pc_pcfns_pc_makestring(osnos_os_getos(),(int64)-1,result);
}

void pc_oslayer_pch_gethostsize(struct pc_decls_varrec * result) {
    (*result).tagx = (uint32)1u;
    (*result).value = osnos_os_gethostsize();
}

void pc_oslayer_pch_iswindows(struct pc_decls_varrec * result) {
    (*result).tagx = (uint32)1u;
    (*result).value = osnos_os_iswindows();
}

void pc_oslayer_os_calldll(int64 calltype,int64 fnindex,int64 offset,int64 nparams,int64 restype,struct pc_decls_varrec * dest) {
    int64 baserestype;
    void (*fnaddr)(void);
    int64 retval;
    double fretval;
    int64 (*iparams)[];
    fnaddr = pc_decls_dllproctable[(fnindex)-1].address;
    if (!(!!(fnaddr))) {
        fnaddr = (void (*)(void))(pc_oslayer_os_loaddllfunction(fnindex));
        if (!!(fnaddr)) {
            pc_decls_dllproctable[(fnindex)-1].address = fnaddr;
        }
        else {
            printf("%s\n",(char*)(pc_decls_dllproctable[(fnindex)-1].name));
            pc_support_pcerror((byte*)"Calldll nil fn:");
        }
    }
    iparams = (int64 (*)[])(&pc_decls_dllparams[((offset + (int64)1))-1]);
    baserestype = (int64)(pc_decls_ttbasetype[(restype)]);
    if ((((int64)64 == (int64)64) && (calltype == (int64)87))) {
        calltype = (int64)67;
    }
    switch (baserestype) {
    case 39:;
    case 40:;
    case 0:;
    case 23:;
    case 50:;
    case 51:;
    case 52:;
    case 46:;
    case 45:;
    case 5:;
        if ((calltype==(int64)67)) {
            retval = pc_oslayer_calldll_cint(fnaddr,iparams,nparams);
        } else if ((calltype==(int64)77)) {
            retval = pc_oslayer_calldll_mint(fnaddr,iparams,nparams);
        } else if ((calltype==(int64)87)) {
            retval = osnosdll_os_calldll_wint((void *)(fnaddr),iparams,nparams);
        }
        if ((baserestype==(int64)0)) {
        } else if ((baserestype==(int64)40)) {
//doi64:
L629:;
            (*dest).tagx = (uint32)1u;
            (*dest).value = retval;
        } else if ((baserestype==(int64)39)) {
//doi32:
L630:;
            (*dest).tagx = (uint32)1u;
            (*dest).value = (int64)((int32)(retval));
        } else if ((baserestype==(int64)23)) {
            (*dest).tagx = (uint32)23u;
            (*dest).refptr = (byte *)((void *)(retval));
            (*dest).refelemtag = (uint16)(pc_decls_tttarget[(restype)]);
        } else if ((baserestype==(int64)50) || (baserestype==(int64)51) || (baserestype==(int64)52)) {
            goto L629;
        } else if ((baserestype==(int64)46)) {
            (*dest).tagx = (uint32)1u;
            (*dest).value = (int64)((uint32)(retval));
        } else if ((baserestype==(int64)45)) {
            (*dest).tagx = (uint32)1u;
            (*dest).value = (int64)((uint16)(retval));
        } else if ((baserestype==(int64)5)) {
            pc_pcfns_pc_makestring((byte *)(retval),(int64)-1,dest);
        }
        else {
            printf("%s\n",(char*)(pc_decls_ttname[(restype)]));
            pc_support_pcerror((byte*)"xxCALLDLL can't convert rettype");
        }
        break;
    case 49:;
    case 48:;
    case 3:;
        if ((calltype==(int64)67)) {
            fretval = pc_oslayer_calldll_creal(fnaddr,(double (*)[])(iparams),nparams);
        } else if ((calltype==(int64)77)) {
            fretval = pc_oslayer_calldll_mreal(fnaddr,iparams,nparams);
        } else if ((calltype==(int64)87)) {
            fretval = osnosdll_os_calldll_wreal((void *)(fnaddr),iparams,nparams);
        }
        (*dest).tagx = (uint32)3u;
        (*dest).xvalue = fretval;
        break;
    default:;
        printf("%s\n",(char*)(pc_decls_ttname[(baserestype)]));
        pc_support_pcerror((byte*)"CALLDLL unknown rettype");
    }
}

static int64 pc_oslayer_calldll_mint(void (*fnaddr)(void),int64 (*params)[],int64 nparams) {
    switch (nparams) {
    case 0:;
        return ((*(int64 (*)(void))(fnaddr)))();
        break;
    case 1:;
        return ((*(int64 (*)(int64))(fnaddr)))((*params)[((int64)1)-1]);
        break;
    case 2:;
        return ((*(int64 (*)(int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1]);
        break;
    case 3:;
        return ((*(int64 (*)(int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1]);
        break;
    case 4:;
        return ((*(int64 (*)(int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1]);
        break;
    case 5:;
        return ((*(int64 (*)(int64,int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1],(*params)[((int64)5)-1]);
        break;
    default:;
        pc_support_pcerror((byte*)"calldll/b/int too many params");
    }
    return (int64)0;
}

static double pc_oslayer_calldll_mreal(void (*fnaddr)(void),int64 (*params)[],int64 nparams) {
    switch (nparams) {
    case 0:;
        return ((*(double (*)(void))(fnaddr)))();
        break;
    case 1:;
        return ((*(double (*)(int64))(fnaddr)))((*params)[((int64)1)-1]);
        break;
    case 2:;
        return ((*(double (*)(int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1]);
        break;
    default:;
        pc_support_pcerror((byte*)"calldll/b/real too many params");
    }
    return (float)0.000000;
}

static int64 pc_oslayer_calldll_cint(void (*fnaddr)(void),int64 (*params)[],int64 nparams) {
    switch (nparams) {
    case 0:;
        return ((*(int64 (*)(void))(fnaddr)))();
        break;
    case 1:;
        return ((*(int64 (*)(int64))(fnaddr)))((*params)[((int64)1)-1]);
        break;
    case 2:;
        return ((*(int64 (*)(int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1]);
        break;
    case 3:;
        return ((*(int64 (*)(int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1]);
        break;
    case 4:;
        return ((*(int64 (*)(int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1]);
        break;
    case 5:;
        return ((*(int64 (*)(int64,int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1],(*params)[((int64)5)-1]);
        break;
    case 6:;
        return ((*(int64 (*)(int64,int64,int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1],(*params)[((int64)5)-1],(*params)[((int64)6)-1]);
        break;
    case 9:;
        return ((*(int64 (*)(int64,int64,int64,int64,int64,int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1],(*params)[((int64)5)-1],(*params)[((int64)6)-1],(*params)[((int64)7)-1],(*params)[((int64)8)-1],(*params)[((int64)9)-1]);
        break;
    case 10:;
        return ((*(int64 (*)(int64,int64,int64,int64,int64,int64,int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1],(*params)[((int64)5)-1],(*params)[((int64)6)-1],(*params)[((int64)7)-1],(*params)[((int64)8)-1],(*params)[((int64)9)-1],(*params)[((int64)10)-1]);
        break;
    case 11:;
        return ((*(int64 (*)(int64,int64,int64,int64,int64,int64,int64,int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1],(*params)[((int64)5)-1],(*params)[((int64)6)-1],(*params)[((int64)7)-1],(*params)[((int64)8)-1],(*params)[((int64)9)-1],(*params)[((int64)10)-1],(*params)[((int64)11)-1]);
        break;
    case 12:;
        return ((*(int64 (*)(int64,int64,int64,int64,int64,int64,int64,int64,int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1],(*params)[((int64)5)-1],(*params)[((int64)6)-1],(*params)[((int64)7)-1],(*params)[((int64)8)-1],(*params)[((int64)9)-1],(*params)[((int64)10)-1],(*params)[((int64)11)-1],(*params)[((int64)12)-1]);
        break;
    case 14:;
        return ((*(int64 (*)(int64,int64,int64,int64,int64,int64,int64,int64,int64,int64,int64,int64,int64,int64))(fnaddr)))((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1],(*params)[((int64)5)-1],(*params)[((int64)6)-1],(*params)[((int64)7)-1],(*params)[((int64)8)-1],(*params)[((int64)9)-1],(*params)[((int64)10)-1],(*params)[((int64)11)-1],(*params)[((int64)12)-1],(*params)[((int64)13)-1],(*params)[((int64)14)-1]);
        break;
    default:;
        printf("%lld\n",(int64)nparams);
        pc_support_pcerror((byte*)"calldll/c/int unsupported # of params");
    }
    return (int64)0;
}

static double pc_oslayer_calldll_creal(void (*fnaddr)(void),double (*params)[],int64 nparams) {
    switch (nparams) {
    case 0:;
        return ((*(double (*)(void))(fnaddr)))();
        break;
    case 1:;
        printf("%s\n",(char*)((byte*)"DLL/CREAL/1"));
        osnosdll_os_dummycall((*params)[((int64)1)-1],(*params)[((int64)2)-1],(*params)[((int64)3)-1],(*params)[((int64)4)-1]);
        return ((*(double (*)(int64))(fnaddr)))((int64)((*params)[((int64)1)-1]));
        break;
    case 2:;
        return ((*(double (*)(int64,int64))(fnaddr)))((int64)((*params)[((int64)1)-1]),(int64)((*params)[((int64)2)-1]));
        break;
    default:;
        pc_support_pcerror((byte*)"calldll/c/real too many params");
    }
    return (float)0.000000;
}

int64 osnosdll_os_calldll_wint(void * fnaddr,int64 (*params)[],int64 nparams) {
    return (int64)0;
}

double osnosdll_os_calldll_wreal(void * fnaddr,int64 (*params)[],int64 nparams) {
    return (float)0.000000;
}

void osnosdll_os_dummycall(double a,double b,double c,double d) {
}

void pc_host_callhostfunction(int64 hostfn,int64 calledasfn) {
    void (*fnaddr)(void);
    int64 nparams;
    int64 isfn;
    struct pc_decls_objrec *  p;
    int64 av_1;
    fnaddr = (void (*)(void))(pc_host_hosttable[(hostfn)-1]);
    nparams = pq_common_hostnparams[(hostfn)];
    isfn = pq_common_hostisfn[(hostfn)];
    if (!!(isfn)) {
        switch (nparams) {
        case 0:;
            ((*(void (*)(struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr);
            break;
        case 1:;
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64)1));
            break;
        case 2:;
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64)1),(pc_decls_sptr + (int64)2));
            break;
        case 3:;
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64)1),(pc_decls_sptr + (int64)2),(pc_decls_sptr + (int64)3));
            break;
        case 4:;
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64)1),(pc_decls_sptr + (int64)2),(pc_decls_sptr + (int64)3),(pc_decls_sptr + (int64)4));
            break;
        default:;
            pc_support_pcerror((byte*)"callhost/fn");
        }
    }
    else {
        switch (nparams) {
        case 0:;
            ((*fnaddr))();
            break;
        case 1:;
            ((*(void (*)(struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr);
            break;
        case 2:;
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64)1));
            break;
        case 3:;
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64)1),(pc_decls_sptr + (int64)2));
            break;
        case 4:;
            ((*(void (*)(struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *,struct pc_decls_varrec *))(fnaddr)))(pc_decls_sptr,(pc_decls_sptr + (int64)1),(pc_decls_sptr + (int64)2),(pc_decls_sptr + (int64)3));
            break;
        default:;
            pc_support_pcerror((byte*)"callhost/proc");
        }
    }
    av_1 = nparams;
    while (av_1-- > 0) {
L631:;
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        ++pc_decls_sptr;
L632:;
    }
L633:;
}

static void pc_host_pch_leftstr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result) {
    int64 n;
    int64 length;
    int64 padchar;
    byte *  s;
    struct pc_decls_objrec *  pa;
    padchar = (int64)32;
    if (((int64)((*c).tag)==(int64)0)) {
    } else if (((int64)((*c).tag)==(int64)5)) {
        if (((int64)((*(*c).objptr).length) == (int64)1)) {
            padchar = (int64)((*(*(*c).objptr).strptr));
        }
        else {
            pc_support_pcerror((byte*)"left/padx");
        }
    } else if (((int64)((*c).tag)==(int64)1)) {
        padchar = (*c).value;
    }
    else {
        pc_support_pcerror((byte*)"left/pad?");
    }
    if (((int64)((*b).tag)==(int64)0)) {
        n = (int64)1;
    } else if (((int64)((*b).tag)==(int64)1)) {
        n = (*b).value;
    }
    else {
        pc_support_pcerror((byte*)"left:bad n");
    }
    if (((int64)((*a).tag) != (int64)5)) {
        pc_support_pcerror((byte*)"left:not str");
    }
    pa = (*a).objptr;
    length = (int64)((*pa).length);
    s = (*pa).strptr;
    if ((n == (int64)0)) {
        pc_pcfns_pc_emptystring(result);
        return;
    }
    (*result).tagx = (uint32)(((int64)5 | (int64)65536));
    if ((n > (int64)0)) {
        if ((n <= length)) {
            pc_host_leftstring(a,n,result);
        }
        else {
            pc_host_padstring_right(a,n,padchar,result);
        }
    }
    else {
        n = -(n);
        if ((n < length)) {
            pc_host_leftstring(a,(length - n),result);
        }
        else {
            pc_pcfns_pc_emptystring(result);
        }
    }
}

static void pc_host_pch_rightstr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result) {
    int64 n;
    int64 length;
    int64 padchar;
    byte *  s;
    struct pc_decls_objrec *  pa;
    padchar = (int64)32;
    if (((int64)((*c).tag)==(int64)0)) {
    } else if (((int64)((*c).tag)==(int64)5)) {
        if (((int64)((*(*c).objptr).length) == (int64)1)) {
            padchar = (int64)((*(*(*c).objptr).strptr));
        }
        else {
            pc_support_pcerror((byte*)"right/padx");
        }
    } else if (((int64)((*c).tag)==(int64)1)) {
        padchar = (*c).value;
    }
    else {
        pc_support_pcerror((byte*)"right/pad?");
    }
    if (((int64)((*b).tag)==(int64)0)) {
        n = (int64)1;
    } else if (((int64)((*b).tag)==(int64)1)) {
        n = (*b).value;
    }
    else {
        pc_support_pcerror((byte*)"right:bad n");
    }
    pa = (*a).objptr;
    if (((int64)((*a).tag) != (int64)5)) {
        pc_support_pcerror((byte*)"right:not str");
    }
    length = (int64)((*pa).length);
    s = (*pa).strptr;
    (*result).tagx = (uint32)(((int64)5 | (int64)65536));
    if ((n == (int64)0)) {
        pc_pcfns_pc_emptystring(result);
        return;
    }
    if ((n > (int64)0)) {
        if ((n <= length)) {
            pc_host_rightstring(a,n,result);
        }
        else {
            pc_host_padstring_left(a,n,padchar,result);
        }
    }
    else {
        n = -(n);
        if ((n < length)) {
            pc_host_rightstring(a,(length - n),result);
        }
        else {
            pc_pcfns_pc_emptystring(result);
        }
    }
}

static void pc_host_pch_convlc(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    (*result) = (*a);
    ++(*(*result).objptr).refcount;
    if (!!((*result).hasref)) {
        pc_pcfns_pc_dupl(result);
    }
    pc_pcfns_pc_iconvcase(result,b,(int64)0);
}

static void pc_host_pch_convuc(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    (*result) = (*a);
    ++(*(*result).objptr).refcount;
    if (!!((*result).hasref)) {
        pc_pcfns_pc_dupl(result);
    }
    pc_pcfns_pc_iconvcase(result,b,(int64)1);
}

static void pc_host_pch_iconvlc(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    pc_host_checkparam(a,(int64)22,(int64)-999999);
    pc_pcfns_pc_iconvcase((*a).varptr,b,(int64)0);
}

static void pc_host_pch_iconvuc(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    pc_host_checkparam(a,(int64)22,(int64)-999999);
    pc_pcfns_pc_iconvcase((*a).varptr,b,(int64)1);
}

static void pc_host_pch_stop(void) {
    pc_support_pcerror((byte*)"host_stop not impl");
}

static void pc_host_pch_stopx(struct pc_decls_varrec * a) {
    pc_support_pcerror((byte*)"host_stopx not impl");
}

static void pc_host_pch_ismain(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    (*result).tagx = (uint32)1u;
    (*result).value = (int64)((pc_pcfns_cmpstringlen((*(*a).objptr).strptr,pc_decls_moduletable[(pc_decls_nmodules)].name,(int64)((*(*a).objptr).length),(int64)(strlen(pc_decls_moduletable[(pc_decls_nmodules)].name))) == (int64)0));
}

static void pc_host_pch_waitkey(struct pc_decls_varrec * result) {
    (*result).tagx = (uint32)1u;
    (*result).value = osnos_os_getch();
}

static void pc_host_pch_testkey(struct pc_decls_varrec * result) {
    (*result).tagx = (uint32)1u;
    (*result).value = osnos_os_kbhit();
}

static void pc_host_pch_execwait(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result) {
    byte *  workdir;
    int64 flag;
    struct pc_decls_objrec *  pa;
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    pa = (*a).objptr;
    flag = pc_host_checkparam(b,(int64)1,(int64)0);
    if (((int64)((*c).tag) == (int64)0)) {
        workdir = (byte *)(0);
    }
    else {
        pc_host_checkparam(c,(int64)5,(int64)-999999);
        workdir = pc_support_convcstring((*(*c).objptr).strptr,(int64)((*(*c).objptr).length));
    }
    (*result).tagx = (uint32)1u;
    (*result).value = osnos_os_execwait(pc_support_convcstring((*pa).strptr,(int64)((*pa).length)),flag,workdir);
}

static void pc_host_pch_execcmd(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * result) {
    byte *  workdir;
    int64 flag;
    struct pc_decls_objrec *  pa;
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    pa = (*a).objptr;
    flag = pc_host_checkparam(b,(int64)1,(int64)0);
    if (((int64)((*c).tag) == (int64)0)) {
        workdir = (byte *)(0);
    }
    else {
        pc_host_checkparam(c,(int64)5,(int64)-999999);
        workdir = pc_support_convcstring((*(*c).objptr).strptr,(int64)((*(*c).objptr).length));
    }
    (*result).tagx = (uint32)1u;
    (*result).value = osnos_os_execcmd(pc_support_convcstring((*pa).strptr,(int64)((*pa).length)),flag);
}

static void pc_host_pch_makestr(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    int64 n;
    struct pc_decls_objrec *  s;
    switch ((int64)((*a).tag)) {
    case 23:;
        break;
    case 1:;
        break;
    default:;
        pc_support_pcerror((byte*)"makestr");
    }
    n = pc_support_getintvalue(b);
    (*result).tagx = (uint32)(((int64)5 | (int64)65536));
    s = pc_objects_make_strslicexobj((*a).refptr,n);
    (*result).objptr = s;
}

static void pc_host_pch_makestrslice(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_support_pcerror((byte*)"MAKESTRSLICE");
}

static void pc_host_pch_makeref(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    byte *  ptr;
    switch ((int64)(pc_decls_ttbasetype[((int64)((*a).tag))])) {
    case 22:;
    case 23:;
    case 1:;
        ptr = (*a).refptr;
        break;
    case 5:;
    case 30:;
    case 29:;
    case 9:;
        ptr = (*(*a).objptr).ptr;
        break;
    default:;
        pc_support_pcerror((byte*)"makeref");
    }
    (*result).tagx = (uint32)23u;
    (*result).refptr = ptr;
    (*result).refelemtag = (uint16)(pc_support_getintvalue(b));
    if (((int64)((*result).refelemtag)==(int64)41) || ((int64)((*result).refelemtag)==(int64)42) || ((int64)((*result).refelemtag)==(int64)43)) {
        (*result).tag = (uint16)24u;
        (*result).refbitoffset = (uint8)0u;
    }
}

static void pc_host_pch_new(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * d,struct pc_decls_varrec * result) {
    struct pc_decls_varrec v;
    int64 i;
    int64 t;
    int64 nbytes;
    int64 ival;
    int64 nwords;
    int64 nbits;
    int64 offset;
    int64 elemtype;
    int64 n;
    struct pc_host_dimrec dims;
    struct pc_decls_varrec *  qvar;
    int64 *  qint;
    byte *  qbyte;
    byte *  ptr;
    struct pc_decls_objrec *  p;
    int64 av_1;
    int64 av_2;
    int64 av_3;
    int64 av_4;
    t = pc_support_getintvalue(a);
    if (((t < (int64)0) || (t > pc_decls_ntypes))) {
        pc_support_pcustypet((byte*)"New:bad type",t);
    }
    v.tagx = (uint32)((t | (int64)65536));
    switch ((int64)(pc_decls_ttbasetype[(t)])) {
    case 29:;
        pc_host_getbounds(b,&dims,(int64)1);
        p = pc_objects_make_listobj(dims.length,dims.lbound);
        v.objptr = p;
        if (!!(dims.length)) {
            if ((!!(c) && ((int64)((*c).tag) != (int64)0))) {
                qvar = (*p).vptr;
                av_1 = dims.length;
                while (av_1-- > 0) {
L634:;
                    (*qvar) = (*c);
                    if (!!((*qvar).hasref)) {
                        pc_pcfns_pc_ushare(qvar);
                    }
                    ++qvar;
L635:;
                }
L636:;
            }
        }
        break;
    case 30:;
        if (!!(pc_decls_ttlength[(t)])) {
            elemtype = (int64)(pc_decls_tttarget[(t)]);
            dims.length = (int64)(pc_decls_ttlength[(t)]);
            dims.lbound = (int64)(pc_decls_ttlower[(t)]);
            dims.upper = ((dims.length + dims.lbound) - (int64)1);
            d = b;
            goto L637;
        }
        elemtype = pc_support_getintvalue(b);
        pc_host_getbounds(c,&dims,(int64)1);
        if (((elemtype >= (int64)41) && (elemtype <= (int64)43))) {
            v.tag = (uint16)((t = (int64)31));
            goto L638;
        }
//doarray2:
L637:;
        p = pc_objects_make_arrayobj(dims.length,elemtype,dims.lbound);
        v.objptr = p;
        if (!!(dims.length)) {
            if ((!!(d) && ((int64)((*d).tag) != (int64)0))) {
                qbyte = (*p).ptr;
                av_2 = dims.length;
                while (av_2-- > 0) {
L639:;
                    pc_pcfns_pc_storepacked(qbyte,d,elemtype);
                    qbyte += pc_decls_ttsize[(elemtype)];
L640:;
                }
L641:;
            }
        }
        break;
    case 31:;
        if (!!(pc_decls_ttlength[(t)])) {
            elemtype = (int64)(pc_decls_tttarget[(t)]);
            dims.length = (int64)(pc_decls_ttlength[(t)]);
            dims.lbound = (int64)(pc_decls_ttlower[(t)]);
            dims.upper = ((dims.length + dims.lbound) - (int64)1);
            d = b;
            goto L638;
        }
        elemtype = pc_support_getintvalue(b);
        if (((elemtype < (int64)41) || (elemtype > (int64)43))) {
            pc_support_pcerror((byte*)"new: bad bits elem");
        }
        pc_host_getbounds(c,&dims,(int64)1);
//dobits2:
L638:;
        p = pc_objects_make_bitsobj(dims.length,elemtype,dims.lbound);
        v.objptr = p;
        if (!!(dims.length)) {
            if ((!!(d) && ((int64)((*d).tag) != (int64)0))) {
                qbyte = (*p).ptr;
                offset = (int64)0;
                av_3 = dims.length;
                while (av_3-- > 0) {
L642:;
                    pc_pcfns_pc_storebit(qbyte,offset,d,elemtype);
                    offset += (int64)(pc_decls_ttbitwidth[(elemtype)]);
                    if ((offset >= (int64)8)) {
                        offset = (int64)0;
                        ++qbyte;
                    }
L643:;
                }
L644:;
            }
        }
        break;
    case 9:;
        pc_host_getbounds(b,&dims,(int64)0);
        if ((dims.lbound < (int64)0)) {
            pc_support_pcerror((byte*)"new:set:lwb");
        }
        if ((dims.lbound != (int64)0)) {
            dims.lbound = (int64)0;
            dims.length = (dims.upper + (int64)1);
        }
        p = pc_objects_make_setobj(dims.length);
        v.objptr = p;
        break;
    case 32:;
        p = pc_objects_make_listobj((int64)(pc_decls_ttlength[(t)]),(int64)1);
        (*p).mutable = (uint8)1u;
        v.objptr = p;
        if ((!!(b) && ((int64)((*b).tag) != (int64)0))) {
            qvar = (*p).vptr;
            av_4 = (int64)((*p).length);
            while (av_4-- > 0) {
L645:;
                (*qvar) = (*b);
                if (!!((*qvar).hasref)) {
                    pc_pcfns_pc_ushare(qvar);
                }
                ++qvar;
L646:;
            }
L647:;
        }
        break;
    case 33:;
        p = pc_objects_newobject();
        (*p).vptr = pc_objects_make_arraydata(pc_decls_ttsize[(t)],(int64)44,&(*p).allocated,(int64)1);
        (*p).lower = (int32)1;
        (*p).mutable = (uint8)1u;
        (*p).length = pc_decls_ttlength[(t)];
        v.objptr = p;
        if ((!!(b) && ((int64)((*b).tag) != (int64)0))) {
            pc_support_pcerror((byte*)"New: struct init");
        }
        break;
    case 1:;
    case 2:;
    case 3:;
    case 18:;
    case 22:;
        v.value = (int64)0;
        if ((!!(b) && ((int64)((*b).tag) != (int64)0))) {
            pc_support_pcerror((byte*)"NEW(int/value)");
        }
        break;
    case 10:;
        pc_host_getbounds(b,&dims,(int64)1);
        n = pc_support_nextpoweroftwo(dims.length);
        p = pc_objects_make_listobj(msysc_m_imax((int64)16,(n * (int64)2)),(int64)1);
        (*p).dictitems = (uint32)0u;
        v.objptr = p;
        break;
    default:;
        pc_support_pcustypet((byte*)"new",t);
    }
//finish:
L648:;
    (*result) = v;
}

static void pc_host_pch_newheap(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c,struct pc_decls_varrec * d,struct pc_decls_varrec * result) {
    struct pc_decls_varrec *  p;
    p = (struct pc_decls_varrec *)(mlib_pcm_alloc((int64)16));
    pc_host_pch_new(a,b,c,d,p);
    (*result).tagx = (uint32)22u;
    (*result).varptr = p;
}

static void pc_host_pch_heapvar(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    struct pc_decls_varrec *  p;
    pc_support_pcerror((byte*)"HEAPVAR");
}

static void pc_host_pch_freeheap(struct pc_decls_varrec * a) {
    pc_support_pcerror((byte*)"FREEHEAP");
}

static void pc_host_pch_getcmdparam(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    int64 n;
    byte *  s;
    if (((int64)((*a).tag) == (int64)0)) {
        (*result).tagx = (uint32)1u;
        (*result).value = (pc_decls_ncmdparams + (int64)1);
        return;
    }
    n = pc_support_getintvalue(a);
    pc_pcfns_pc_makestring(pc_decls_cmdparamtable[(n)],(int64)-1,result);
}

static void pc_host_pch_setpcerror(struct pc_decls_varrec * a) {
    struct pc_decls_objrec *  pa;
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    pa = (*a).objptr;
    if (!!(pc_decls_pcerror_mess)) {
        free((void *)(pc_decls_pcerror_mess));
        pc_decls_pcerror_mess = (byte *)(0);
    }
    if (!!((*pa).length)) {
        pc_decls_pcerror_mess = (byte *)(malloc((uint64)(((int64)((*pa).length) + (int64)1))));
        memcpy((void *)(pc_decls_pcerror_mess),(void *)((*pa).strptr),(uint64)((*pa).length));
        (*(pc_decls_pcerror_mess + (int64)((*pa).length))) = (uint8)0u;
    }
}

static void pc_host_pch_setdebug(struct pc_decls_varrec * a) {
    pc_host_checkparam(a,(int64)1,(int64)-999999);
    printf("%s\n",(char*)((byte*)"SETDEBUG................."));
    mlib_fdebug = (*a).value;
}

static void pc_host_pch_setfprintf(struct pc_decls_varrec * a,struct pc_decls_varrec * b) {
    pc_host_checkparam(a,(int64)19,(int64)-999999);
    pc_host_checkparam(b,(int64)19,(int64)-999999);
    pc_decls_fprintf_ptr = (void (*)(void))((*a).refptr);
    pc_decls_fgets_ptr = (void (*)(void))((*b).refptr);
}

static void pc_host_pch_ticks(struct pc_decls_varrec * result) {
    (*result).tagx = (uint32)1u;
    (*result).value = osnos_os_clock();
}

static void pc_host_pch_sleep(struct pc_decls_varrec * a) {
    pc_host_checkparam(a,(int64)1,(int64)-999999);
    osnos_os_sleep((*a).value);
}

static void pc_host_pch_random(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    int64 n;
    int64 x;
    int64 r;
    r = (int64)(((rand() << (int64)15) | rand()));
    (*result).tagx = (uint32)1u;
    if (((int64)((*a).tag) == (int64)4)) {
        x = ((r % ((int64)(((*a).range_upper - (*a).range_lower)) + (int64)1)) + (int64)((*a).range_lower));
    }
    else {
        pc_host_checkparam(a,(int64)1,(int64)-999999);
        n = (*a).value;
        if ((n > (int64)1)        ) {
            x = (r % n);
        }
        else if ((n == (int64)0)) {
            x = r;
        }
        else if ((n == (int64)1)) {
            (*result).tagx = (uint32)3u;
            (*result).xvalue = ((double)(r) / (float)1073741824.000000);
            return;
        }
        else {
            srand((uint32)(-(n)));
            x = (int64)0;
        }
    }
    (*result).value = x;
}

static void pc_host_pch_findmetafunction(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    int64 i;
    byte *  sdata;
    struct pc_decls_objrec *  pa;
    struct pc_decls_procrec *  pp;
    struct pc_decls_strec *  d;
    int64 av_1;
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    pa = (*a).objptr;
    (*result).tagx = (uint32)18u;
    (*result).value = (int64)0;
    if (!!((*pa).length)) {
        sdata = pc_support_convcstring((*pa).strptr,(int64)((*pa).length));
    }
    else {
        return;
    }
    if (!!(pc_decls_runfrompc)) {
        d = &(*pc_decls_pcsymboltable)[((int64)1)-1];
        av_1 = pc_decls_nsymbols;
        while (av_1-- > 0) {
L649:;
            if (((int64)((*d).nameid) == (int64)6)) {
                if ((!!((*d).metadata) && (strstr((*d).metadata,sdata) != 0))) {
                    (*result).refptr = (byte *)((*d).address);
                    return;
                }
            }
            ++d;
L650:;
        }
L651:;
    }
    else {
        pp = pc_decls_proclist;
L652:;
        while (!!(pp)) {
            d = (*pp).def;
            if ((!!((*d).metadata) && (strstr((*d).metadata,sdata) != 0))) {
                (*result).refptr = (byte *)((*d).address);
                return;
            }
            pp = (*pp).nextproc;
L653:;
        }
L654:;
    }
}

static void pc_host_pch_loadpcl(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_support_pcerror((byte*)"host_loadpcl not impl");
}

static void pc_host_pch_runpcl(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_support_pcerror((byte*)"host_runpcl not impl");
}

static void pc_host_pch_runtask(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    pc_support_pcerror((byte*)"host_runtask not impl");
}

static void pc_host_pch_callext(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    pc_support_pcerror((byte*)"host_callext not impl");
}

static void pc_host_pch_system(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    (*result).tagx = (uint32)1u;
    (*result).value = (int64)(system(pc_support_convcstring((*(*a).objptr).strptr,(int64)((*(*a).objptr).length))));
}

static void pc_host_pch_shellexec(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  pa;
    struct pc_decls_objrec *  pb;
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    pc_host_checkparam(b,(int64)5,(int64)-999999);
    pa = (*a).objptr;
    pb = (*b).objptr;
    (*result).tagx = (uint32)1u;
    (*result).value = osnos_os_shellexec(pc_support_convcstring((*pa).strptr,(int64)((*pa).length)),pc_support_convcstring((*pb).strptr,(int64)((*pb).length)));
}

static void pc_host_pch_gethash(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    (*result).tagx = (uint32)1u;
    (*result).value = pc_pcfns_gethashvalue(a);
}

static void pc_host_pch_test(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  p;
    struct pc_decls_objrec *  q;
    int64 i;
    p = (*a).objptr;
    printf("%s %s %u\n",(char*)((byte*)"*****************************TEST:"),(char*)((byte*)"A^.TAG="),(*a).tag);
    if (((int64)((*a).tag) > (int64)100)) {
        pc_support_pcerror((byte*)"BAD TAG");
    }
    (*result).tagx = (uint32)1u;
}

static void pc_host_pch_pcldata(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * result) {
    int64 res;
    int64 length;
    int64 i;
    struct pc_decls_strec *  d;
    int64 av_1;
    pc_host_checkparam(a,(int64)1,(int64)-999999);
    res = (int64)0;
    if (((*a).value==(int64)6073471649054675536)) {
        if (((pc_decls_proclist == 0) && !!(pc_decls_runfrompc))) {
            d = &(*pc_decls_pcsymboltable)[((int64)1)-1];
            av_1 = pc_decls_nsymbols;
            while (av_1-- > 0) {
L655:;
                if (((int64)((*d).nameid) == (int64)6)) {
                    pc_host_addtoproclist(d);
                }
                ++d;
L656:;
            }
L657:;
        }
        pc_host_proclistptr = pc_decls_proclist;
    } else if (((*a).value==(int64)1129271888)) {
        if (!!(pc_host_proclistptr)) {
            pc_host_getproctabledata(pc_host_proclistptr,result);
            pc_host_proclistptr = (*pc_host_proclistptr).nextproc;
            return;
        }
    } else if (((*a).value==(int64)76194150371149)) {
        printf("%s\n",(char*)((byte*)"MODULE"));
    } else if (((*a).value==(int64)19506716274347331)) {
        pc_pcfns_pc_makestring(pq_common_cmdnames[((*b).value)],(int64)-1,result);
        return;
    } else if (((*a).value==(int64)19496880614690115)) {
L658:;
        for (i=(int64)1;i<=(int64)216;++i) {
L659:;
            length = (int64)(strlen(pq_common_cmdnames[(i)]));
            if ((((int64)((*(*b).objptr).length) == length) && ((int64)(memcmp((void *)((*(*b).objptr).strptr),(void *)(pq_common_cmdnames[(i)]),(uint64)(length))) == (int64)0))) {
                res = i;
                goto L661;
            }
L660:;
        }
L661:;
    } else if (((*a).value==(int64)91552836767566)) {
        res = pc_decls_cmdnopnds[((*b).value)];
    }
    else {
        pc_support_pcerror((byte*)"pcldata/bad table");
    }
    (*result).tagx = (uint32)1u;
    (*result).value = res;
}

static void pc_host_pch_getcstring(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_support_pcerror((byte*)"PCH/GETCSTRING");
}

static void pc_host_pch_getparam(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64)1,(int64)-999999);
    (*result) = (*(struct pc_decls_varrec *)((pc_decls_frameptr + ((*a).value * (int64)16))));
    if (!!((*result).hasref)) {
        ++(*(*result).objptr).refcount;
    }
}

static void pc_host_pch_clearlist(struct pc_decls_varrec * a) {
    int64 n;
    pc_support_pcerror((byte*)"PCH CLEARLIST");
}

static void pc_host_pch_makelink(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    if (((int64)(pc_decls_ttbasetype[((int64)((*a).tag))])==(int64)32)) {
        (*result).tagx = (uint32)25u;
        (*result).refelemtag = (*a).tag;
        (*result).objptr = (*a).objptr;
    } else if (((int64)(pc_decls_ttbasetype[((int64)((*a).tag))])==(int64)1)) {
        if (!!((*a).value)) {
            pc_support_pcerror((byte*)"makelink/int");
        }
        (*result).tagx = (uint32)1u;
        (*result).value = (int64)0;
    } else if (((int64)(pc_decls_ttbasetype[((int64)((*a).tag))])==(int64)25)) {
    }
    else {
        printf("%s\n",(char*)(pc_decls_ttname[((int64)((*a).tag))]));
        printf("%s\n",(char*)(pc_decls_ttname[((int64)(pc_decls_ttbasetype[((int64)((*a).tag))]))]));
        pc_support_pcerror((byte*)"makelink: not record/list");
    }
}

static void pc_host_pch_allparams(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  p;
    int64 nparams;
    int64 isfn;
    int64 i;
    struct pc_decls_varrec *  q;
    uint64 *  fnptr;
    pc_host_checkparam(a,(int64)18,(int64)-999999);
    fnptr = (uint64 *)((*a).refptr);
    nparams = (int64)((*(fnptr - (int64)1)));
    p = pc_objects_newobject();
    (*p).objtype = (uint8)2u;
    (*p).length = (uint32)(nparams);
    (*p).lower = (int32)1;
    (*p).vptr = ((struct pc_decls_varrec *)(pc_decls_frameptr) + (int64)1);
    (*result).tagx = (uint32)(((int64)29 | (int64)65536));
    (*result).objptr = p;
}

static void pc_host_pch_stackvars(struct pc_decls_varrec * result) {
    pc_support_pcerror((byte*)"STACKVARS");
}

static void pc_host_pch_makeempty(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  p;
    int64 t;
    t = (int64)(pc_decls_ttbasetype[((int64)((*a).tag))]);
    if ((t == (int64)13)) {
        t = (*a).value;
    }
    if ((t==(int64)29)) {
        p = pc_objects_emptylist;
        ++(*p).refcount;
    } else if ((t==(int64)5)) {
        pc_pcfns_pc_emptystring(result);
        return;
    } else if ((t==(int64)30)) {
        p = pc_objects_newobject();
        (*p).lower = (int32)1;
        (*p).elemtag = (*(*a).objptr).elemtag;
    }
    else {
        pc_support_pcustypet((byte*)"makeempty?",t);
    }
    (*result).tagx = (uint32)((t | (int64)65536));
    (*result).objptr = p;
}

static void pc_host_pch_readlines(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    byte *  p;
    byte *  q;
    byte *  pstart;
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  r;
    struct pc_decls_objrec *  l;
    int64 nlines;
    int64 n;
    pc_host_checkparam(a,(int64)5,(int64)-999999);
    if (((int64)((*(*a).objptr).length) == (int64)0)) {
//error:
L662:;
        (*result).tagx = (uint32)1u;
        (*result).value = (int64)0;
        return;
    }
    p = mlib_readfile((*(*a).objptr).strptr);
    if ((p == 0)) {
        goto L662;
    }
    q = p;
    nlines = (int64)0;
L663:;
    switch ((int64)((*q++))) {
    case 26:;
        goto L664;
        break;
    case 13:;
        ++nlines;
        if (((int64)((*q)) == (int64)10)) {
            ++q;
        }
        break;
    case 10:;
        ++nlines;
        break;
    default:;
    }
    goto L663;
L664:;
    v.tagx = (uint32)(((int64)29 | (int64)65536));
    v.objptr = pc_objects_make_listobj(nlines,(int64)1);
    r = (*v.objptr).vptr;
    q = p;
    pstart = q;
L665:;
    switch ((int64)((*q++))) {
    case 26:;
        goto L666;
        break;
    case 13:;
        n = ((q - pstart) - (int64)1);
        if (((int64)((*q)) == (int64)10)) {
            ++q;
        }
//addline:
L667:;
        pc_pcfns_pc_makestring(pstart,n,r);
        ++r;
        pstart = q;
        break;
    case 10:;
        n = ((q - pstart) - (int64)1);
        goto L667;
        break;
    default:;
    }
    goto L665;
L666:;
    (*result) = v;
    free((void *)(p));
}

static void pc_host_pch_dictitems(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    if (!!((*a).hasref)) {
        (*result).tagx = (uint32)1u;
        (*result).value = (int64)((*(*a).objptr).dictitems);
    }
    else {
        pc_support_pcerror((byte*)".alloclen/not heap");
    }
}

static void pc_host_pch_setoverload(struct pc_decls_varrec * a,struct pc_decls_varrec * b,struct pc_decls_varrec * c) {
    void * (*tableptr)[];
    void (*handlerptr)(void);
    struct pc_host_overloadrec * *  ovptr;
    byte str[20];
    int64 i;
    int64 t;
    int64 cmd;
    uint64 fnptr;
    uint64 oldfnptr;
    static struct pc_host_pch_setoverload_rec table[2] =     {
    {(int64)151,(void *)(&pc_decls_tostr_table),(void *)(&pc_host_tostr_handler),&pc_host_tostr_list},
    {(int64)85,(void *)(&pc_decls_convert_dtable),(void *)(&pc_host_convert_handler),&pc_host_convert_list}
};
    int64 av_1;
    pc_host_checkparam(a,(int64)14,(int64)-999999);
    pc_host_checkparam(b,(int64)13,(int64)-999999);
    pc_host_checkparam(c,(int64)18,(int64)-999999);
    cmd = (*a).value;
L668:;
    for (i=(int64)1;i<=(int64)2;++i) {
L669:;
        if ((table[(i)-1].cmd == cmd)) {
            tableptr = (void * (*)[])(table[(i)-1].tableptr);
            handlerptr = (void (*)(void))(table[(i)-1].handleptr);
            ovptr = table[(i)-1].ovlist;
            goto L671;
        }
L670:;
    }
    sprintf(str,(byte*)"Setoverload: can't find calltable: %s",(pq_common_cmdnames[(cmd)] + (int64)1));
    pc_support_pcerror(str);
L671:;
    t = (*b).value;
    (*tableptr)[(t)] = (void *)(handlerptr);
    pc_host_addovrecord(ovptr,t,(uint64 *)((*c).refptr));
}

static void pc_host_pch_errorinfo(struct pc_decls_varrec * a,struct pc_decls_varrec * result) {
    pc_host_checkparam(a,(int64)1,(int64)-999999);
    (*result).tagx = (uint32)1u;
    (*result).value = (int64)(pc_decls_err_pcptr);
}

static void pc_host_getbounds(struct pc_decls_varrec * p,struct pc_host_dimrec * dims,int64 lower) {
    int64 n;
    if (!(!!(p))) {
        pc_support_pcerror((byte*)"New: no bounds");
    }
    switch ((int64)((*p).tag)) {
    case 0:;
        (*dims).lbound = lower;
        (*dims).upper = (int64)0;
        (*dims).length = (int64)0;
        break;
    case 4:;
        (*dims).lbound = (int64)((*p).range_lower);
        (*dims).upper = (int64)((*p).range_upper);
        (*dims).length = ((int64)(((*p).range_upper - (*p).range_lower)) + (int64)1);
        if (((*dims).length < (int64)0)) {
            (*dims).length = (int64)0;
            (*dims).upper = ((*dims).lbound - (int64)1);
        }
        break;
    default:;
        n = pc_support_getintvalue(p);
        (*dims).lbound = lower;
        (*dims).upper = ((*dims).length = n);
    }
}

static int64 pc_host_checkparam(struct pc_decls_varrec * p,int64 tag,int64 defaultx) {
    if (((int64)((*p).tag)==(int64)0)) {
        if ((defaultx == (int64)-999999)) {
            pc_support_pcerror((byte*)"Missing host param");
        }
        return defaultx;
    } else if (((int64)((*p).tag)==tag)) {
        return (*p).value;
    }
    if ((tag == (int64)1)) {
        if (((int64)((*p).tag)==(int64)3)) {
            return (int64)((*p).xvalue);
        }
    }
    printf("%s\n",(char*)(pc_decls_ttname[((int64)((*p).tag))]));
    pc_support_pcerror((byte*)"Host param wrong type");
    return (int64)0;
}

static void pc_host_leftstring(struct pc_decls_varrec * a,int64 n,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  p;
    pc_pcfns_pc_makestring((*(*a).objptr).strptr,n,result);
}

static void pc_host_rightstring(struct pc_decls_varrec * a,int64 n,struct pc_decls_varrec * result) {
    struct pc_decls_objrec *  p;
    pc_pcfns_pc_makestring(((*(*a).objptr).strptr + ((int64)((*(*a).objptr).length) - n)),n,result);
}

static void pc_host_padstring_right(struct pc_decls_varrec * a,int64 n,int64 fillchar,struct pc_decls_varrec * result) {
    byte *  s;
    int64 length;
    int64 av_1;
    length = (int64)((*(*a).objptr).length);
    pc_pcfns_pc_makestringn(n,result);
    s = (*(*result).objptr).strptr;
    if (!!(length)) {
        memcpy((void *)(s),(void *)((*(*a).objptr).strptr),(uint64)(length));
        s += length;
    }
    av_1 = (n - length);
    while (av_1-- > 0) {
L672:;
        (*s) = (byte)(fillchar);
        ++s;
L673:;
    }
L674:;
}

static void pc_host_padstring_left(struct pc_decls_varrec * a,int64 n,int64 fillchar,struct pc_decls_varrec * result) {
    byte *  s;
    int64 length;
    int64 padlen;
    int64 av_1;
    length = (int64)((*(*a).objptr).length);
    padlen = (n - length);
    pc_pcfns_pc_makestringn(n,result);
    s = (*(*result).objptr).strptr;
    s += padlen;
    if (!!(length)) {
        memcpy((void *)(s),(void *)((*(*a).objptr).strptr),(uint64)(length));
    }
    av_1 = padlen;
    while (av_1-- > 0) {
L675:;
        --s;
        (*s) = (byte)(fillchar);
L676:;
    }
L677:;
}

static void pc_host_pcld_makevint(struct pc_decls_varrec * p,int64 a) {
    (*p).tagx = (uint32)1u;
    (*p).value = a;
}

static void pc_host_pcld_makelist(struct pc_decls_varrec * p,struct pc_decls_varrec * result,int64 n) {
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  r;
    int64 av_1;
    (*result).tagx = (uint32)(((int64)29 | (int64)65536));
    r = pc_objects_make_listobj(n,(int64)1);
    (*result).objptr = r;
    q = (*r).vptr;
    av_1 = n;
    while (av_1-- > 0) {
L678:;
        (*q) = (*p);
        pc_pcfns_pc_dupl(q);
        ++q;
        ++p;
L679:;
    }
L680:;
}

static void pc_host_getproctabledata(struct pc_decls_procrec * p,struct pc_decls_varrec * result) {
    struct pc_decls_varrec table[4];
    struct pc_decls_varrec l;
    struct pc_decls_strec *  d;
    int64 moduleno;
    d = (*p).def;
    pc_pcfns_pc_makestring((*d).name,(int64)-1,&table[((int64)1)-1]);
    pc_pcfns_pc_makestring((*d).metadata,(int64)-1,&table[((int64)2)-1]);
    moduleno = (int64)((*d).ax_moduleno);
    pc_host_pcld_makevint(&table[((int64)3)-1],moduleno);
    table[((int64)4)-1].tagx = (uint32)18u;
    table[((int64)4)-1].refptr = (byte *)((*d).pcaddress);
    pc_host_pcld_makelist(&table[((int64)1)-1],result,(int64)4);
}

static uint64 * pc_host_convert_handler(int64 _1) {
    return (uint64 *)(0);
}

static void pc_host_addtoproclist(struct pc_decls_strec * d) {
    struct pc_decls_procrec *  pp;
    ++pc_decls_nproclist;
    pp = (struct pc_decls_procrec *)(mlib_pcm_alloc((int64)16));
    (*pp).nextproc = pc_decls_proclist;
    pc_decls_proclist = pp;
    (*pp).def = d;
}

static uint64 * pc_host_tostr_handler(struct pc_decls_varrec * p,struct pc_decls_varrec * fmtstr,struct pc_decls_fmtrec * fmt,struct pc_decls_objrec * dest) {
    struct pc_host_overloadrec *  q;
    struct pc_decls_varrec vdest;
    struct pc_decls_objrec *  vp;
    q = pc_host_tostr_list;
    q = pc_host_tostr_list;
L681:;
    while (!!(q)) {
        if (((*q).optype == pc_decls_overloadtype)) {
            goto L683;
        }
        q = (*q).nextrec;
L682:;
    }
L683:;
    if ((q == 0)) {
        printf("%s\n",(char*)(pc_decls_ttname[((int64)((*p).tag))]));
        pc_support_pcerror((byte*)"tostr/overload");
    }
    vdest.tagx = (uint32)0u;
    pc_runproc((void *)((*q).pchandler),p,fmtstr,&vdest);
    if (((int64)(vdest.tag) != (int64)5)) {
        pc_support_pcerror((byte*)"custom tostr needs string result");
    }
    vp = vdest.objptr;
    if (!!((*vp).length)) {
        pc_print_addstring(dest,(*vp).strptr,(int64)((*vp).length));
    }
    pc_pcfns_pc_ufree(&vdest);
    return (uint64 *)(0);
}

static void pc_host_addovrecord(struct pc_host_overloadrec * * p,int64 t,uint64 * fnptr) {
    struct pc_host_overloadrec *  q;
    q = (struct pc_host_overloadrec *)(mlib_pcm_allocz((int64)32));
    (*q).optype = t;
    (*q).pchandler = fnptr;
    (*q).nextrec = (*p);
    (*p) = q;
}

void pc_dxfns_dx_iorset(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 xlen;
    int64 ylen;
    int64 n;
    int64 i;
    int64 *  p;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    byte *  pp;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64)((*px).length);
    ylen = (int64)((*py).length);
    if ((ylen == (int64)0)    ) {
    }
    else if ((xlen == (int64)0)) {
        (*x) = (*y);
    }
    else {
        pc_pcfns_pc_duplvar(x);
        px = (*x).objptr;
        pc_dxfns_iresizeset(x,ylen);
        pc_dxfns_iorsetbits((int64 *)((*px).ptr),(int64 *)((*py).ptr),ylen);
        pc_pcfns_pc_ufree(y);
    }
}

void pc_dxfns_dx_iandset(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 xlen;
    int64 ylen;
    int64 n;
    int64 i;
    int64 *  p;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    byte *  pp;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64)((*px).length);
    ylen = (int64)((*py).length);
    if ((ylen == (int64)0)    ) {
    }
    else if ((xlen == (int64)0)) {
        (*x) = (*y);
    }
    else {
        pc_pcfns_pc_duplvar(x);
        px = (*x).objptr;
        pc_dxfns_iresizeset(x,ylen);
        pc_dxfns_iandsetbits((int64 *)((*px).ptr),(int64 *)((*py).ptr),ylen);
        pc_pcfns_pc_ufree(y);
    }
}

void pc_dxfns_dx_ixorset(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 xlen;
    int64 ylen;
    int64 n;
    int64 i;
    int64 *  p;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    byte *  pp;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64)((*px).length);
    ylen = (int64)((*py).length);
    if ((ylen == (int64)0)    ) {
    }
    else if ((xlen == (int64)0)) {
        (*x) = (*y);
    }
    else {
        pc_pcfns_pc_duplvar(x);
        px = (*x).objptr;
        pc_dxfns_iresizeset(x,ylen);
        pc_dxfns_ixorsetbits((int64 *)((*px).ptr),(int64 *)((*py).ptr),ylen);
        pc_pcfns_pc_ufree(y);
    }
}

void pc_dxfns_dx_inotset(struct pc_decls_varrec * x) {
    struct pc_decls_objrec *  px;
    px = (*x).objptr;
    if (!!((*px).length)) {
        pc_pcfns_pc_duplvar(x);
        px = (*x).objptr;
        pc_dxfns_inotsetbits((int64 *)((*px).ptr),(int64)((*px).length));
    }
}

void pc_dxfns_dx_subset(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 xlen;
    int64 ylen;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    px = (*x).objptr;
    py = (*y).objptr;
    xlen = (int64)((*px).length);
    ylen = (int64)((*py).length);
    if ((!!(xlen) && !!(ylen))) {
        pc_pcfns_pc_dupl(x);
        px = (*x).objptr;
        pc_dxfns_iresizeset(x,ylen);
        pc_dxfns_subsetbits((int64 *)((*px).ptr),(int64 *)((*py).ptr),ylen);
    }
    pc_pcfns_pc_ufree(y);
}

void pc_dxfns_inotsetbits(int64 * p,int64 n) {
    int64 i;
    int64 av_1;
    av_1 = (((n - (int64)1) / (int64)64) + (int64)1);
    while (av_1-- > 0) {
L684:;
        (*p) = ~((*p));
        ++p;
L685:;
    }
L686:;
}

void pc_dxfns_iorsetbits(int64 * p,int64 * q,int64 n) {
    int64 i;
    int64 av_1;
    av_1 = (((n - (int64)1) / (int64)64) + (int64)1);
    while (av_1-- > 0) {
L687:;
        (*p++) |= (*q++);
L688:;
    }
L689:;
}

void pc_dxfns_iandsetbits(int64 * p,int64 * q,int64 n) {
    int64 i;
    int64 av_1;
    av_1 = (((n - (int64)1) / (int64)64) + (int64)1);
    while (av_1-- > 0) {
L690:;
        (*p++) &= (*q++);
L691:;
    }
L692:;
}

void pc_dxfns_ixorsetbits(int64 * p,int64 * q,int64 n) {
    int64 i;
    int64 av_1;
    av_1 = (((n - (int64)1) / (int64)64) + (int64)1);
    while (av_1-- > 0) {
L693:;
        (*p++) ^= (*q++);
L694:;
    }
L695:;
}

void pc_dxfns_subsetbits(int64 * p,int64 * q,int64 n) {
    int64 i;
    int64 av_1;
    av_1 = (((n - (int64)1) / (int64)64) + (int64)1);
    while (av_1-- > 0) {
L696:;
        (*p) |= (*q);
        (*p) ^= (*q);
        ++p;
        ++q;
L697:;
    }
L698:;
}

void pc_dxfns_iresizeset(struct pc_decls_varrec * p,int64 n) {
    struct pc_decls_objrec *  pp;
    pp = (*p).objptr;
    if (((int64)((*pp).length) >= n)) {
        return;
    }
    pc_objects_resize_bitsobj(pp,n);
    (*pp).length = (uint32)(n);
}

int64 pc_dxfns_dx_varinvar(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    int64 i;
    int64 xt;
    int64 yt;
    int64 n;
    int64 a;
    int64 nn;
    int64 aa;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    int64 av_1;
    xt = (int64)((*x).tag);
    yt = (int64)(pc_decls_ttbasetype[((int64)((*y).tag))]);
    px = (*x).objptr;
    py = (*y).objptr;
    switch (xt) {
    case 1:;
//doi64invar:
L699:;
        switch (yt) {
        case 9:;
            n = (*x).value;
//doi64inset:
L700:;
            if (((uint32)(n) >= (*py).length)) {
                if (!!((*y).hasref)) {
                    pc_pcfns_pc_ufree(y);
                }
                return (int64)0;
            }
            n = pc_support_testelem((byte (*)[])((*py).ptr),n);
            pc_pcfns_pc_ufree(y);
            return n;
            break;
        case 29:;
            a = (*x).value;
            n = (int64)((*py).length);
            p = (*py).vptr;
L701:;
            for (i=(int64)1;i<=n;++i) {
L702:;
                if ((((int64)((*p).tag) == (int64)1) && ((*p).value == a))) {
                    if (!!((*y).hasref)) {
                        pc_pcfns_pc_ufree(y);
                    }
                    return i;
                }
                ++p;
L703:;
            }
L704:;
            pc_pcfns_pc_ufree(y);
            return (int64)0;
            break;
        case 30:;
            if (((int64)((*py).elemtag)==(int64)37) || ((int64)((*py).elemtag)==(int64)44)) {
                n = pc_pcfns_u8inarray((byte)((*x).value),py);
            } else if (((int64)((*py).elemtag)==(int64)38) || ((int64)((*py).elemtag)==(int64)45)) {
                n = pc_pcfns_u16inarray((uint16)((*x).value),py);
            } else if (((int64)((*py).elemtag)==(int64)39) || ((int64)((*py).elemtag)==(int64)46)) {
                n = pc_pcfns_u32inarray((uint32)((*x).value),py);
            } else if (((int64)((*py).elemtag)==(int64)40) || ((int64)((*py).elemtag)==(int64)47)) {
                n = pc_pcfns_u64inarray((uint64)((*x).value),py);
            }
            else {
                pc_support_pcustypet((byte*)"x in array",(int64)((*py).elemtag));
            }
            pc_pcfns_pc_ufree(y);
            return n;
            break;
        case 31:;
            if (((int64)((*py).elemtag)==(int64)41)) {
                n = pc_pcfns_bitinbits((byte)((*x).value),py);
            }
            else {
                pc_support_pcustypet((byte*)"x in bits",(int64)((*py).elemtag));
            }
            pc_pcfns_pc_ufree(y);
            return n;
            break;
        case 4:;
            n = (*x).value;
            return ((n >= (int64)((*y).range_lower)) && (n <= (int64)((*y).range_upper)));
            break;
        default:;
        }
        break;
    case 5:;
        switch (yt) {
        case 5:;
            n = pc_pcfns_pc_strinstr(x,y);
            if (!!((*x).hasref)) {
                pc_pcfns_pc_ufree(x);
            }
            if (!!((*y).hasref)) {
                pc_pcfns_pc_ufree(y);
            }
            return n;
            break;
        case 29:;
            n = (int64)((*py).length);
            p = (*py).vptr;
            i = (int64)((*py).lower);
            av_1 = n;
            while (av_1-- > 0) {
L705:;
                if (((int64)((*p).tag) == (int64)5)) {
                    if (!!(pc_pcfns_pc_eqstring_nf(x,p))) {
                        if (!!((*x).hasref)) {
                            pc_pcfns_pc_ufree(x);
                        }
                        if (!!((*y).hasref)) {
                            pc_pcfns_pc_ufree(y);
                        }
                        return i;
                    }
                }
                ++p;
                ++i;
L706:;
            }
L707:;
            if (!!((*x).hasref)) {
                pc_pcfns_pc_ufree(x);
            }
            if (!!((*y).hasref)) {
                pc_pcfns_pc_ufree(y);
            }
            return (int64)0;
            break;
        default:;
        }
        break;
    default:;
        switch (yt) {
        case 29:;
            n = (int64)((*py).length);
            p = (*py).vptr;
L708:;
            for (i=(int64)1;i<=n;++i) {
L709:;
                if ((pc_pcfns_pc_equal_nf(x,p,(int64)1) == (int64)1)) {
                    if (!!((*x).hasref)) {
                        pc_pcfns_pc_ufree(x);
                    }
                    if (!!((*y).hasref)) {
                        pc_pcfns_pc_ufree(y);
                    }
                    return i;
                }
                ++p;
L710:;
            }
L711:;
            if (!!((*x).hasref)) {
                pc_pcfns_pc_ufree(x);
            }
            if (!!((*y).hasref)) {
                pc_pcfns_pc_ufree(y);
            }
            return (int64)0;
            break;
        default:;
        }
    }
    pc_support_pcmxtypes((byte*)"varinvar:",x,y);
    return (int64)0;
}

int64 pc_dxfns_dx_mixed(struct pc_decls_varrec * x,struct pc_decls_varrec * y) {
    switch ((int64)((*x).tag)) {
    case 1:;
        switch ((int64)((*y).tag)) {
        case 3:;
            (*x).xvalue = (double)((*x).value);
            (*x).tagx = (uint32)3u;
            return (int64)3;
            break;
        case 2:;
            return (int64)1;
            break;
        case 7:;
            pc_bigint_bn_makeint((*x).value,x);
            return (int64)7;
            break;
        case 0:;
            goto L712;
            break;
        default:;
            return (int64)0;
        }
        break;
    case 3:;
        switch ((int64)((*y).tag)) {
        case 1:;
            (*y).xvalue = (double)((*y).value);
            (*y).tagx = (uint32)3u;
            return (int64)3;
            break;
        case 0:;
            goto L712;
            break;
        default:;
            return (int64)0;
        }
        break;
    case 2:;
        switch ((int64)((*y).tag)) {
        case 1:;
            return (int64)2;
            break;
        case 0:;
            goto L712;
            break;
        default:;
            return (int64)0;
        }
        break;
    case 7:;
        switch ((int64)((*y).tag)) {
        case 1:;
            pc_bigint_bn_makeint((*y).value,y);
            return (int64)7;
            break;
        default:;
            return (int64)0;
        }
        break;
    case 0:;
//dxvoid:
L712:;
        pc_support_pcerror((byte*)"dxmix/void");
        break;
    default:;
        if (((int64)((*y).tag) == (int64)0)) {
            goto L712;
        }
        return (int64)0;
    }
    return (int64)0;
}

void pc_dxfns_resize_stringobj(struct pc_decls_objrec * p,int64 n) {
    byte *  q;
    int32 allocated;
    if ((n <= (int64)((*p).allocated))) {
        (*p).length = (uint32)(n);
        return;
    }
    q = (byte *)(mlib_pcm_alloc(n));
    if (!!((*p).length)) {
        memcpy((void *)(q),(void *)((*p).strptr),(uint64)((*p).length));
        mlib_pcm_free((void *)((*p).strptr),(int64)((*p).allocated));
    }
    (*p).strptr = q;
    (*p).allocated = (uint32)(mlib_allocbytes);
    (*p).length = (uint32)(n);
}

void * pc_khandlers_k_zero(void) {
    pc_support_pclunimpl((int64)0);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_nop(void) {
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_procstart(void) {
    pc_support_pclunimpl((int64)2);
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_procend(void) {
    pc_support_pclunimpl((int64)3);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_endmodule(void) {
    pc_support_pclunimpl((int64)4);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_push_m(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr) = (*(struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64)1))));
    if (!!((*pc_decls_sptr).hasref)) {
        ++(*(*pc_decls_sptr).objptr).refcount;
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_f(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr) = (*(struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)1))))));
    if (!!((*pc_decls_sptr).hasref)) {
        ++(*(*pc_decls_sptr).objptr).refcount;
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_am(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)22u;
    (*pc_decls_sptr).varptr = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64)1)));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_af(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)22u;
    (*pc_decls_sptr).varptr = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)1)))));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_ap(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)18u;
    (*pc_decls_sptr).refptr = (byte *)((*(pc_decls_pcptr + (int64)1)));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_al(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)20u;
    (*pc_decls_sptr).refptr = (byte *)((*(pc_decls_pcptr + (int64)1)));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_ci(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (int64)((*(pc_decls_pcptr + (int64)1)));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_cw(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)2u;
    (*pc_decls_sptr).uvalue = (*(pc_decls_pcptr + (int64)1));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_cr(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)3u;
    (*pc_decls_sptr).uvalue = (*(pc_decls_pcptr + (int64)1));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_cn(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)4u;
    (*pc_decls_sptr).uvalue = (*(pc_decls_pcptr + (int64)1));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_cs(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)(((int64)5 | (int64)65536));
    (*pc_decls_sptr).objptr = (struct pc_decls_objrec *)((*(pc_decls_pcptr + (int64)1)));
    ++(*(*pc_decls_sptr).objptr).refcount;
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_t(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)13u;
    (*pc_decls_sptr).value = (int64)((*(pc_decls_pcptr + (int64)1)));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_op(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)14u;
    (*pc_decls_sptr).value = (int64)((*(pc_decls_pcptr + (int64)1)));
    (*pc_decls_sptr).opdims = (byte)((*(pc_decls_pcptr + (int64)2)));
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_pushz(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)((*(pc_decls_pcptr + (int64)1)));
    (*pc_decls_sptr).value = (int64)0;
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_pushz_void(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)0u;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushz_str(void) {
    void (*f)(void);
    --pc_decls_sptr;
    if ((pc_khandlers_zerostringobj == 0)) {
        pc_khandlers_zerostringobj = pc_objects_newobject();
    }
    (*pc_decls_sptr).objptr = pc_khandlers_zerostringobj;
    (*pc_decls_sptr).tagx = (uint32)(((int64)5 | (int64)65536));
    ++(*pc_khandlers_zerostringobj).refcount;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushz_list(void) {
    void (*f)(void);
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)(((int64)29 | (int64)65536));
    (*pc_decls_sptr).objptr = pc_objects_emptylist;
    ++(*pc_objects_emptylist).refcount;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushz_listl(void) {
    struct pc_decls_objrec *  p;
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)(((int64)29 | (int64)65536));
    (*pc_decls_sptr).objptr = pc_objects_make_listobj((int64)0,(int64)((*(pc_decls_pcptr + (int64)1))));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_pushz_set(void) {
    --pc_decls_sptr;
    (*pc_decls_sptr).tagx = (uint32)(((int64)9 | (int64)65536));
    (*pc_decls_sptr).objptr = pc_objects_emptyset;
    ++(*pc_objects_emptyset).refcount;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushz_arrayl(void) {
    pc_support_pclunimpl((int64)24);
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_pop_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64)1)));
    if (!!((*a).hasref)) {
        pc_pcfns_pc_ufree(a);
    }
    (*a) = (*pc_decls_sptr++);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_pop_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)1)))));
    if (!!((*a).hasref)) {
        pc_pcfns_pc_ufree(a);
    }
    (*a) = (*pc_decls_sptr++);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_store_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64)1)));
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ushare(pc_decls_sptr);
    }
    if (!!((*a).hasref)) {
        pc_pcfns_pc_ufree(a);
    }
    (*a) = (*pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_store_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)1)))));
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ushare(pc_decls_sptr);
    }
    if (!!((*a).hasref)) {
        pc_pcfns_pc_ufree(a);
    }
    (*a) = (*pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_pushptr(void) {
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 22:;
        (*pc_decls_sptr) = (*(*pc_decls_sptr).varptr);
        if (!!((*pc_decls_sptr).hasref)) {
            ++(*(*pc_decls_sptr).objptr).refcount;
        }
        break;
    case 25:;
        (*pc_decls_sptr).tagx = (uint32)(((int64)((*pc_decls_sptr).refelemtag) | (int64)65536));
        ++(*(*pc_decls_sptr).objptr).refcount;
        break;
    case 23:;
        pc_pcfns_pc_loadpacked((void *)((*pc_decls_sptr).refptr),(int64)((*pc_decls_sptr).refelemtag),pc_decls_sptr,(struct pc_decls_objrec *)(0));
        break;
    case 24:;
        pc_pcfns_pc_loadbit((*pc_decls_sptr).refptr,(int64)((*pc_decls_sptr).refbitoffset),(int64)((*pc_decls_sptr).refelemtag),pc_decls_sptr);
        break;
    default:;
        pc_support_pcustype((byte*)"pushptr",pc_decls_sptr);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_popptr(void) {
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    p = pc_decls_sptr++;
    switch ((int64)((*p).tag)) {
    case 22:;
        q = (*p).varptr;
        if (!!((*q).hasref)) {
            pc_pcfns_pc_ufree(q);
        }
        (*q) = (*pc_decls_sptr++);
        break;
    case 5:;
        pc_pcfns_pc_storestring(p,pc_decls_sptr);
        ++pc_decls_sptr;
        break;
    default:;
        pc_pcfns_pc_storeptr(p,pc_decls_sptr);
        ++pc_decls_sptr;
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_storeptr(void) {
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  q;
    p = pc_decls_sptr++;
    if (((int64)((*p).tag) == (int64)22)) {
        q = (*p).varptr;
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ushare(pc_decls_sptr);
        }
        if (!!((*q).hasref)) {
            pc_pcfns_pc_ufree(q);
        }
        (*q) = (*pc_decls_sptr);
    }
    else {
        pc_pcfns_pc_storeptr(p,pc_decls_sptr);
        pc_pcfns_pc_cfree(pc_decls_sptr);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_zpop_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64)1)));
    (*a) = (*pc_decls_sptr++);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_zpop_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)1)))));
    (*a) = (*pc_decls_sptr++);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_zstore_m(void) {
    pc_support_pclunimpl((int64)34);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_zstore_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)1)))));
    (*a) = (*pc_decls_sptr);
    if (!!((*a).hasref)) {
        pc_pcfns_pc_ushare(a);
    }
    if (!!((*pc_decls_sptr).hasref)) {
        ++(*(*pc_decls_sptr).objptr).refcount;
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_copy(void) {
    if (!(!!((*pc_decls_sptr).hasref))) {
        return (void *)((pc_decls_pcptr + (int64)1));
    }
    pc_pcfns_pc_dupl(pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_swap(void) {
    byte tempbuffer[1024];
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    struct pc_decls_varrec v;
    int64 xt;
    int64 yt;
    int64 s;
    int64 t;
    int64 n;
    byte *  p;
    byte *  q;
    int64 a;
    x = pc_decls_sptr++;
    y = pc_decls_sptr++;
    xt = (int64)((*x).tag);
    yt = (int64)((*y).tag);
    if (((xt == (int64)22) && (yt == (int64)22))    ) {
        v = (*(*x).varptr);
        (*(*x).varptr) = (*(*y).varptr);
        (*(*y).varptr) = v;
    }
    else if (((xt == (int64)23) && (yt == (int64)23))) {
        s = (int64)((*x).refelemtag);
        t = (int64)((*y).refelemtag);
        if ((s != t)) {
            goto L713;
        }
        n = pc_decls_ttsize[(s)];
        if ((n==(int64)1)) {
            p = (*x).refptr;
            q = (*y).refptr;
            a = (int64)((*p));
            (*p) = (*q);
            (*q) = (byte)(a);
        }
        else {
            if ((pc_decls_ttsize[(s)] <= (int64)1024)) {
                memcpy((void *)(&tempbuffer),(void *)((*x).refptr),(uint64)(n));
                memcpy((void *)((*x).refptr),(void *)((*y).refptr),(uint64)(n));
                memcpy((void *)((*y).refptr),(void *)(&tempbuffer),(uint64)(n));
            }
            else {
                goto L713;
            }
        }
    }
    else {
//swaperror:
L713:;
        pc_support_pcmxtypes((byte*)"SWAP",x,y);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_convptr(void) {
    struct pc_decls_varrec *  a;
    int64 tag;
    int64 elemtype;
    void *  p;
    struct pc_decls_objrec *  pa;
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 22:;
        a = (*pc_decls_sptr).varptr;
        pa = (*a).objptr;
        switch ((int64)(pc_decls_ttbasetype[((int64)((*a).tag))])) {
        case 1:;
            p = (void *)(&(*a).value);
            elemtype = (int64)40;
            break;
        case 3:;
            p = (void *)(&(*a).value);
            elemtype = (int64)49;
            break;
        case 30:;
            p = (void *)((*pa).ptr);
            elemtype = (int64)((*(*a).objptr).elemtag);
            break;
        case 5:;
            p = (void *)((*pa).strptr);
            elemtype = (int64)44;
            if ((p == 0)) {
                p = (void *)((byte*)"");
            }
            break;
        case 33:;
            p = (void *)((*pa).ptr);
            elemtype = (int64)((*a).tag);
            break;
        default:;
            if (!!((*a).hasref)) {
                p = (void *)(pa);
                elemtype = (int64)0;
                goto L714;
            }
            printf("%s\n",(char*)(pc_support_gettypename((int64)(pc_decls_ttbasetype[((int64)((*a).tag))]))));
            pc_support_pcustype((byte*)"Getrefpack1",a);
            return (void *)(pc_decls_pcptr);
        }
        break;
    case 23:;
    case 24:;
        return (void *)((pc_decls_pcptr + (int64)1));
        break;
    default:;
        pc_support_pcustype((byte*)"Getrefpack2",pc_decls_sptr);
        return (void *)(pc_decls_pcptr);
    }
//done:
L714:;
    (*pc_decls_sptr).tagx = (uint32)23u;
    (*pc_decls_sptr).refptr = (byte *)(p);
    (*pc_decls_sptr).refelemtag = (uint16)(elemtype);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_jump(void) {
    return (void *)((int64 *)((*(pc_decls_pcptr + (int64)1))));
}

void * pc_khandlers_k_jumpptr(void) {
    if (((int64)((*pc_decls_sptr).tag) != (int64)20)) {
        pc_support_pcerror((byte*)"Bad label ptr");
    }
    pc_decls_pcptr = (uint64 *)((*pc_decls_sptr).refptr);
    ++pc_decls_sptr;
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_jumptrue(void) {
    return (void *)(((*pc_decls_jumptrue_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_jumpfalse(void) {
    return (void *)(((*pc_decls_jumpfalse_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_jumpdef(void) {
    if (((int64)((*pc_decls_sptr).tag) != (int64)0)) {
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        ++pc_decls_sptr;
        return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
    }
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    ++pc_decls_sptr;
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_jumpvoid(void) {
    if (((int64)((*pc_decls_sptr).tag) == (int64)0)) {
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        ++pc_decls_sptr;
        return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
    }
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    ++pc_decls_sptr;
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_jumpeq(void) {
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        return (void *)(((*pc_decls_jumpeq_table[(yt)]))());
    }
    pc_decls_opc_tableptr = &pc_decls_jumpeq_table;
    return (void *)(((*pc_decls_jumpeq_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumpne(void) {
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        return (void *)(((*pc_decls_jumpne_table[(yt)]))());
    }
    pc_decls_opc_tableptr = &pc_decls_jumpne_table;
    return (void *)(((*pc_decls_jumpne_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumplt(void) {
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        return (void *)(((*pc_decls_jumplt_table[(yt)]))());
    }
    pc_decls_opc_tableptr = &pc_decls_jumplt_table;
    return (void *)(((*pc_decls_jumplt_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumple(void) {
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        return (void *)(((*pc_decls_jumple_table[(yt)]))());
    }
    pc_decls_opc_tableptr = &pc_decls_jumple_table;
    return (void *)(((*pc_decls_jumple_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumpge(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            if (((*pc_decls_sptr).value >= (*y).value)) {
                ++pc_decls_sptr;
                return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
            }
            ++pc_decls_sptr;
            return (void *)((pc_decls_pcptr + (int64)2));
            break;
        default:;
            return (void *)(((*pc_decls_jumpge_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_jumpge_table;
    return (void *)(((*pc_decls_jumpge_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumpgt(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            if (((*pc_decls_sptr).value > (*y).value)) {
                ++pc_decls_sptr;
                return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
            }
            ++pc_decls_sptr;
            return (void *)((pc_decls_pcptr + (int64)2));
            break;
        default:;
            return (void *)(((*pc_decls_jumpgt_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_jumpgt_table;
    return (void *)(((*pc_decls_jumpgt_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_jumptesteq(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 xt;
    int64 yt;
    int64 res;
    struct pc_decls_objrec *  py;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    xt = (int64)((*x).tag);
    yt = (int64)((*y).tag);
    if ((xt != yt)) {
        if (!!((xt = pc_dxfns_dx_mixed(x,y)))) {
            goto L715;
        }
        xt = (int64)((*x).tag);
        yt = (int64)((*y).tag);
        switch (xt) {
        case 1:;
            switch (yt) {
            case 4:;
                if ((((*x).value < (int64)((*y).range_lower)) || ((*x).value > (int64)((*y).range_upper)))) {
                    return (void *)((pc_decls_pcptr + (int64)2));
                }
                break;
            case 9:;
                py = (*y).objptr;
                if (((((int64)((*py).length) == (int64)0) || ((*x).value >= (int64)((*py).length))) || !(!!(pc_support_testelem((byte (*)[])((*py).ptr),(*x).value))))) {
                    return (void *)((pc_decls_pcptr + (int64)2));
                }
                break;
            default:;
                return (void *)((pc_decls_pcptr + (int64)2));
            }
            break;
        default:;
            return (void *)((pc_decls_pcptr + (int64)2));
        }
        ++pc_decls_sptr;
        return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
    }
//retry:
L715:;
    switch (xt) {
    case 1:;
    case 13:;
        if (((*x).value == (*y).value)) {
            ++pc_decls_sptr;
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        break;
    case 3:;
        if (((*x).xvalue == (*y).xvalue)) {
            ++pc_decls_sptr;
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        break;
    case 4:;
        if (((*x).value == (*y).value)) {
            ++pc_decls_sptr;
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        break;
    case 5:;
        res = pc_pcfns_pc_eqstring_nf(x,y);
        if (!!((*y).hasref)) {
            pc_pcfns_pc_ufree(y);
        }
        if (!!(res)) {
            if (!!((*x).hasref)) {
                pc_pcfns_pc_ufree(x);
            }
            ++pc_decls_sptr;
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        break;
    default:;
        res = pc_pcfns_pc_equal_nf(x,y,(int64)0);
        if (!!((*x).hasref)) {
            pc_pcfns_pc_ufree(x);
        }
        if (!!((*y).hasref)) {
            pc_pcfns_pc_ufree(y);
        }
        if (!!(res)) {
            ++pc_decls_sptr;
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_jumptestne(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 xt;
    int64 yt;
    int64 res;
    struct pc_decls_objrec *  px;
    struct pc_decls_objrec *  py;
    y = pc_decls_sptr++;
    x = pc_decls_sptr;
    xt = (int64)((*x).tag);
    yt = (int64)((*y).tag);
    if ((xt != yt)) {
        if (!!((xt = pc_dxfns_dx_mixed(x,y)))) {
            goto L716;
        }
        xt = (int64)((*x).tag);
        yt = (int64)((*y).tag);
        switch (xt) {
        case 1:;
            switch (yt) {
            case 4:;
                if ((((*x).value >= (int64)((*y).range_lower)) && ((*x).value <= (int64)((*y).range_upper)))) {
                    ++pc_decls_sptr;
                    return (void *)((pc_decls_pcptr + (int64)2));
                }
                break;
            case 9:;
                py = (*y).objptr;
                if ((((*x).value < (int64)((*py).length)) && !!(pc_support_testelem((byte (*)[])((*py).ptr),(*x).value)))) {
                    ++pc_decls_sptr;
                    return (void *)((pc_decls_pcptr + (int64)2));
                }
                break;
            default:;
            }
            break;
        default:;
        }
        return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
    }
//retry:
L716:;
    switch (xt) {
    case 1:;
    case 13:;
        if (((*x).value != (*y).value)) {
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        ++pc_decls_sptr;
        break;
    case 3:;
        if (((*x).xvalue != (*y).xvalue)) {
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        ++pc_decls_sptr;
        break;
    case 4:;
        if (((*x).value != (*y).value)) {
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        ++pc_decls_sptr;
        break;
    case 5:;
        res = pc_pcfns_pc_eqstring_nf(x,y);
        if (!!((*y).hasref)) {
            pc_pcfns_pc_ufree(y);
        }
        if (!(!!(res))) {
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        if (!!((*x).hasref)) {
            pc_pcfns_pc_ufree(x);
        }
        ++pc_decls_sptr;
        break;
    default:;
        res = pc_pcfns_pc_equal(x,y,(int64)0);
        if (!(!!(res))) {
            return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
        }
        if (!!((*x).hasref)) {
            pc_pcfns_pc_ufree(x);
        }
        ++pc_decls_sptr;
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_jumplabel(void) {
    pc_support_pclunimpl((int64)53);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_jumpclabel(void) {
    pc_support_pclunimpl((int64)54);
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_switch(void) {
    int64 index;
    int64 n;
    int64 lower;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    lower = (int64)((*(pc_decls_pcptr + (int64)2)));
    if (((int64)((*pc_decls_sptr).tag)==(int64)1) || ((int64)((*pc_decls_sptr).tag)==(int64)13)) {
    }
    else {
        printf("%s\n",(char*)(pc_decls_ttname[((int64)((*pc_decls_sptr).tag))]));
        pc_support_pcerror((byte*)"switch not int");
    }
    index = ((*pc_decls_sptr++).value - lower);
    if (((uint32)(index) >= (uint32)(n))) {
        return (void *)((int64 *)((*((pc_decls_pcptr + (n * (int64)2)) + (int64)4))));
    }
    else {
        return (void *)((int64 *)((*((pc_decls_pcptr + (index * (int64)2)) + (int64)4))));
    }
}

void * pc_khandlers_k_cswitch(void) {
    pc_support_pclunimpl((int64)56);
    return (void *)((pc_decls_pcptr + (int64)4));
}

void * pc_khandlers_k_new(void) {
    pc_support_pclunimpl((int64)57);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_to_f(void) {
    if (!!(--(*(struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)2)))))).value)) {
        return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
    }
    else {
        return (void *)((pc_decls_pcptr + (int64)3));
    }
}

void * pc_khandlers_k_for_fci(void) {
    if ((++(*(struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)2)))))).value <= (int64)((*(pc_decls_pcptr + (int64)3))))) {
        return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
    }
    else {
        return (void *)((pc_decls_pcptr + (int64)4));
    }
}

void * pc_khandlers_k_for_ff(void) {
    if ((++(*(struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)2)))))).value <= (*(struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)3)))))).value)) {
        return (void *)((int64 *)((*(pc_decls_pcptr + (int64)1))));
    }
    else {
        return (void *)((pc_decls_pcptr + (int64)4));
    }
}

void * pc_khandlers_k_ford_fci(void) {
    if ((--(*(struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)2)))))).value >= (int64)((*(pc_decls_pcptr + (int64)3))))) {
        return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
    }
    else {
        return (void *)((pc_decls_pcptr + (int64)4));
    }
}

void * pc_khandlers_k_ford_ff(void) {
    if ((--(*(struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)2)))))).value >= (*(struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)3)))))).value)) {
        return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
    }
    else {
        return (void *)((pc_decls_pcptr + (int64)4));
    }
}

void * pc_khandlers_k_call(void) {
    static int64 count = (int64)10;
    static byte *  dummyfp;
    int64 ticks;
    if ((--count == (int64)0)) {
        count = (int64)10;
        osnos_os_peek();
    }
    (*--pc_decls_sptr).tagx = (uint32)16u;
    (*pc_decls_sptr).retaddr = (pc_decls_pcptr + (int64)3);
    (*pc_decls_sptr).frameptr_low = *(int32*)&pc_decls_frameptr;
    (*pc_decls_sptr).stackadj = (byte)((*(pc_decls_pcptr + (int64)2)));
    pc_decls_frameptr = (byte *)(pc_decls_sptr);
    return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
}

void * pc_khandlers_k_callptr(void) {
    uint64 *  newpc;
    if (((int64)((*pc_decls_sptr).tag) != (int64)18)) {
        printf("%s\n",(char*)(pc_decls_ttname[((int64)((*pc_decls_sptr).tag))]));
        pc_support_pcerror((byte*)"callptr: not refproc");
    }
    newpc = (uint64 *)((*pc_decls_sptr).value);
    if (((*(pc_decls_pcptr + (int64)1)) != (*(newpc - (int64)1)))) {
        printf("%llu %llu\n",(uint64)(*(pc_decls_pcptr + (int64)1)),(uint64)(*(newpc - (int64)1)));
        pc_support_pcerror((byte*)"callptr wrong # params");
    }
    (*pc_decls_sptr).tagx = (uint32)16u;
    (*pc_decls_sptr).retaddr = (pc_decls_pcptr + (int64)3);
    (*pc_decls_sptr).frameptr_low = *(int32*)&pc_decls_frameptr;
    (*pc_decls_sptr).stackadj = (byte)((*(pc_decls_pcptr + (int64)2)));
    pc_decls_frameptr = (byte *)(pc_decls_sptr);
    return (void *)(newpc);
}

void * pc_khandlers_k_return(void) {
    if (((int64)((*pc_decls_sptr).tag) != (int64)16)) {
        printf("%s\n",(char*)(pc_decls_ttname[((int64)((*pc_decls_sptr).tag))]));
        pc_support_pcerror((byte*)"Return error");
    }
    (*pc_decls_sptr).tag = (uint16)0u;
    pc_decls_pcptr = (*pc_decls_sptr).retaddr;
    (*(int32 *)(&pc_decls_frameptr)) = (*pc_decls_sptr).frameptr_low;
    pc_decls_sptr = (struct pc_decls_varrec *)(((byte *)(pc_decls_sptr) + (int64)((*pc_decls_sptr).stackadj)));
    ++pc_decls_sptr;
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_startdll(void) {
    if ((++pc_decls_dllcallindex > (int64)30)) {
        pc_support_pcerror((byte*)"nested dll max");
    }
    pc_decls_dllcallstack[(pc_decls_dllcallindex)-1] = pc_decls_dllindex;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushdll(void) {
    int64 s;
    int64 t;
    struct pc_decls_objrec *  p;
    if ((++pc_decls_dllindex > (int64)29)) {
        printf("%s %lld\n",(char*)((byte*)"DLLIX %d"),(int64)pc_decls_dllindex);
        pc_support_pcerror((byte*)"dll params");
    }
    s = (int64)((*pc_decls_sptr).tag);
    t = (int64)(pc_decls_ttbasetype[((int64)((*(pc_decls_pcptr + (int64)1))))]);
    switch (t) {
    case 0:;
        t = s;
        switch (s) {
        case 5:;
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64)(pc_support_convcstring((*(*pc_decls_sptr).objptr).strptr,(int64)((*(*pc_decls_sptr).objptr).length)));
            break;
        default:;
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (*pc_decls_sptr).value;
        }
        break;
    case 40:;
    case 47:;
        if (((int64)64 == (int64)32)) {
            pc_support_pcerror((byte*)"pushdll i64=>i32,i32 needed");
        }
        if ((s==(int64)1) || (s==(int64)2)) {
        } else if ((s==(int64)3)) {
            (*pc_decls_sptr).value = (int64)((*pc_decls_sptr).xvalue);
        } else if ((s==(int64)23)) {
            (*pc_decls_sptr).value = (int64)((*pc_decls_sptr).refptr);
        }
        else {
//error:
L717:;
            printf("%s %s %s\n",(char*)(pc_decls_ttname[(s)]),(char*)((byte*)"should be"),(char*)(pc_decls_ttname[(t)]));
            pc_support_pcerror((byte*)"DLL: param wrong type");
        }
        pc_decls_dllparams[(pc_decls_dllindex)-1] = (*pc_decls_sptr).value;
        break;
    case 49:;
        if (((int64)64 == (int64)32)) {
            pc_support_pcerror((byte*)"pushdll r64=>i32,i32 needed");
        }
        if ((s==(int64)1) || (s==(int64)2)) {
            (*pc_decls_sptr).xvalue = (double)((*pc_decls_sptr).value);
        } else if ((s==(int64)3)) {
        }
        else {
            goto L717;
        }
        break;
    case 5:;
        if ((s==(int64)5)) {
            p = (*pc_decls_sptr).objptr;
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64)(pc_support_convcstring((*p).strptr,(int64)((*p).length)));
        } else if ((s==(int64)1)) {
            if (((*pc_decls_sptr).value != (int64)0)) {
                goto L717;
            }
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64)0;
        }
        else {
            goto L717;
        }
        break;
    case 23:;
        if (!!((*pc_decls_sptr).hasref)) {
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64)((*(*pc_decls_sptr).objptr).ptr);
        }
        else {
            pc_decls_dllparams[(pc_decls_dllindex)-1] = (int64)((*pc_decls_sptr).refptr);
        }
        break;
    default:;
        pc_decls_dllparams[(pc_decls_dllindex)-1] = (*pc_decls_sptr).value;
    }
    if (((int64)((*pc_decls_sptr).tag) == (int64)5)) {
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
    }
    ++pc_decls_sptr;
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_calldll(void) {
    int64 nparams;
    int64 offset;
    if ((pc_decls_dllcallindex <= (int64)0)) {
        pc_support_pcerror((byte*)"calldll??");
    }
    offset = pc_decls_dllcallstack[(pc_decls_dllcallindex)-1];
    nparams = (pc_decls_dllindex - offset);
    pc_oslayer_os_calldll((int64)((*(pc_decls_pcptr + (int64)2))),(int64)((*(pc_decls_pcptr + (int64)1))),offset,nparams,(int64)((*(pc_decls_pcptr + (int64)3))),pc_decls_sptr);
    pc_decls_dllindex = pc_decls_dllcallstack[(pc_decls_dllcallindex)-1];
    --pc_decls_dllcallindex;
    return (void *)((pc_decls_pcptr + (int64)4));
}

void * pc_khandlers_k_callhost(void) {
    pc_host_callhostfunction((int64)((*(pc_decls_pcptr + (int64)1))),(int64)0);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_stackframe(void) {
    int64 i;
    int64 n;
    int64 av_1;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    av_1 = n;
    while (av_1-- > 0) {
L718:;
        (*--pc_decls_sptr).tagx = (uint32)0u;
        (*pc_decls_sptr).value = (int64)0;
L719:;
    }
L720:;
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_free(void) {
    int64 i;
    int64 n;
    struct pc_decls_objrec *  p;
    int64 av_1;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    av_1 = n;
    while (av_1-- > 0) {
L721:;
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        ++pc_decls_sptr;
L722:;
    }
L723:;
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_addsp(void) {
    pc_decls_sptr = (struct pc_decls_varrec *)(((byte *)(pc_decls_sptr) + (int64)((*(pc_decls_pcptr + (int64)1)))));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_stop(void) {
    int64 i;
    int64 j;
    int64 k;
    int64 n;
    int64 c;
    int64 total;
    int64 exitcode;
    double speed;
    pc_khandlers_stopped = (uint8)1u;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_test(void) {
    pc_support_pclunimpl((int64)74);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_makelist(void) {
    int64 n;
    int64 lower;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    lower = (int64)((*(pc_decls_pcptr + (int64)2)));
    pc_pcfns_pc_makelist(n,pc_decls_sptr,((pc_decls_sptr + n) - (int64)1),lower);
    pc_decls_sptr += (n - (int64)1);
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_makerecord(void) {
    int64 n;
    int64 t;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    t = (int64)((*(pc_decls_pcptr + (int64)2)));
    pc_pcfns_pc_makerecord(n,t,pc_decls_sptr,((pc_decls_sptr + n) - (int64)1));
    pc_decls_sptr += (n - (int64)1);
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_makearray(void) {
    int64 n;
    int64 lower;
    int64 t;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    lower = (int64)((*(pc_decls_pcptr + (int64)2)));
    t = (int64)((*(pc_decls_pcptr + (int64)3)));
    if (((int64)(pc_decls_ttbasetype[(t)]) == (int64)30)) {
        pc_pcfns_pc_makearray(n,t,(int64)((*(pc_decls_pcptr + (int64)4))),lower,pc_decls_sptr,((pc_decls_sptr + n) - (int64)1));
    }
    else {
    }
    pc_decls_sptr += (n - (int64)1);
    return (void *)((pc_decls_pcptr + (int64)5));
}

void * pc_khandlers_k_makestruct(void) {
    int64 n;
    int64 t;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    t = (int64)((*(pc_decls_pcptr + (int64)2)));
    pc_pcfns_pc_makestruct(n,t,pc_decls_sptr,((pc_decls_sptr + n) - (int64)1));
    pc_decls_sptr += (n - (int64)1);
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_makeset(void) {
    int64 n;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    pc_pcfns_pc_makeset(n,pc_decls_sptr,((pc_decls_sptr + n) - (int64)1));
    pc_decls_sptr += (n - (int64)1);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_makerange(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    y = pc_decls_sptr++;
    pc_pcfns_pc_makerange(pc_decls_sptr,y,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_makedict(void) {
    int64 n;
    n = (int64)((*(pc_decls_pcptr + (int64)1)));
    pc_pcfns_pc_makedict(n,pc_decls_sptr,((pc_decls_sptr + (n * (int64)2)) - (int64)1));
    pc_decls_sptr += ((n * (int64)2) - (int64)1);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_pushdot(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  p;
    int64 index;
    int64 j;
    int64 k;
    int64 n;
    int64 fieldtype;
    int64 needfree;
    byte *  xptr;
    int64 i;
    int64 dx;
    int64 ix;
    struct pc_decls_genfielddatarec *  gd;
    struct pc_decls_genfielddatarec *  gd0;
    struct pc_decls_varrec v;
    int64 av_1;
    v = (*pc_decls_sptr);
    if (((int64)(v.tag)==(int64)25)) {
        v.tagx = (uint32)(v.refelemtag);
    }
    else {
        if (!(!!(v.hasref))) {
            pc_support_pcerror((byte*)"pushdot/not record");
        }
    }
    xptr = (*v.objptr).ptr;
    gd0 = (gd = &pc_decls_genfielddata[((ix = (int64)(pc_decls_genfieldnames[((int64)((*(pc_decls_pcptr + (int64)1))))-1].dataindex)))-1]);
    n = (int64)(pc_decls_genfieldnames[((int64)((*(pc_decls_pcptr + (int64)1))))-1].datalength);
    av_1 = n;
    while (av_1-- > 0) {
L724:;
        if (((*gd).recordtype == (int32)(v.tag))) {
            fieldtype = (int64)((*gd).fieldtype);
            if ((fieldtype == (int64)35)            ) {
                (*pc_decls_sptr) = (*(struct pc_decls_varrec *)((xptr + (int64)((*gd).offset))));
                if (!!((*pc_decls_sptr).hasref)) {
                    ++(*(*pc_decls_sptr).objptr).refcount;
                }
                if (!!(v.hasref)) {
                    pc_pcfns_pc_ufree(&v);
                }
                return (void *)((pc_decls_pcptr + (int64)2));
            }
            else if ((fieldtype == (int64)18)) {
                dx = (gd - gd0);
                (*pc_decls_sptr).tagx = (uint32)18u;
                (*pc_decls_sptr).refptr = (byte *)(pc_decls_genfieldpcaddress[((ix + (gd - gd0)))-1]);
                if (!!(v.hasref)) {
                    pc_pcfns_pc_ufree(&v);
                }
                return (void *)((pc_decls_pcptr + (int64)2));
            }
            else {
                pc_pcfns_pc_loadpacked((void *)((xptr + (int64)((*gd).offset))),fieldtype,pc_decls_sptr,(struct pc_decls_objrec *)(0));
                if (!!(v.hasref)) {
                    pc_pcfns_pc_ufree(&v);
                }
                return (void *)((pc_decls_pcptr + (int64)2));
            }
        }
        ++gd;
L725:;
    }
L726:;
    printf("%s %lld %s\n",(char*)((byte*)"Field:"),(int64)pc_decls_ngenfieldnames,(char*)(pc_decls_genfieldnames[((int64)((*(pc_decls_pcptr + (int64)1))))-1].name));
    pc_support_pcustypet((byte*)"Dotg: wrong record type",(int64)(v.tag));
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_pushdotref(void) {
    struct pc_decls_varrec v;
    struct pc_decls_varrec *  p;
    int64 index;
    int64 n;
    int64 xtag;
    int64 fieldtype;
    int64 isrefvar;
    int64 rectype;
    int64 offset;
    struct pc_decls_genfielddatarec *  gd;
    int64 av_1;
    v = (*pc_decls_sptr);
    if (((int64)(v.tag)==(int64)22)) {
        p = v.varptr;
        isrefvar = (int64)1;
        rectype = (int64)((*p).tag);
        if ((rectype == (int64)25)) {
            rectype = (int64)((*p).refelemtag);
        }
        if (!(!!((*(*p).objptr).mutable))) {
            (*p).objptr = pc_objects_copyonwrite((*p).objptr,(int64)((*p).tag));
        }
    } else if (((int64)(v.tag)==(int64)23)) {
        isrefvar = (int64)0;
        rectype = (int64)(v.refelemtag);
    }
    else {
        pc_support_pcustype((byte*)"&dotg not ref",&v);
        return (void *)(pc_decls_pcptr);
    }
    gd = &pc_decls_genfielddata[((int64)(pc_decls_genfieldnames[((int64)((*(pc_decls_pcptr + (int64)1))))-1].dataindex))-1];
    n = (int64)(pc_decls_genfieldnames[((int64)((*(pc_decls_pcptr + (int64)1))))-1].datalength);
    av_1 = n;
    while (av_1-- > 0) {
L727:;
        if (((int64)((*gd).recordtype) == rectype)) {
            fieldtype = (int64)((*gd).fieldtype);
            offset = (int64)((*gd).offset);
            if (!!(isrefvar)) {
                if ((fieldtype == (int64)35)) {
                    (*pc_decls_sptr).refptr = ((*(*p).objptr).ptr + offset);
                }
                else {
                    (*pc_decls_sptr).tagx = (uint32)23u;
                    (*pc_decls_sptr).refptr = ((*(*p).objptr).ptr + offset);
                    (*pc_decls_sptr).refelemtag = (uint16)(fieldtype);
                }
            }
            else {
                (*pc_decls_sptr).refptr += offset;
                (*pc_decls_sptr).refelemtag = (uint16)(fieldtype);
            }
            return (void *)((pc_decls_pcptr + (int64)2));
        }
        ++gd;
L728:;
    }
L729:;
    pc_support_pcustypet((byte*)"&Dotg: wrong record type",rectype);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_softconv(void) {
    int64 t;
    t = (int64)((*(pc_decls_pcptr + (int64)1)));
    (*pc_decls_sptr).tagx = (uint32)(t);
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_hardconv(void) {
    int64 s;
    int64 t;
    s = (int64)((*pc_decls_sptr).tag);
    t = (int64)((*(pc_decls_pcptr + (int64)1)));
    if (((int64)((*pc_decls_sptr).tag) != t)) {
        pc_pcfns_pc_iconvert(t,pc_decls_sptr);
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_mixed(void) {
    pc_support_pclunimpl((int64)86);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_incrptr(void) {
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec v;
    p = pc_decls_sptr++;
    switch ((int64)(pc_decls_ttbasetype[((int64)((*p).tag))])) {
    case 22:;
        p = (*p).varptr;
        switch ((int64)((*p).tag)) {
        case 1:;
            ++(*p).value;
            break;
        case 22:;
            ++(*p).varptr;
            break;
        case 23:;
            (*p).refptr += pc_decls_ttsize[((int64)((*p).refelemtag))];
            break;
        default:;
            pc_support_pcustype((byte*)"incrptr/refvar",p);
        }
        break;
    case 23:;
        switch ((int64)((*p).refelemtag)) {
        case 44:;
        case 37:;
            ++(*(*p).refptr);
            break;
        default:;
            pc_support_pcustypet((byte*)"incrptr/ref",(int64)((*p).refelemtag));
        }
        break;
    default:;
        pc_support_pcustype((byte*)"incrptr",p);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_incrto_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64)1)));
    switch ((int64)(pc_decls_ttbasetype[((int64)((*a).tag))])) {
    case 1:;
        ++(*a).value;
        break;
    case 22:;
        ++(*a).varptr;
        break;
    case 23:;
        (*a).refptr += pc_decls_ttsize[((int64)((*a).refelemtag))];
        break;
    default:;
        pc_support_pcustype((byte*)"INCRTO_M",a);
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_incrto_f(void) {
    struct pc_decls_varrec *  a;
    int64 offset;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)1)))));
    switch ((int64)((*a).tag)) {
    case 1:;
        ++(*a).value;
        return (void *)((pc_decls_pcptr + (int64)2));
        break;
    case 22:;
        ++(*a).varptr;
        break;
    case 23:;
        (*a).refptr += pc_decls_ttsize[((int64)((*a).refelemtag))];
        break;
    case 24:;
        offset = ((int64)((*a).refbitoffset) + pc_types_stdtypewidths[((int64)((*a).refelemtag))]);
        if ((offset >= (int64)8)) {
            offset = (int64)0;
            ++(*a).refptr;
        }
        (*a).refbitoffset = (byte)(offset);
        break;
    default:;
        pc_support_pcustype((byte*)"INCRTO_F",a);
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_loadincr(void) {
    struct pc_decls_varrec ptr;
    ptr = (*pc_decls_sptr);
    pc_pcfns_pc_loadptr(pc_decls_sptr,pc_decls_sptr);
    --pc_decls_sptr;
    (*pc_decls_sptr) = ptr;
    return pc_khandlers_k_incrptr();
}

void * pc_khandlers_k_incrload(void) {
    int64 *  pc;
    struct pc_decls_varrec ptr;
    ptr = (*pc_decls_sptr);
    pc = (int64 *)(pc_khandlers_k_incrptr());
    pc_pcfns_pc_loadptr(&ptr,--pc_decls_sptr);
    return (void *)(pc);
}

void * pc_khandlers_k_decrptr(void) {
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec v;
    p = pc_decls_sptr++;
    switch ((int64)(pc_decls_ttbasetype[((int64)((*p).tag))])) {
    case 22:;
        p = (*p).varptr;
        switch ((int64)((*p).tag)) {
        case 1:;
            --(*p).value;
            break;
        case 22:;
            --(*p).varptr;
            break;
        case 23:;
            (*p).refptr -= pc_decls_ttsize[((int64)((*p).refelemtag))];
            break;
        default:;
            pc_support_pcustype((byte*)"decrptr/refvar",p);
        }
        break;
    case 23:;
        switch ((int64)((*p).refelemtag)) {
        case 39:;
            --(*(*p).dptr);
            break;
        case 44:;
        case 37:;
            --(*(*p).refptr);
            break;
        default:;
            pc_support_pcustypet((byte*)"decrptr/ref",(int64)((*p).refelemtag));
        }
        break;
    default:;
        pc_support_pcustype((byte*)"decrptr",p);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_decrto_m(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((*(pc_decls_pcptr + (int64)1)));
    switch ((int64)((*a).tag)) {
    case 1:;
        --(*a).value;
        break;
    case 22:;
        --(*a).varptr;
        break;
    case 23:;
        (*a).refptr -= pc_decls_ttsize[((int64)((*a).refelemtag))];
        break;
    default:;
        pc_support_pcustype((byte*)"DECRTO_M",a);
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_decrto_f(void) {
    struct pc_decls_varrec *  a;
    a = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)1)))));
    switch ((int64)((*a).tag)) {
    case 1:;
        --(*a).value;
        break;
    case 22:;
        --(*a).varptr;
        break;
    case 23:;
        (*a).refptr -= pc_decls_ttsize[((int64)((*a).refelemtag))];
        break;
    default:;
        pc_support_pcustype((byte*)"DECRTO_F",a);
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_loaddecr(void) {
    struct pc_decls_varrec ptr;
    ptr = (*pc_decls_sptr);
    pc_pcfns_pc_loadptr(pc_decls_sptr,pc_decls_sptr);
    (*--pc_decls_sptr) = ptr;
    return pc_khandlers_k_decrptr();
}

void * pc_khandlers_k_decrload(void) {
    int64 *  pc;
    struct pc_decls_varrec ptr;
    ptr = (*pc_decls_sptr);
    pc = (int64 *)(pc_khandlers_k_decrptr());
    pc_pcfns_pc_loadptr(&ptr,--pc_decls_sptr);
    return (void *)(pc);
}

void * pc_khandlers_k_incr(void) {
    pc_support_pclunimpl((int64)97);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_decr(void) {
    if (((int64)((*pc_decls_sptr).tag)==(int64)1)) {
        --(*pc_decls_sptr).value;
    }
    else {
        pc_support_pcustype((byte*)"decr",pc_decls_sptr);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_neg(void) {
    return (void *)(((*pc_decls_neg_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_abs(void) {
    return (void *)(((*pc_decls_abs_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_not(void) {
    (*pc_decls_sptr).value = !((*pc_decls_sptr).value);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_inot(void) {
    return (void *)(((*pc_decls_inot_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_istrue(void) {
    return (void *)(((*pc_decls_istrue_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_asc(void) {
    int64 a;
    struct pc_decls_objrec *  s;
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 5:;
        s = (*pc_decls_sptr).objptr;
        if (((int64)((*s).length) == (int64)0)) {
            a = (int64)0;
        }
        else {
            a = (int64)((*(*s).strptr));
            if (!!((*pc_decls_sptr).hasref)) {
                pc_pcfns_pc_ufree(pc_decls_sptr);
            }
        }
        (*pc_decls_sptr).tagx = (uint32)1u;
        (*pc_decls_sptr).value = a;
        break;
    default:;
        pc_support_pcustype((byte*)"ASC",pc_decls_sptr);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_chr(void) {
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 1:;
        if (((*pc_decls_sptr).uvalue > (uint64)255u)) {
            pc_support_pcerror((byte*)"chr>255");
        }
        pc_pcfns_pc_makechar((*pc_decls_sptr).value,pc_decls_sptr);
        break;
    default:;
        pc_support_pcustype((byte*)"CHR",pc_decls_sptr);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_sqrt(void) {
    pc_decls_pcptr += (int64)1;
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 1:;
        (*pc_decls_sptr).tagx = (uint32)3u;
        (*pc_decls_sptr).xvalue = sqrt(((double)((*pc_decls_sptr).value)));
        break;
    case 3:;
        (*pc_decls_sptr).xvalue = sqrt(((*pc_decls_sptr).xvalue));
        break;
    default:;
        pc_support_pcustype((byte*)"SQRT",pc_decls_sptr);
    }
    return (void *)(pc_decls_pcptr);
}

void * pc_khandlers_k_sqr(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64)((*x).tag)) {
    case 1:;
        (*pc_decls_sptr).value = ((*x).value * (*x).value);
        break;
    case 3:;
        (*pc_decls_sptr).xvalue = ((*x).xvalue * (*x).xvalue);
        break;
    default:;
        pc_support_pcustype((byte*)"SQR",x);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_cube(void) {
    pc_support_pclunimpl((int64)108);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_sin(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64)((*x).tag)) {
    case 3:;
        (*pc_decls_sptr).xvalue = sin((*x).xvalue);
        break;
    default:;
        pc_support_pcustype((byte*)"SIN",x);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_cos(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64)((*x).tag)) {
    case 3:;
        (*pc_decls_sptr).xvalue = cos((*x).xvalue);
        break;
    default:;
        pc_support_pcustype((byte*)"COS",x);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_tan(void) {
    pc_support_pclunimpl((int64)111);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_asin(void) {
    pc_support_pclunimpl((int64)112);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_acos(void) {
    pc_support_pclunimpl((int64)113);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_atan(void) {
    pc_support_pclunimpl((int64)114);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_sign(void) {
    pc_support_pclunimpl((int64)115);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_ln(void) {
    double x;
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 3:;
        (*pc_decls_sptr).xvalue = log((*pc_decls_sptr).xvalue);
        break;
    case 1:;
        x = (double)((*pc_decls_sptr).value);
        (*pc_decls_sptr).xvalue = log(x);
        break;
    default:;
        pc_support_pcustype((byte*)"LN",pc_decls_sptr);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_log(void) {
    pc_support_pclunimpl((int64)117);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_lg(void) {
    pc_support_pclunimpl((int64)118);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_exp(void) {
    pc_support_pclunimpl((int64)119);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_round(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64)((*x).tag)) {
    case 3:;
        if (((*x).xvalue >= (float)0.000000)) {
            (*pc_decls_sptr).xvalue = floor(((*x).xvalue + (float)0.500000));
        }
        else {
            (*pc_decls_sptr).xvalue = ceil(((*x).xvalue - (float)0.500000));
        }
        break;
    default:;
        pc_support_pcustype((byte*)"ROUND",x);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_floor(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr;
    switch ((int64)((*x).tag)) {
    case 3:;
        if (((*x).xvalue >= (float)0.000000)) {
            (*pc_decls_sptr).xvalue = floor((*x).xvalue);
        }
        else {
            (*pc_decls_sptr).xvalue = ceil((*x).xvalue);
        }
        break;
    default:;
        pc_support_pcustype((byte*)"ROUND",x);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_ceil(void) {
    pc_support_pclunimpl((int64)122);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_fract(void) {
    pc_support_pclunimpl((int64)123);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_negto(void) {
    pc_support_pclunimpl((int64)124);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_absto(void) {
    pc_support_pclunimpl((int64)125);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_notto(void) {
    pc_support_pclunimpl((int64)126);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_inotto(void) {
    pc_support_pclunimpl((int64)127);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_len(void) {
    return (void *)(((*pc_decls_len_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_lwb(void) {
    return (void *)(((*pc_decls_lwb_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_upb(void) {
    return (void *)(((*pc_decls_upb_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_bounds(void) {
    return (void *)(((*pc_decls_bounds_table[((int64)((*pc_decls_sptr).tag))]))());
}

void * pc_khandlers_k_bits(void) {
    if (((int64)((*pc_decls_sptr).tag)==(int64)13)) {
        (*pc_decls_sptr).value = (int64)(pc_decls_ttbitwidth[((*pc_decls_sptr).value)]);
    }
    else {
        (*pc_decls_sptr).value = (int64)(pc_decls_ttbitwidth[((int64)((*pc_decls_sptr).tag))]);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_bytes(void) {
    int64 m;
    int64 n;
    struct pc_decls_objrec *  p;
    m = (int64)((*pc_decls_sptr).tag);
    if ((m == (int64)13)) {
        m = (*pc_decls_sptr).value;
    }
    p = (*pc_decls_sptr).objptr;
    if (((int64)(pc_decls_ttbasetype[(m)])==(int64)5)) {
        n = (int64)((*p).length);
    } else if (((int64)(pc_decls_ttbasetype[(m)])==(int64)30)) {
        n = ((int64)((*p).length) * pc_decls_ttsize[((int64)((*p).elemtag))]);
    } else if (((int64)(pc_decls_ttbasetype[(m)])==(int64)31) || ((int64)(pc_decls_ttbasetype[(m)])==(int64)9)) {
        n = ((int64)((*p).length) / (int64)8);
    } else if (((int64)(pc_decls_ttbasetype[(m)])==(int64)29)) {
        n = ((int64)((*p).length) * (int64)16);
    }
    else {
        n = pc_decls_ttsize[(m)];
    }
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_type(void) {
    int64 res;
    res = (int64)((*pc_decls_sptr).tag);
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)13u;
    (*pc_decls_sptr).value = res;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_elemtype(void) {
    pc_support_pclunimpl((int64)135);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_basetype(void) {
    int64 res;
    if (((int64)((*pc_decls_sptr).tag) == (int64)13)) {
        res = (int64)(pc_decls_ttbasetype[((*pc_decls_sptr).value)]);
    }
    else {
        res = (int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))]);
    }
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)13u;
    (*pc_decls_sptr).value = res;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_minval(void) {
    int64 t;
    int64 a;
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 1:;
        t = (int64)40;
        break;
    case 3:;
        t = (int64)49;
        break;
    case 13:;
        t = (*pc_decls_sptr).value;
        break;
    default:;
        pc_support_pcustype((byte*)"Maxval",pc_decls_sptr);
    }
    if ((t==(int64)44) || (t==(int64)45) || (t==(int64)46) || (t==(int64)47)) {
        a = (int64)0;
    } else if ((t==(int64)37)) {
        a = (int64)-128;
    } else if ((t==(int64)38)) {
        a = (int64)-32768;
    } else if ((t==(int64)39)) {
        a = (int64)-2147483648;
    } else if ((t==(int64)40)) {
        a = (int64)((uint64)9223372036854775808u);
    }
    else {
        printf("%s\n",(char*)(pc_support_gettypename(t)));
        pc_support_pcerror((byte*)"MINVALUE");
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = a;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_maxval(void) {
    int64 t;
    int64 a;
    switch ((int64)((*pc_decls_sptr).tag)) {
    case 1:;
        t = (int64)40;
        break;
    case 3:;
        t = (int64)49;
        break;
    case 13:;
        t = (*pc_decls_sptr).value;
        break;
    default:;
        pc_support_pcustype((byte*)"Maxval",pc_decls_sptr);
    }
    if ((t==(int64)44)) {
        a = (int64)255;
    } else if ((t==(int64)45)) {
        a = (int64)65536;
    } else if ((t==(int64)46)) {
        a = (int64)4294967295;
    } else if ((t==(int64)47)) {
        a = (int64)((uint64)18446744073709551615u);
    } else if ((t==(int64)37)) {
        a = (int64)127;
    } else if ((t==(int64)38)) {
        a = (int64)32767;
    } else if ((t==(int64)39)) {
        a = (int64)2147483647;
    } else if ((t==(int64)40)) {
        a = (int64)((uint64)9223372036854775807u);
    }
    else {
        printf("%s\n",(char*)(pc_support_gettypename(t)));
        pc_support_pcerror((byte*)"MAXVALUE");
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = a;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isint(void) {
    if ((((int64)((*pc_decls_sptr).tag) == (int64)1) || ((int64)((*pc_decls_sptr).tag) == (int64)2))) {
        (*pc_decls_sptr).value = (int64)1;
    }
    else {
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        (*pc_decls_sptr).value = (int64)0;
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isreal(void) {
    if (((int64)((*pc_decls_sptr).tag) == (int64)3)) {
        (*pc_decls_sptr).value = (int64)1;
    }
    else {
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        (*pc_decls_sptr).value = (int64)0;
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isstring(void) {
    int64 n;
    n = (int64)(((int64)((*pc_decls_sptr).tag) == (int64)5));
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isrange(void) {
    int64 n;
    n = (int64)(((int64)((*pc_decls_sptr).tag) == (int64)4));
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isnumber(void) {
    pc_support_pclunimpl((int64)143);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isarray(void) {
    int64 n;
    switch ((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])) {
    case 29:;
    case 30:;
    case 31:;
        n = (int64)1;
        break;
    default:;
        n = (int64)0;
    }
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isrecord(void) {
    int64 n;
    n = (int64)0;
    switch ((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])) {
    case 32:;
    case 33:;
        n = (int64)1;
        break;
    default:;
    }
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_ispointer(void) {
    int64 n;
    switch ((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))])) {
    case 23:;
    case 22:;
    case 24:;
    case 18:;
    case 20:;
        n = (int64)1;
        break;
    default:;
        n = (int64)0;
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_ismutable(void) {
    pc_support_pclunimpl((int64)147);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isset(void) {
    int64 n;
    n = (int64)(((int64)(pc_decls_ttbasetype[((int64)((*pc_decls_sptr).tag))]) == (int64)9));
    if (!!((*pc_decls_sptr).hasref)) {
        pc_pcfns_pc_ufree(pc_decls_sptr);
    }
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isvoid(void) {
    if (((int64)((*pc_decls_sptr).tag) == (int64)0)) {
        (*pc_decls_sptr).tagx = (uint32)1u;
        (*pc_decls_sptr).value = (int64)1;
    }
    else {
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        (*pc_decls_sptr).tagx = (uint32)1u;
        (*pc_decls_sptr).value = (int64)0;
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isdef(void) {
    if (((int64)((*pc_decls_sptr).tag) != (int64)0)) {
        (*pc_decls_sptr).tagx = (uint32)1u;
        (*pc_decls_sptr).value = (int64)1;
    }
    else {
        if (!!((*pc_decls_sptr).hasref)) {
            pc_pcfns_pc_ufree(pc_decls_sptr);
        }
        (*pc_decls_sptr).tagx = (uint32)1u;
        (*pc_decls_sptr).value = (int64)0;
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_tostr(void) {
    pc_support_pclunimpl((int64)151);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_isequal(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 xt;
    int64 yt;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    xt = (int64)((*x).tag);
    yt = (int64)((*y).tag);
    if ((xt == (int64)25)) {
        xt = (int64)((*x).refelemtag);
        (*x).hasref = (uint8)1u;
    }
    if ((yt == (int64)25)) {
        yt = (int64)((*y).refelemtag);
    }
    if (((xt == yt) && !!((*x).hasref))) {
        (*pc_decls_sptr).tagx = (uint32)1u;
        (*pc_decls_sptr).value = (int64)(((*x).objptr == (*y).objptr));
        return (void *)((pc_decls_pcptr + (int64)1));
    }
    if ((((((xt == (int64)1) && ((*x).value == (int64)0)) && !!((*y).hasref)) || (((yt == (int64)1) && ((*y).value == (int64)0)) && !!((*x).hasref))) || ((((xt == (int64)1) && (yt == (int64)1)) && ((*x).value == (int64)0)) && !!((*y).value)))) {
        (*pc_decls_sptr).tagx = (uint32)1u;
        (*pc_decls_sptr).value = (int64)0;
        return (void *)((pc_decls_pcptr + (int64)1));
    }
    pc_support_pcmxtypes((byte*)"ISEQUAL",x,y);
    return 0;
}

void * pc_khandlers_k_add(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value += (*y).value;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        case 3:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue += (*y).xvalue;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_add_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_add_table;
    return (void *)(((*pc_decls_add_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_sub(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value -= (*y).value;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        case 3:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue -= (*y).xvalue;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_sub_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_sub_table;
    return (void *)(((*pc_decls_sub_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_mul(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value *= (*y).value;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        case 3:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue *= (*y).xvalue;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_mul_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_mul_table;
    return (void *)(((*pc_decls_mul_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_div(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue = ((double)((*pc_decls_sptr).value) / (double)((*y).value));
            (*pc_decls_sptr).tag = (uint16)3u;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        case 3:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue /= (*y).xvalue;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_div_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_div_table;
    return (void *)(((*pc_decls_div_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_idiv(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value = ((*pc_decls_sptr).value / (*y).value);
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_idiv_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_idiv_table;
    return (void *)(((*pc_decls_idiv_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_rem(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value = ((*pc_decls_sptr).value % (*y).value);
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_rem_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_rem_table;
    return (void *)(((*pc_decls_rem_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_divrem(void) {
    pc_support_pclunimpl((int64)159);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_iand(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value &= (*y).value;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_iand_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_iand_table;
    return (void *)(((*pc_decls_iand_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_ior(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value |= (*y).value;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_ior_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_ior_table;
    return (void *)(((*pc_decls_ior_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_ixor(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value ^= (*y).value;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_ixor_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_ixor_table;
    return (void *)(((*pc_decls_ixor_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_shl(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value <<= (*y).value;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_shl_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_shl_table;
    return (void *)(((*pc_decls_shl_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_shr(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value >>= (*y).value;
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_shr_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_shr_table;
    return (void *)(((*pc_decls_shr_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_in(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 n;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    n = pc_dxfns_dx_varinvar(x,y);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = n;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_notin(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 n;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    n = pc_dxfns_dx_varinvar(x,y);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = !(n);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_inrev(void) {
    pc_support_pclunimpl((int64)167);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_eq(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_equal(x,y,(int64)0);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = res;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_ne(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_equal(x,y,(int64)0);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = !(res);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_lt(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_compare(x,y);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (res < (int64)0);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_le(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_compare(x,y);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (res <= (int64)0);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_ge(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_compare(x,y);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (res >= (int64)0);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_gt(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 res;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    res = pc_pcfns_pc_compare(x,y);
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (res > (int64)0);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_min(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value=((*pc_decls_sptr).value<(*y).value?(*pc_decls_sptr).value:(*y).value);
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        case 3:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue=((*pc_decls_sptr).xvalue<(*y).xvalue?(*pc_decls_sptr).xvalue:(*y).xvalue);
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_min_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_min_table;
    return (void *)(((*pc_decls_min_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_max(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        switch (yt) {
        case 1:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).value=((*pc_decls_sptr).value>(*y).value?(*pc_decls_sptr).value:(*y).value);
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        case 3:;
            y = pc_decls_sptr++;
            (*pc_decls_sptr).xvalue=((*pc_decls_sptr).xvalue>(*y).xvalue?(*pc_decls_sptr).xvalue:(*y).xvalue);
            return (void *)((pc_decls_pcptr + (int64)1));
            break;
        default:;
            return (void *)(((*pc_decls_max_table[(yt)]))());
        }
    }
    pc_decls_opc_tableptr = &pc_decls_max_table;
    return (void *)(((*pc_decls_max_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][(yt)]))]))());
}

void * pc_khandlers_k_concat(void) {
    struct pc_decls_varrec *  y;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == yt)) {
        return (void *)(((*pc_decls_concat_table[(yt)]))());
    }
    pc_support_pcmxtypes((byte*)"CONCAT",pc_decls_sptr,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_append(void) {
    return (void *)(((*pc_decls_append_table[((int64)((*(pc_decls_sptr + (int64)1)).tag))]))());
}

void * pc_khandlers_k_power(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  y;
    int64 xt;
    int64 yt;
    struct pc_decls_varrec result;
    y = pc_decls_sptr;
    x = ++pc_decls_sptr;
    xt = (int64)((*x).tag);
    yt = (int64)((*y).tag);
    if ((xt != yt)) {
        if (((xt = pc_dxfns_dx_mixed(x,y)) == (int64)0)) {
            pc_support_pcmxtypes((byte*)"**MIXED",x,y);
        }
    }
    switch (xt) {
    case 1:;
        (*pc_decls_sptr).value = pc_support_ipower((*x).value,(*y).value);
        break;
    case 3:;
        (*pc_decls_sptr).xvalue = fmod((*x).xvalue,(*y).xvalue);
        break;
    case 7:;
        pc_bigint_bn_power(x,pc_bigint_bn_int(y),&result);
        pc_pcfns_pc_ufree(x);
        if (!!((*y).hasref)) {
            pc_pcfns_pc_ufree(y);
        }
        (*pc_decls_sptr) = result;
        break;
    default:;
        pc_support_pcustype((byte*)"**",x);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_atan2(void) {
    pc_support_pclunimpl((int64)179);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_addto(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_addto_table[(yt)]))());
        }
        pc_decls_opc_tableptr = &pc_decls_addto_table;
        return (void *)(((*pc_decls_addto_dtable[((int64)(pc_decls_sigmap[((int64)((*x).tag))][(yt)]))]))());
    }
    else {
        pc_support_pcerror((byte*)"addto not ptr");
    }
    pc_support_pcmxtypes((byte*)"addto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_subto(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_subto_table[(yt)]))());
        }
    }
    else {
        pc_support_pcerror((byte*)"subto not ptr");
    }
    pc_support_pcmxtypes((byte*)"subto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_multo(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_multo_table[(yt)]))());
        }
    }
    else {
        pc_support_pcerror((byte*)"multo not ptr");
    }
    pc_support_pcmxtypes((byte*)"multo",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_divto(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_divto_table[(yt)]))());
        }
    }
    else {
        pc_support_pcerror((byte*)"divto not ptr");
    }
    pc_support_pcmxtypes((byte*)"divto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_idivto(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_idivto_table[(yt)]))());
        }
    }
    else {
        pc_support_pcerror((byte*)"idivto not ptr");
    }
    pc_support_pcmxtypes((byte*)"idivto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_iandto(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec ptr;
    int64 yt;
    uint64 *  pc;
    yt = (int64)((*pc_decls_sptr).tag);
    p = (pc_decls_sptr + (int64)1);
    if (((int64)((*p).tag) == (int64)22)) {
        x = (*p).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_iandto_table[(yt)]))());
        }
        pc_support_pcmxtypes((byte*)"iandto",x,pc_decls_sptr);
    }
    else {
        ptr = (*p);
        pc_pcfns_pc_loadptr(p,p);
        pc = (uint64 *)(pc_khandlers_k_iand());
        pc_pcfns_pc_storeptr(&ptr,pc_decls_sptr++);
        return (void *)(pc);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_iorto(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec ptr;
    int64 yt;
    uint64 *  pc;
    yt = (int64)((*pc_decls_sptr).tag);
    p = (pc_decls_sptr + (int64)1);
    if (((int64)((*p).tag) == (int64)22)) {
        x = (*p).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_iorto_table[(yt)]))());
        }
        pc_support_pcmxtypes((byte*)"iorto",x,pc_decls_sptr);
    }
    else {
        ptr = (*p);
        pc_pcfns_pc_loadptr(p,p);
        pc = (uint64 *)(pc_khandlers_k_ior());
        pc_pcfns_pc_storeptr(&ptr,pc_decls_sptr++);
        return (void *)(pc);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_ixorto(void) {
    struct pc_decls_varrec *  x;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec ptr;
    int64 yt;
    uint64 *  pc;
    yt = (int64)((*pc_decls_sptr).tag);
    p = (pc_decls_sptr + (int64)1);
    if (((int64)((*p).tag) == (int64)22)) {
        x = (*p).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_ixorto_table[(yt)]))());
        }
        pc_support_pcmxtypes((byte*)"ixorto",x,pc_decls_sptr);
    }
    else {
        ptr = (*p);
        pc_pcfns_pc_loadptr(p,p);
        pc = (uint64 *)(pc_khandlers_k_ixor());
        pc_pcfns_pc_storeptr(&ptr,pc_decls_sptr++);
        return (void *)(pc);
    }
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_shlto(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_shlto_table[(yt)]))());
        }
    }
    else {
        pc_support_pcerror((byte*)"Shlto not ptr");
    }
    pc_support_pcmxtypes((byte*)"Shlto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_shrto(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_shrto_table[(yt)]))());
        }
    }
    else {
        pc_support_pcerror((byte*)"Shrto not ptr");
    }
    pc_support_pcmxtypes((byte*)"Shrto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_minto(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_minto_table[(yt)]))());
        }
    }
    else {
        pc_support_pcerror((byte*)"minto not ptr");
    }
    pc_support_pcmxtypes((byte*)"minto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_maxto(void) {
    struct pc_decls_varrec *  x;
    int64 yt;
    yt = (int64)((*pc_decls_sptr).tag);
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        x = (*(pc_decls_sptr + (int64)1)).varptr;
        if (((int64)((*x).tag) == yt)) {
            return (void *)(((*pc_decls_maxto_table[(yt)]))());
        }
    }
    else {
        pc_support_pcerror((byte*)"maxto not ptr");
    }
    pc_support_pcmxtypes((byte*)"maxto",x,pc_decls_sptr);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_concatto(void) {
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        return (void *)(((*pc_decls_concatto_table[((int64)((*(*(pc_decls_sptr + (int64)1)).varptr).tag))]))());
    }
    pc_support_pcerror((byte*)"Concatto not ptr");
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_appendto(void) {
    if (((int64)((*(pc_decls_sptr + (int64)1)).tag) == (int64)22)) {
        return (void *)(((*pc_decls_appendto_table[((int64)((*(*(pc_decls_sptr + (int64)1)).varptr).tag))]))());
    }
    pc_support_pcerror((byte*)"Appendto not ptr");
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushix(void) {
    return (void *)(((*pc_decls_pushix_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][((int64)((*pc_decls_sptr).tag))]))]))());
}

void * pc_khandlers_k_pushdotix(void) {
    return (void *)(((*pc_decls_pushdotix_dtable[((int64)(pc_decls_sigmap[((int64)((*(pc_decls_sptr + (int64)1)).tag))][((int64)((*pc_decls_sptr).tag))]))]))());
}

void * pc_khandlers_k_pushkeyix(void) {
    struct pc_decls_varrec *  d;
    struct pc_decls_varrec *  k;
    struct pc_decls_varrec *  p;
    d = pc_decls_sptr++;
    k = pc_decls_sptr;
    if (((int64)((*d).tag) != (int64)10)) {
        pc_support_pcustype((byte*)"keyix",d);
    }
    p = pc_pcfns_finddictitem((*d).objptr,k,(int64)0);
    pc_pcfns_pc_ufree(d);
    if (!!((*k).hasref)) {
        pc_pcfns_pc_ufree(k);
    }
    if (!!(p)) {
        (*pc_decls_sptr) = (*p);
        return (void *)((pc_decls_pcptr + (int64)1));
    }
    (*pc_decls_sptr).tagx = (uint32)0u;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushkeyixd(void) {
    struct pc_decls_varrec *  d;
    struct pc_decls_varrec *  k;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  def;
    def = pc_decls_sptr++;
    d = pc_decls_sptr++;
    k = pc_decls_sptr;
    if (((int64)((*d).tag) != (int64)10)) {
        pc_support_pcustype((byte*)"keyix",d);
    }
    p = pc_pcfns_finddictitem((*d).objptr,k,(int64)0);
    pc_pcfns_pc_ufree(d);
    if (!!((*k).hasref)) {
        pc_pcfns_pc_ufree(k);
    }
    if (!!(p)) {
        (*pc_decls_sptr) = (*p);
        if (!!((*def).hasref)) {
            pc_pcfns_pc_ufree(def);
        }
        return (void *)((pc_decls_pcptr + (int64)1));
    }
    (*pc_decls_sptr) = (*def);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushixref(void) {
    struct pc_decls_varrec *  p;
    int64 *  qq;
    p = (pc_decls_sptr + (int64)1);
    if (((int64)((*p).tag) == (int64)22)) {
        return (void *)(((*pc_decls_pushixref_dtable[((int64)(pc_decls_sigmap[((int64)((*(*p).varptr).tag))][((int64)((*pc_decls_sptr).tag))]))]))());
    }
    return (void *)(pc_support_pcerror((byte*)"pushixref/not ptr"));
}

void * pc_khandlers_k_pushdotixref(void) {
    struct pc_decls_varrec *  p;
    p = (pc_decls_sptr + (int64)1);
    if (((int64)((*p).tag) == (int64)22)) {
        return (void *)(((*pc_decls_pushdotixref_dtable[((int64)(pc_decls_sigmap[((int64)((*(*p).varptr).tag))][((int64)((*pc_decls_sptr).tag))]))]))());
    }
    pc_support_pcerror((byte*)"pushdotixref/not ptr");
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushkeyixref(void) {
    struct pc_decls_varrec *  d;
    struct pc_decls_varrec *  k;
    struct pc_decls_varrec *  p;
    struct pc_decls_varrec *  pd;
    d = (*pc_decls_sptr).varptr;
    k = ++pc_decls_sptr;
    if (((int64)((*d).tag) != (int64)10)) {
        pc_support_pcustype((byte*)"keyixref",d);
    }
    p = pc_pcfns_finddictitem((*d).objptr,k,(int64)1);
    if (!!((*k).hasref)) {
        pc_pcfns_pc_ufree(k);
    }
    (*pc_decls_sptr).tagx = (uint32)22u;
    (*pc_decls_sptr).varptr = p;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushbyteix(void) {
    int64 a;
    uint64 index;
    struct pc_decls_varrec *  x;
    if (((int64)((*pc_decls_sptr).tag) != (int64)1)) {
        pc_support_pcerror((byte*)"byteix/bad index");
    }
    index = (uint64)((*pc_decls_sptr).value);
    ++pc_decls_sptr;
    if (((int64)((*pc_decls_sptr).tag) != (int64)1)) {
        pc_support_pcerror((byte*)"byteix/not int");
    }
    a = (*pc_decls_sptr).value;
    if (((*(pc_decls_pcptr + (int64)1))==(uint64)((int64)44))) {
        if (((int64)(index) >= (int64)8)) {
            if (((int64)(index) >= (int64)12)) {
                pc_support_pcerror((byte*)"byteix bounds");
            }
            a = (int64)((*pc_decls_sptr).frameptr_low);
            (*pc_decls_sptr).value = ((a >> (((int64)(index) - (int64)8) * (int64)8)) & (int64)255);
        }
        else {
            (*pc_decls_sptr).value = ((a >> ((int64)(index) * (int64)8)) & (int64)255);
        }
    }
    else {
        pc_support_pcerror((byte*)"byteix/bad type");
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_pushbyteixref(void) {
    byte *  a;
    uint64 index;
    struct pc_decls_varrec *  p;
    if (((int64)((*pc_decls_sptr).tag) != (int64)1)) {
        pc_support_pcerror((byte*)"&byteix/bad index");
    }
    index = (uint64)((*pc_decls_sptr).value);
    ++pc_decls_sptr;
    if (((int64)((*pc_decls_sptr).tag) != (int64)22)) {
        pc_support_pcerror((byte*)"&byteix/not ptr");
    }
    p = (*pc_decls_sptr).varptr;
    if (((int64)((*p).tag) != (int64)1)) {
        pc_support_pcerror((byte*)"&bytix/not int");
    }
    (*pc_decls_sptr).tagx = (uint32)23u;
    if (((*(pc_decls_pcptr + (int64)1))==(uint64)((int64)44))) {
        if (((int64)(index) >= (int64)8)) {
            if (((int64)(index) >= (int64)12)) {
                pc_support_pcerror((byte*)"&byteix bounds");
            }
            (*pc_decls_sptr).packptr = (((byte *)(p) + (int64)(index)) - (int64)4);
        }
        else {
            (*pc_decls_sptr).packptr = (((byte *)(p) + (int64)8) + (int64)(index));
        }
        (*pc_decls_sptr).refelemtag = (uint16)44u;
    }
    else {
        pc_support_pcerror((byte*)"&byteix/bad type");
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_appendset(void) {
    pc_support_pclunimpl((int64)203);
    return (void *)((pc_decls_pcptr + (int64)1));
}

void * pc_khandlers_k_pushdotm(void) {
    pc_support_pclunimpl((int64)204);
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_pushdott(void) {
    pc_support_pclunimpl((int64)205);
    return (void *)((pc_decls_pcptr + (int64)3));
}

void * pc_khandlers_k_push_ad(void) {
    (*--pc_decls_sptr).tagx = (uint32)19u;
    (*pc_decls_sptr).refptr = (byte *)((void *)(pc_decls_dllproctable[((int64)((*(pc_decls_pcptr + (int64)1))))-1].address));
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_push_try(void) {
    (*--pc_decls_sptr).tagx = (uint32)17u;
    (*pc_decls_sptr).refptr = (byte *)((*(pc_decls_pcptr + (int64)1)));
    (*pc_decls_sptr).frameoffset = (int16)((pc_decls_frameptr - (byte *)(pc_decls_sptr)));
    (*pc_decls_sptr).exceptiontype = (byte)((*(pc_decls_pcptr + (int64)2)));
    (*pc_decls_sptr).nexceptions = (byte)((*(pc_decls_pcptr + (int64)3)));
    return (void *)((pc_decls_pcptr + (int64)4));
}

void * pc_khandlers_k_raise(void) {
    if (((int64)((*pc_decls_sptr).tag) != (int64)1)) {
        pc_support_pcerror((byte*)"Raise: not Int on stack [not proceeding direct to RAISE]");
    }
    return (void *)(pc_misc_raiseexception((*pc_decls_sptr).value));
}

void * pc_khandlers_k_applyop(void) {
    static uint64 codeseq[10];
    codeseq[((int64)1)-1] = (uint64)(pq_common_cmdmap[((*pc_decls_sptr).value)]);
    if (((int64)((*pc_decls_sptr).tag) != (int64)14)) {
        pc_support_pcerror((byte*)"Apply:no op");
    }
    if (((uint64)((*pc_decls_sptr).opdims) != (*(pc_decls_pcptr + (int64)1)))) {
        printf("%llu %u\n",(uint64)(*(pc_decls_pcptr + (int64)1)),(*pc_decls_sptr).opdims);
        pc_support_pcerror((byte*)"Apply:wrong #opnds");
    }
    ++pc_decls_sptr;
    codeseq[((int64)2)-1] = (*(pc_decls_pcptr + (int64)2));
    codeseq[((int64)3)-1] = (*(pc_decls_pcptr + (int64)3));
    return (void *)(&codeseq[((int64)1)-1]);
}

void * pc_khandlers_k_makeiter(void) {
    struct pc_decls_objrec *  p;
    p = (*pc_decls_sptr).objptr;
    (*pc_decls_sptr).itcount = (int32)(((int64)((*p).length) + (int64)1));
    if (((int64)((*pc_decls_sptr).tag)==(int64)29)) {
        (*pc_decls_sptr).varptr = (*p).vptr;
        (*pc_decls_sptr).tagx = (uint32)22u;
        (*pc_decls_sptr).ittype = (uint8)29u;
    } else if (((int64)((*pc_decls_sptr).tag)==(int64)5)) {
        (*pc_decls_sptr).refptr = (*p).strptr;
        (*pc_decls_sptr).tagx = (uint32)23u;
        (*pc_decls_sptr).ittype = (uint8)5u;
    }
    else {
        pc_support_pcustype((byte*)"makeiter",pc_decls_sptr);
    }
    return (void *)((pc_decls_pcptr + (int64)2));
}

void * pc_khandlers_k_forall(void) {
    struct pc_decls_varrec *  pit;
    struct pc_decls_varrec *  ploopvar;
    struct pc_decls_varrec *  pelem;
    pit = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)2)))));
    ploopvar = (struct pc_decls_varrec *)((pc_decls_frameptr + (int64)((*(pc_decls_pcptr + (int64)3)))));
    if (((int64)(--(*pit).itcount) <= (int64)0)) {
        return (void *)((pc_decls_pcptr + (int64)4));
    }
    if (!!((*ploopvar).hasref)) {
        --(*(*ploopvar).objptr).refcount;
    }
    if (((int64)((*pit).ittype)==(int64)29)) {
        pelem = (*pit).varptr;
        (*ploopvar) = (*pelem);
        if (!!((*ploopvar).hasref)) {
            ++(*(*ploopvar).objptr).refcount;
        }
        ++(*pit).varptr;
    } else if (((int64)((*pit).ittype)==(int64)5)) {
        pc_pcfns_pc_makechar((int64)((*(*pit).refptr)),ploopvar);
        ++(*pit).refptr;
    }
    else {
        pc_support_pcerror((byte*)"forall/type?");
    }
    return (void *)((uint64 *)((*(pc_decls_pcptr + (int64)1))));
}

void * pc_khandlers_k_forallx(void) {
    pc_support_pclunimpl((int64)212);
    return (void *)((pc_decls_pcptr + (int64)5));
}

void * pc_khandlers_k_foreach(void) {
    pc_support_pclunimpl((int64)213);
    return (void *)((pc_decls_pcptr + (int64)4));
}

void * pc_khandlers_k_foreachx(void) {
    pc_support_pclunimpl((int64)214);
    return (void *)((pc_decls_pcptr + (int64)5));
}

void * pc_khandlers_k_expandrange(void) {
    struct pc_decls_varrec *  x;
    x = pc_decls_sptr--;
    (*pc_decls_sptr).tagx = (uint32)1u;
    (*pc_decls_sptr).value = (int64)((*x).range_upper);
    (*x).value = (int64)((*x).range_lower);
    (*x).tagx = (uint32)1u;
    return (void *)((pc_decls_pcptr + (int64)1));
}

void pc_assem_c_fixup_asm(int64 mx) {
}

int64 pc_assem_c_asmavailable(void) {
    return (int64)0;
}

void pc_assem_c_addcountint(void * cmd) {
}

void pc_assem_c_addcountext(void) {
}

void pc_assem_c_showasmcmd(void * cmd) {
}

int64 * pc_assem_c_disploop_asm(void) {
    return (int64 *)(0);
}

uint32 pc_assem_c_getasmjump(int64 cmd) {
    return (uint32)0u;
}

int64 qc_qcompiler(byte * infile,byte * outfile) {
    printf("%s\n",(char*)((byte*)"Q Compiler [Integrated Version 2]"));
    qc_initdata();
    qc_getinputoptions();
    printf("%s %s %s %s\n",(char*)((byte*)"Compiling"),(char*)(infile),(char*)((byte*)"to"),(char*)(outfile));
    qc_do_loadmodules();
    qc_do_compilemodules();
    qc_do_writepcfile();
    return (int64)1;
}

void qc_qcstart(void) {
    int64 i;
    int64 status;
    int64 t;
    int64 n;
    int64 tx;
    int64 stopcode;
    byte *  file;
    struct var_decls_strec s;
    struct var_decls_modulerec m;
    printf("%s\n",(char*)((byte*)"*************** Q Compiler 13/MM"));
    qc_starttiming();
    qc_initdata();
    qc_getinputoptions();
    if (!!(qc_fshowoptions)) {
        qc_showoptions();
    }
    if ((var_decls_fverbose == (int64)0)) {
        printf("%s %s %s %s\n",(char*)((byte*)"Compiling"),(char*)(qc_infile),(char*)((byte*)"to"),(char*)(qc_outfile));
    }
    qc_initlogfile();
    if (!!((qc_passes & (int64)1))) {
        qc_do_loadmodules();
    }
    if (!!((qc_passes & (int64)2))) {
        qc_do_loadqafile();
    }
    if (!!((qc_passes & (int64)4))) {
        qc_do_writeqafile();
    }
    if (!!((qc_passes & ((int64)16 | (int64)32)))) {
        qc_do_compilemodules();
    }
    if (!!(qc_fshowpcl)) {
        qc_showpcl((byte*)"PCL",(int64)1);
    }
    if (!!((qc_passes & (int64)64))) {
        qc_do_writepcfile();
    }
    qc_showoutput();
    if (!!(qc_fdocs)) {
        qc_writedocs();
    }
    if (!!(qc_fshowlog)) {
        qc_closelogfile();
    }
    stopcode = (int64)0;
    exit(stopcode);
}

static void qc_do_loadmodules(void) {
    if ((var_decls_ninputfiles==(int64)0)) {
        qc_loaderror((byte*)"No sourcefile specified",(byte*)"");
    } else if ((var_decls_ninputfiles==(int64)1)) {
    }
    else {
    }
    if (!!(var_decls_fverbose)) {
        printf("%s %s\n",(char*)((byte*)"Loading:"),(char*)(qc_infile));
    }
    var_decls_loadstart = osnos_os_clock();
    qc_loadstatus = (byte)(qc_loadmainmodule(qc_infile));
    var_decls_loadend = osnos_os_clock();
}

static int64 qc_loadmainmodule(byte * filespec) {
    byte modulename[100];
    byte path[300];
    byte *  source;
    int64 status;
    struct var_decls_modulerec m;
    int64 i;
    int64 flag;
    mlib_pcm_clearmem((void *)(&var_decls_moduletable[((int64)0)]),(int64)118);
    var_decls_moduletable[((int64)0)].name = (byte*)"PROGRAM";
    var_decls_moduletable[((int64)0)].filename = (byte*)"<->";
    var_decls_moduletable[((int64)0)].sourcecode = (byte*)"<program>";
    var_decls_moduletable[((int64)0)].sourcelen = (int32)(strlen(var_decls_moduletable[((int64)0)].sourcecode));
    var_decls_stprogram = qc_lib_getduplnameptr((struct var_decls_strec *)(0),qc_lex_addnamestr((byte*)"$prog"),(int64)1);
    var_decls_moduletable[((int64)0)].stmodule = var_decls_stprogram;
    source = mlib_readfile(filespec);
    if ((source == 0)) {
        qc_loaderror((byte*)"Can't load main file:",filespec);
        return (int64)0;
    }
    strcpy(modulename,mlib_extractbasefile(filespec));
    strcpy(path,mlib_extractpath(filespec));
    if (!!(path[((int64)1)-1])) {
        ++var_decls_nsearchdirs;
L730:;
        for (i=var_decls_nsearchdirs;i>=(int64)2;--i) {
L731:;
            var_decls_searchdirs[(i)-1] = var_decls_searchdirs[((i - (int64)1))-1];
L732:;
        }
L733:;
        var_decls_searchdirs[((int64)1)-1] = mlib_pcm_copyheapstring(path);
    }
    qc_loadmodule(modulename,filespec,source,mlib_rfsize,(int64)2,&flag);
    return (int64)1;
}

static int64 qc_loadmodule(byte * modulename,byte * filespec,byte * source,int64 length,int64 id,int64 * exportflag) {
    struct var_decls_modulerec m;
    byte *  importnames[50];
    byte importflags[51];
    int64 importmoduleno[50];
    int64 nimports;
    int64 i;
    int64 status;
    int64 k;
    int64 flag;
    int64 j;
    mlib_pcm_clearmem((void *)(&m),(int64)118);
    m.name = mlib_pcm_copyheapstring(modulename);
    m.filename = mlib_pcm_copyheapstring(filespec);
    m.sourcecode = source;
    m.sourcelen = (int32)(length);
    var_decls_stmodule = qc_lib_getduplnameptr(var_decls_stprogram,qc_lex_addnamestr(m.name),id);
    qc_lib_adddef(var_decls_stprogram,var_decls_stmodule);
    m.stmodule = var_decls_stmodule;
    if ((var_decls_npendingmodules >= (int64)50)) {
        qc_loaderror((byte*)"Too many pendingmodules",modulename);
    }
    var_decls_pendingmodules[(++var_decls_npendingmodules)-1] = m.name;
    nimports = qc_readimportlist(&m,&importnames,&importflags,(int64)50);
    ++qc_modulelevel;
L734:;
    for (i=(int64)1;i<=nimports;++i) {
L735:;
        flag = (int64)0;
        if ((var_decls_fverbose == (int64)2)) {
            printf("%s %s\n",(char*)((byte*)"Load import for"),(char*)(modulename));
        }
        k = qc_loadimport(importnames[(i)-1],&flag);
        if (!!(flag)) {
            importflags[(i)] = (uint8)1u;
        }
        m.importmap[(k)-1] = (uint8)1u;
        importmoduleno[(i)-1] = k;
L736:;
    }
L737:;
L738:;
    for (i=(int64)1;i<=nimports;++i) {
L739:;
        if (!!(importflags[(i)])) {
            k = importmoduleno[(i)-1];
L742:;
            for (j=(int64)1;j<=var_decls_nmodules;++j) {
L743:;
                if (!!(var_decls_moduletable[(k)].importmap[(j)-1])) {
                    m.importmap[(j)-1] = (uint8)1u;
                }
L744:;
            }
L745:;
        }
L740:;
    }
L741:;
    --qc_modulelevel;
    --var_decls_npendingmodules;
    if ((var_decls_nmodules >= (int64)50)) {
        qc_loaderror((byte*)"Too many modules",modulename);
    }
    m.level = (int32)(qc_modulelevel);
    memcpy(&var_decls_moduletable[(++var_decls_nmodules)],&m,118);
    (*m.stmodule).attribs.ax_moduleno = (byte)(var_decls_nmodules);
    (*exportflag) = (int64)(importflags[((int64)0)]);
    return var_decls_nmodules;
}

static int64 qc_loadimport(byte * modulename,int64 * exportflag) {
    int64 i;
    byte *  ifilespec;
    byte filespec[300];
    byte *  source;
    byte *  newname;
    newname = modulename;
L746:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L747:;
        if (!!(mlib_eqstring(var_decls_moduletable[(i)].name,newname))) {
            return i;
        }
L748:;
    }
L749:;
L750:;
    for (i=(int64)1;i<=var_decls_npendingmodules;++i) {
L751:;
        if (!!(mlib_eqstring(var_decls_pendingmodules[(i)-1],newname))) {
            qc_loaderror((byte*)"Circular/mutual import",modulename);
        }
L752:;
    }
L753:;
    source = qc_getmodulestr(modulename,filespec);
    return qc_loadmodule(newname,filespec,source,mlib_rfsize,(int64)3,exportflag);
}

static int64 qc_readimportlist(struct var_decls_modulerec * m,byte * (*importnames)[],byte (*importflags)[],int64 maximports) {
    int64 n;
    int64 flag;
    int64 exportflag;
    byte *  s;
    byte name[100];
    byte libname[100];
    qc_lex_startlex((byte*)"IMPORTS",(*m).sourcecode);
    exportflag = (int64)0;
    n = (int64)0;
L754:;
    while (1) {
        qc_lex_lexreadtoken();
        if ((qc_lex_nextlx.symbol==(int64)33)) {
            goto L755;
        } else if ((qc_lex_nextlx.symbol==(int64)6) || (qc_lex_nextlx.symbol==(int64)32)) {
        } else if ((qc_lex_nextlx.symbol==(int64)34)) {
            flag = (int64)0;
            if (!!(qc_checkname((byte*)"import",(int64)0))            ) {
                qc_lex_lexreadtoken();
                if (((qc_lex_nextlx.symbol == (int64)31) && (qc_lex_nextlx.subcode == (int64)105))) {
                    flag = (int64)1;
                    qc_lex_lexreadtoken();
                }
                if ((qc_lex_nextlx.symbol != (int64)34)) {
                    mlib_abortprogram((byte*)"import: modulename expected");
                }
                if ((++n > maximports)) {
                    mlib_abortprogram((byte*)"too many imports");
                }
                strcpy(name,qc_lex_convertzstring(qc_lex_nextlx.svalue,qc_lex_nextlx.length));
                (*importnames)[(n)-1] = mlib_pcm_copyheapstring(name);
                (*importflags)[(n)] = (byte)(flag);
            }
            else if ((!!(qc_checkname((byte*)"export",(int64)0)) || !!(qc_checkname((byte*)"endexport",(int64)0)))) {
                exportflag = (int64)1;
                goto L754;
            }
            else if (!!(qc_checkname((byte*)"$windows",(int64)0))) {
                if (!!(osnos_os_iswindows())) {
                    goto L754;
                }
                else {
//skipthisline:
L756:;
L757:;
                    do {
                        qc_lex_lexreadtoken();
L758:;
                    } while (!((qc_lex_nextlx.symbol == (int64)32) || (qc_lex_nextlx.symbol == (int64)33)));;
L759:;
                }
            }
            else if (!!(qc_checkname((byte*)"$linux",(int64)0))) {
                if (!(!!(osnos_os_iswindows()))) {
                    goto L754;
                }
                else {
                    goto L756;
                }
            }
            else {
                goto L755;
            }
        }
        else {
            goto L755;
        }
    }
L755:;
    (*importflags)[((int64)0)] = (byte)(exportflag);
    return n;
}

static void qc_initlogfile(void) {
    if (!(!!(qc_fshowlog))) {
        return;
    }
    if ((qc_logdest==(int64)2)) {
        remove((byte*)"qq.log");
        var_decls_logdev = fopen((byte*)"qq.log",(byte*)"w");
    } else if ((qc_logdest==(int64)0) || (qc_logdest==(int64)1)) {
        var_decls_logdev = 0;
    }
}

static void qc_closelogfile(void) {
    byte str[100];
    int64 pos;
    if ((qc_logdest == (int64)2)    ) {
        fclose(var_decls_logdev);
        sprintf(str,(byte*)"\\m\\ed.bat  %s",(byte*)"qq.log");
        osnos_os_execwait(str,(int64)1,(byte *)(0));
    }
    else if ((!!(qc_dopause) && (qc_logdest != (int64)0))) {
        printf("%s",(char*)((byte*)"PrEss key..."));
        osnos_os_getch();
puts("");
    }
}

static void qc_initdata(void) {
    mlib_pcm_init();
    qc_lex_lexsetup();
    qc_support_inittypetables();
    qc_initsearchdirs();
    qc_lib_initqclib();
    qc_pcllib_initpclgen();
    qc_pcllib_initpcldata();
}

static void qc_initsearchdirs(void) {
    byte str1[300];
    byte str2[300];
    int64 i;
    var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = (byte*)"";
    strcpy(str1,osnos_os_gethostname());
    if (!!(str1[((int64)1)-1])) {
        strcpy(str2,mlib_extractpath(str1));
        var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = mlib_pcm_copyheapstring(str2);
    }
    strcpy(str1,osnos_os_getmpath());
    if (!!(str1[((int64)1)-1])) {
        var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = mlib_pcm_copyheapstring(str1);
    }
    var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = (byte*)"c:\\qapps\\";
    var_decls_searchdirs[(++var_decls_nsearchdirs)-1] = (byte*)"c:\\qq\\";
}

static byte * qc_getmodulestr(byte * modulename,byte * filespec) {
    byte *  ifile;
    byte *  source;
    if (!!((int64)0)) {
        source = q_libs_getintlib(modulename);
        if (!!(source)) {
            strcpy(filespec,(byte*)"<Internal>");
            return source;
        }
    }
    ifile = qc_findmodule(modulename);
    if ((ifile == 0)) {
        if (!(!!((int64)0))) {
            source = q_libs_getintlib(modulename);
            if (!!(source)) {
                if ((var_decls_fverbose == (int64)2)) {
                    printf("%s %s\n",(char*)((byte*)"FOUND INTERNAL LIB:"),(char*)(modulename));
                }
                strcpy(filespec,(byte*)"<Internal>");
                return source;
            }
        }
        qc_loaderror((byte*)"Can't locate import module:",modulename);
    }
    strcpy(filespec,ifile);
    source = mlib_readfile(filespec);
    if ((source == 0)) {
        qc_loaderror((byte*)"?Read file error:",filespec);
    }
    return source;
}

static byte * qc_findmodule(byte * modulename) {
    byte file[300];
    static byte filespec[300];
    byte *  s;
    int64 i;
    strcpy(file,modulename);
    strcpy(file,mlib_addext(file,(byte*)".q"));
    if ((var_decls_fverbose == (int64)2)) {
        printf("%s %s\n",(char*)((byte*)"Locating:"),(char*)(file));
    }
L760:;
    for (i=(int64)1;i<=var_decls_nsearchdirs;++i) {
L761:;
        strcpy(filespec,var_decls_searchdirs[(i)-1]);
        strcat(filespec,file);
        if ((var_decls_fverbose == (int64)2)) {
            printf("%s%lld%s %p %s %s\n",(char*)((byte*)"\t"),(int64)i,(char*)((byte*)": Checking File"),(void*)(&filespec),(char*)((byte*)"in"),(char*)(var_decls_searchdirs[(i)-1]));
        }
        if (!!(mlib_checkfile(filespec))) {
            if ((var_decls_fverbose == (int64)2)) {
                printf("%s %p\n",(char*)((byte*)"\tFound:"),(void*)(&filespec));
            }
            return filespec;
        }
L762:;
    }
L763:;
    return (byte *)(0);
}

static int64 qc_checkname(byte * name,int64 length) {
    if ((length == (int64)0)) {
        length = (int64)(strlen(name));
    }
    if (((qc_lex_nextlx.length == length) && ((int64)(memcmp((void *)(qc_lex_nextlx.svalue),(void *)(name),(uint64)(length))) == (int64)0))) {
        return (int64)1;
    }
    return (int64)0;
}

static void qc_getinputoptions(void) {
    int64 i;
    int64 j;
    int64 k;
    int64 paramno;
    int64 pmtype;
    int64 sw;
    byte *  name;
    byte *  value;
    byte *  ext;
    int64 av_1;
    paramno = (int64)2;
L764:;
    while (!!((pmtype = mlib_nextcmdparam(&paramno,&name,&value,(byte*)"q")))) {
        if ((pmtype==(int64)1)) {
            mlib_convlcstring(name);
L767:;
            for (sw=(int64)1;sw<=(int64)27;++sw) {
L768:;
                if (!!(mlib_eqstring(name,qc_optionnames[(sw)-1]))) {
                    qc_do_option(sw,value);
                    goto L770;
                }
L769:;
            }
            printf("%s %s\n",(char*)((byte*)"Unknown option:"),(char*)(name));
            exit((int64)99);
L770:;
        } else if ((pmtype==(int64)2)) {
            if ((var_decls_ninputfiles >= (int64)50)) {
                qc_loaderror((byte*)"Too many input files",(byte*)"");
            }
            var_decls_inputfiles[(++var_decls_ninputfiles)] = mlib_pcm_copyheapstring(name);
        }
L765:;
    }
L766:;
    if ((qc_passes == (int64)0)) {
        qc_passes = (int64)113;
    }
    if ((!!(qc_fshowlog) && (qc_logdest == (int64)0))) {
        qc_logdest = (int64)2;
    }
    if ((var_decls_ninputfiles == (int64)0)) {
        printf("%s\n",(char*)((byte*)"Usage:"));
        printf("%s%s %s\n",(char*)((byte*)"\t"),(char*)(msysc_sysparams[((int64)1)-1]),(char*)((byte*)"filename[.q]"));
        printf("%s%s %s\n",(char*)((byte*)"\t"),(char*)(msysc_sysparams[((int64)1)-1]),(char*)((byte*)"-help"));
        exit(0);
    }
    qc_infile = var_decls_inputfiles[((int64)1)];
    ext = mlib_extractext(qc_infile,(int64)0);
    mlib_convlcstring(ext);
    if (!!(mlib_eqstring(ext,(byte*)"q"))    ) {
    }
    else if (!!(mlib_eqstring(ext,(byte*)"qa"))) {
        if (!!((qc_passes & (int64)1))) {
            qc_passes &= ~((int64)1);
            qc_passes |= (int64)2;
        }
    }
    else {
        qc_loaderror((byte*)"Unknown file extension:",qc_infile);
    }
    qc_outfile = mlib_pcm_copyheapstring(mlib_changeext(qc_infile,(byte*)"pc"));
}

static void qc_do_option(int64 sw,byte * value) {
    int64 length;
    if ((sw==(int64)1)) {
        qc_passes = (int64)1;
    } else if ((sw==(int64)3)) {
        qc_passes = (int64)5;
    } else if ((sw==(int64)2)) {
        qc_passes = (int64)9;
    } else if ((sw==(int64)4)) {
        qc_passes = (int64)17;
    } else if ((sw==(int64)5)) {
        qc_passes = (int64)49;
    } else if ((sw==(int64)6) || (sw==(int64)7)) {
        qc_passes = (int64)113;
    } else if ((sw==(int64)8)) {
        qc_fshowoptions = (uint8)1u;
    } else if ((sw==(int64)9)) {
        qc_fshowmodules = (uint8)1u;
    } else if ((sw==(int64)10)) {
        qc_fshowfiles = (uint8)1u;
    } else if ((sw==(int64)11)) {
        qc_fshowast = (uint8)1u;
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)12)) {
        qc_fshowst = (uint8)1u;
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)13)) {
        qc_fshowstflat = (uint8)1u;
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)18)) {
        qc_fshowpcl = (uint8)1u;
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)16)) {
        qc_fshowtypes = (uint8)1u;
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)17)) {
        qc_fshowfields = (uint8)1u;
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)14)) {
        qc_fshowdis = (uint8)1u;
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)15)) {
        qc_fshowpaths = (uint8)1u;
    } else if ((sw==(int64)19)) {
        qc_logdest = (int64)1;
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)20)) {
        qc_logdest = (int64)2;
        if (!(!!(qc_fshowlog))) {
            qc_fshowast = (uint8)1u;
            qc_fshowst = (uint8)1u;
            qc_fshowpcl = (uint8)1u;
        }
        qc_fshowlog = (uint8)1u;
    } else if ((sw==(int64)21)) {
        qc_fshowtiming = (uint8)1u;
    } else if ((sw==(int64)22)) {
        var_decls_fverbose = (int64)1;
    } else if ((sw==(int64)23)) {
        var_decls_fverbose = (int64)2;
    } else if ((sw==(int64)24) || (sw==(int64)25)) {
        qc_showhelp();
    } else if ((sw==(int64)26)) {
        qc_fdocs = (uint8)1u;
    }
}

static int64 qc_do_parse(int64 n) {
    int64 status;
    status = qc_parse_parsemodule(n);
    return status;
}

static int64 qc_do_codegen(int64 n) {
    int64 status;
    status = qc_pclgen_codegen(n);
    return status;
}

static void qc_showast(void) {
    int64 i;
    if (!!(qc_logdest)) {
        if ((qc_logdest == (int64)2)) {
            fprintf(var_decls_logdev,"\n");
        }
L771:;
        for (i=(int64)1;i<=var_decls_nmodules;++i) {
L772:;
            qc_lib_printcode(var_decls_logdev,(byte*)"AST",i);
L773:;
        }
L774:;
        fprintf(var_decls_logdev,"\n");
    }
}

static void qc_showstflat(byte * caption) {
    if (!!(qc_logdest)) {
        if ((qc_logdest == (int64)2)) {
        }
        fprintf(var_decls_logdev,"%s %s\n",(char*)((byte*)"PROC"),(char*)(caption));
        qc_lib_printstflat(var_decls_logdev);
        fprintf(var_decls_logdev,"\n");
    }
}

static void qc_showsttree(void) {
    if (!!(qc_logdest)) {
        if ((qc_logdest == (int64)2)) {
        }
        fprintf(var_decls_logdev,"%s\n",(char*)((byte*)"PROC ST"));
        qc_lib_printst(var_decls_logdev,var_decls_moduletable[((int64)0)].stmodule,(int64)0);
        fprintf(var_decls_logdev,"\n");
    }
}

static void qc_showpcl(byte * caption,int64 phase) {
    struct mlib_strbuffer *  pclstr;
    int64 i;
    if (!!(qc_logdest)) {
        if ((qc_logdest == (int64)2)) {
        }
L775:;
        for (i=(int64)0;i<=var_decls_nmodules;++i) {
L776:;
            pclstr = qc_pcllib_writepccode(caption,i);
            mlib_gs_println(pclstr,var_decls_logdev);
L777:;
        }
L778:;
    }
}

static void qc_showgenfields(void) {
    if (!!(qc_logdest)) {
        qc_lib_printgenfieldtable(var_decls_logdev,(byte*)"PROC Generic Fields Table");
        fprintf(var_decls_logdev,"\n");
    }
}

static void qc_loaderror(byte * mess,byte * mess2) {
    printf("%s %s %s\n",(char*)((byte*)"Load Error:"),(char*)(mess),(char*)(mess2));
    printf("%s\n",(char*)((byte*)"Stopping"));
    exit(0);
}

static void qc_do_showprogdiags_pc(byte * caption) {
    int64 i;
    struct var_decls_strec *  d;
    struct var_decls_procrec *  pp;
    if (!!(qc_logdest)) {
        printf("%s\n",(char*)((byte*)"DONE INITPC"));
        fprintf(var_decls_logdev,"%s\n",(char*)((byte*)"SHOW ALL PC PCL2"));
        fprintf(var_decls_logdev,"%s\n",(char*)(caption));
        qc_showpcl((byte*)"ALL MODULES",(int64)2);
    }
}

static void qc_getsyscmdline(void) {
    int64 i;
L779:;
    for (i=(int64)1;i<=msysc_nsysparams;++i) {
L780:;
        if ((i <= (int64)32)) {
            var_decls_cmdparamtable[((i - (int64)1))] = mlib_pcm_copyheapstring(msysc_sysparams[(i)-1]);
        }
L781:;
    }
L782:;
    var_decls_ncmdparams = (msysc_nsysparams - (int64)1);
}

static void qc_showmodules(void) {
    int64 i;
    int64 j;
    int64 k;
    struct var_decls_modulerec m;
    int64 av_1;
    printf("%s %lld\n",(char*)((byte*)"Modules:"),(int64)var_decls_nmodules);
L783:;
    for (i=var_decls_nmodules;i>=(int64)1;--i) {
L784:;
        memcpy(&m,&var_decls_moduletable[(i)],118);
        j = ((var_decls_nmodules - i) + (int64)1);
        printf("%lld%s",(int64)j,(char*)((byte*)":"));
        av_1 = (int64)(m.level);
        while (av_1-- > 0) {
L787:;
            printf("%s",(char*)((byte*)"  "));
L788:;
        }
L789:;
        printf("%s %d %p\n",(char*)(m.name),m.sourcelen,(void*)(m.stmodule));
        printf("%s",(char*)((byte*)"       "));
L790:;
        for (j=(int64)1;j<=var_decls_nmodules;++j) {
L791:;
            k = (int64)(m.importmap[(j)-1]);
            if (!!(k)) {
                printf("%s%s",(char*)(var_decls_moduletable[(j)].name),(char*)((byte*)" "));
            }
L792:;
        }
L793:;
puts("");
L785:;
    }
L786:;
    if (!!(var_decls_nextra)) {
        printf("%s %lld\n",(char*)((byte*)"Extra Modules"),(int64)var_decls_nextra);
L794:;
        for (i=(int64)1;i<=var_decls_nextra;++i) {
L795:;
            printf("%lld %s %s %lld %p\n",(int64)i,(char*)((byte*)":"),(char*)(var_decls_extrafiles[(i)-1]),(int64)var_decls_extrasizes[(i)-1],(void *)(var_decls_extratext[(i)-1]));
L796:;
        }
L797:;
    }
}

static void qc_do_compilemodules(void) {
    int64 i;
    int64 status;
    qc_compilestatus = (uint8)1u;
L798:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L799:;
        qc_compilestatus = (byte)(qc_compilemodule(i));
        if (!(!!(qc_compilestatus))) {
            return;
        }
L800:;
    }
L801:;
}

static int64 qc_compilemodule(int64 n) {
    int64 status;
    struct var_decls_modulerec m;
    int64 ntokens = (int64)0;
    byte *  s;
    var_decls_currmoduleno = n;
    var_decls_currmodule = &var_decls_moduletable[(n)];
    memcpy(&m,&var_decls_moduletable[(n)],118);
    (*m.stmodule).nameid = (uint8)2u;
//freddy:
L802:;
    status = qc_do_parse(n);
    qc_totallines += qc_lex_lx.lineno;
    if ((!!(status) && !!((qc_passes & (int64)32)))) {
        status = qc_do_codegen(n);
        if (!!(status)) {
            qc_totalpclopcodes += qc_pcllib_pcindex;
        }
    }
    (*m.stmodule).nameid = (uint8)3u;
    return status;
}

static void qc_starttiming(void) {
    int64 t;
    qc_clockstart = osnos_os_clock();
}

static void qc_showtiming(void) {
    int64 t;
    int64 i;
    t = (osnos_os_clock() - qc_clockstart);
    printf("%lld %s\n",(int64)((t * (int64)1000) / osnos_os_getclockspersec()),(char*)((byte*)"msec\tLoad/compile time"));
    printf("%lld%s\n",(int64)qc_totallines,(char*)((byte*)"\tTotal lines compiled"));
    if ((t > (int64)1)) {
        printf("%lld%s\n",(int64)(int64)((((double)(qc_totallines) / (double)(t)) * (double)(osnos_os_getclockspersec()))),(char*)((byte*)"\tLines per second compile speed"));
    }
    printf("%lld%s\n",(int64)qc_totalpclopcodes,(char*)((byte*)"\tPCL byte-codes generated"));
}

static void qc_do_writeqafile(void) {
    void *  f;
    int64 i;
    int64 k;
    int64 nextra;
    struct var_decls_modulerec m;
    byte filename[300];
    byte *  file;
    int64 offsets[50];
    int64 infooffsets[50];
    int64 extraoffsets[10];
    byte *  text;
    strcpy(filename,var_decls_moduletable[(var_decls_nmodules)].name);
    strcpy(filename,mlib_changeext(filename,(byte*)".qa"));
    f = fopen(filename,(byte*)"wb");
    if ((f == 0)) {
        printf("%s %s\n",(char*)((byte*)"Couldn't create"),(char*)(filename));
        exit((int64)1);
    }
    nextra = (var_decls_ninputfiles - (int64)1);
    if ((nextra > (int64)10)) {
        qc_loaderror((byte*)"qa:too many extra files",(byte*)"");
    }
L803:;
    for (i=(int64)1;i<=nextra;++i) {
L804:;
        var_decls_extrafiles[(i)-1] = var_decls_inputfiles[((i + (int64)1))];
L805:;
    }
L806:;
    fprintf(f,"%s\n",(char*)((byte*)"qa file"));
    fprintf(f,"%s %lld %lld\n",(char*)((byte*)"modules"),(int64)var_decls_nmodules,(int64)nextra);
L807:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L808:;
        memcpy(&m,&var_decls_moduletable[(i)],118);
        fprintf(f,"%s %s%s",(char*)((byte*)"module"),(char*)(m.name),(char*)((byte*)" "));
L811:;
        for (k=(int64)1;k<=var_decls_nmodules;++k) {
L812:;
            if (!!(m.importmap[(k)-1])) {
                fprintf(f,"%lld %s",(int64)k,(char*)((byte*)""));
            }
L813:;
        }
L814:;
        fprintf(f,"%s",(char*)((byte*)"0 "));
        infooffsets[(i)-1] = (int64)(ftell(f));
        fprintf(f,"%s\n",(char*)((byte*)"# #                         "));
L809:;
    }
L810:;
L815:;
    for (i=(int64)1;i<=nextra;++i) {
L816:;
        fprintf(f,"%s%s%s",(char*)((byte*)"file \""),(char*)(var_decls_extrafiles[(i)-1]),(char*)((byte*)"\" "));
        infooffsets[((i + var_decls_nmodules))-1] = (int64)(ftell(f));
        fprintf(f,"%s\n",(char*)((byte*)"# #              "));
L817:;
    }
L818:;
    fprintf(f,"%s\n",(char*)((byte*)"end"));
    fprintf(f,"%s\n",(char*)((byte*)"!This generated file should not be manually edited if the above"));
    fprintf(f,"%s\n",(char*)((byte*)"!byte offsets and sizes are to be valid."));
L819:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L820:;
        memcpy(&m,&var_decls_moduletable[(i)],118);
        fprintf(f,"%s\n",(char*)((byte*)"======================"));
        fprintf(f,"%s %s %lld%s%lld\n",(char*)((byte*)"module "),(char*)(m.name),(int64)i,(char*)((byte*)"/"),(int64)var_decls_nmodules);
        fprintf(f,"%s\n",(char*)((byte*)"======================"));
        offsets[(i)-1] = (int64)(ftell(f));
        fwrite((void *)(m.sourcecode),(uint64)((int64)1),(uint64)(m.sourcelen),f);
L821:;
    }
L822:;
    printf("%s %lld\n",(char*)((byte*)"NEXTRA="),(int64)nextra);
L823:;
    for (i=(int64)1;i<=nextra;++i) {
L824:;
        memcpy(&m,&var_decls_moduletable[(i)],118);
        fprintf(f,"%s\n",(char*)((byte*)"======================"));
        fprintf(f,"%s%s%s%lld\n",(char*)((byte*)"file "),(char*)(var_decls_extrafiles[(i)-1]),(char*)((byte*)"/"),(int64)nextra);
        fprintf(f,"%s\n",(char*)((byte*)"======================"));
        extraoffsets[(i)-1] = (int64)(ftell(f));
        text = mlib_readfile(var_decls_extrafiles[(i)-1]);
        if ((text == 0)) {
            printf("%s\n",(char*)(var_decls_extrafiles[(i)-1]));
            qc_loaderror((byte*)"qa/can't load extra file",(byte*)"");
        }
        var_decls_extrasizes[(i)-1] = mlib_rfsize;
        fwrite((void *)(text),(uint64)((int64)1),(uint64)(mlib_rfsize),f);
L825:;
    }
L826:;
    fprintf(f,"%s\n",(char*)((byte*)"======================"));
    fprintf(f,"%s\n",(char*)((byte*)"end"));
    fprintf(f,"%s\n",(char*)((byte*)"======================"));
L827:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L828:;
        fseek(f,(int32)(infooffsets[(i)-1]),(int32)0);
        fprintf(f,"%lld %d",(int64)offsets[(i)-1],var_decls_moduletable[(i)].sourcelen);
L829:;
    }
L830:;
L831:;
    for (i=(int64)1;i<=nextra;++i) {
L832:;
        fseek(f,(int32)(infooffsets[((i + var_decls_nmodules))-1]),(int32)0);
        fprintf(f,"%lld %lld",(int64)extraoffsets[(i)-1],(int64)var_decls_extrasizes[(i)-1]);
L833:;
    }
L834:;
    fclose(f);
    if (!!(var_decls_fverbose)) {
        printf("%s %p\n",(char*)((byte*)"Finished writing"),(void*)(&filename));
    }
}

static void qc_checkkeyword(byte * kwd) {
    int64 length;
    qc_lex_lexreadtoken();
    length = (int64)(strlen(kwd));
    if (!((((qc_lex_nextlx.symbol == (int64)34) && (qc_lex_nextlx.length == length)) && ((int64)(memcmp((void *)(qc_lex_nextlx.svalue),(void *)(kwd),(uint64)(length))) == (int64)0)))) {
        qc_loaderror((byte*)"QA: expected:",kwd);
    }
}

static int64 qc_readinttoken(void) {
    qc_lex_lexreadtoken();
    if ((qc_lex_nextlx.symbol != (int64)37)) {
        qc_loaderror((byte*)"Int expected",(byte*)"");
    }
    return qc_lex_nextlx.value;
}

static int64 qc_do_loadqafile(void) {
    byte modulename[100];
    byte name[100];
    byte *  source;
    int64 status;
    int64 i;
    int64 k;
    int64 offset;
    int64 length;
    struct var_decls_modulerec m;
    byte *  p;
    qc_infile = var_decls_inputfiles[((int64)1)];
    mlib_pcm_clearmem((void *)(&var_decls_moduletable[((int64)0)]),(int64)118);
    var_decls_moduletable[((int64)0)].name = (byte*)"PROGRAM";
    var_decls_moduletable[((int64)0)].filename = (byte*)"<->";
    var_decls_moduletable[((int64)0)].sourcecode = (byte*)"<program>";
    var_decls_moduletable[((int64)0)].sourcelen = (int32)(strlen(var_decls_moduletable[((int64)0)].sourcecode));
    var_decls_stprogram = qc_lib_getduplnameptr((struct var_decls_strec *)(0),qc_lex_addnamestr((byte*)"$prog"),(int64)1);
    var_decls_moduletable[((int64)0)].stmodule = var_decls_stprogram;
    source = mlib_readfile(qc_infile);
    if ((source == 0)) {
        qc_loaderror((byte*)"Can't load qa file:",qc_infile);
        return (int64)0;
    }
    qc_lex_startlex((byte*)"QA",source);
    qc_checkkeyword((byte*)"qa");
    qc_checkkeyword((byte*)"file");
    qc_lex_lexreadtoken();
    qc_checkkeyword((byte*)"modules");
    var_decls_nmodules = qc_readinttoken();
    var_decls_nextra = qc_readinttoken();
    if (((var_decls_nmodules > (int64)50) || (var_decls_nextra > (int64)10))) {
        qc_loaderror((byte*)"QA:Too many modules",(byte*)"");
    }
    qc_lex_lexreadtoken();
L835:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L836:;
        qc_checkkeyword((byte*)"module");
        qc_lex_lexreadtoken();
        memcpy((void *)(&name),(void *)(qc_lex_nextlx.svalue),(uint64)(qc_lex_nextlx.length));
        name[((qc_lex_nextlx.length + (int64)1))-1] = (uint8)0u;
        mlib_pcm_clearmem((void *)(&m),(int64)118);
        m.name = mlib_pcm_copyheapstring(name);
        m.filename = m.name;
L839:;
        while (1) {
            k = qc_readinttoken();
            if ((k == (int64)0)) {
                goto L840;
            }
            m.importmap[(k)-1] = (uint8)1u;
        }
L840:;
        p = (m.sourcecode = (source + qc_readinttoken()));
        m.sourcelen = (int32)(qc_readinttoken());
        m.level = (int32)0;
        (*(p + (int64)(m.sourcelen))) = (uint8)26u;
        (*((p + (int64)(m.sourcelen)) + (int64)1)) = (uint8)0u;
        qc_lex_lexreadtoken();
        var_decls_stmodule = qc_lib_getduplnameptr(var_decls_stprogram,qc_lex_addnamestr(m.name),((i < var_decls_nmodules)?(int64)3:(int64)2));
        qc_lib_adddef(var_decls_stprogram,var_decls_stmodule);
        m.stmodule = var_decls_stmodule;
        (*var_decls_stmodule).attribs.ax_moduleno = (byte)(i);
        memcpy(&var_decls_moduletable[(i)],&m,118);
L837:;
    }
L838:;
L841:;
    for (i=(int64)1;i<=var_decls_nextra;++i) {
L842:;
        qc_checkkeyword((byte*)"file");
        qc_lex_lexreadtoken();
        memcpy((void *)(name),(void *)(qc_lex_nextlx.svalue),(uint64)(qc_lex_nextlx.length));
        name[((qc_lex_nextlx.length + (int64)1))-1] = (uint8)0u;
        var_decls_extrafiles[(i)-1] = mlib_pcm_copyheapstring(name);
        var_decls_extratext[(i)-1] = (p = (source + qc_readinttoken()));
        var_decls_extrasizes[(i)-1] = (length = qc_readinttoken());
        (*(p + length)) = (uint8)0u;
        qc_lex_lexreadtoken();
L843:;
    }
L844:;
    return (int64)1;
}

static void qc_showinttiming(byte * caption) {
    int64 t;
    int64 i;
    t = (osnos_os_clock() - qc_clockstart);
    printf("%lld %s %s\n",(int64)((t * (int64)1000) / osnos_os_getclockspersec()),(char*)((byte*)"msec"),(char*)(caption));
}

static void qc_do_writepcfile(void) {
    void *  f;
    int64 i;
    int64 length;
    int64 symbolpos;
    int64 currpos;
    struct var_decls_modulerec m;
    byte filename[300];
    byte *  file;
    byte *  s;
    byte *  t;
    strcpy(filename,var_decls_moduletable[(var_decls_nmodules)].filename);
    strcpy(filename,mlib_changeext(filename,(byte*)".pc"));
    qc_support_initpcdest();
    qc_pclgen_doprogramstartup();
    qc_support_writezint((int64)80);
    qc_support_writezint((int64)67);
    qc_support_writezint((int64)26);
    qc_support_writezint((int64)0);
    qc_support_writezint((int64)1);
    qc_support_writezstring((byte*)"403");
    qc_support_writezint((int64)2);
    qc_support_writezint(var_decls_nmodules);
L845:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L846:;
        qc_support_writezstring(var_decls_moduletable[(i)].name);
L847:;
    }
L848:;
    qc_support_writezint((int64)3);
    qc_support_writezint(var_decls_ndlltable);
L849:;
    for (i=(int64)1;i<=var_decls_ndlltable;++i) {
L850:;
        qc_support_writezstring(var_decls_dlltable[(i)-1]);
L851:;
    }
L852:;
    qc_support_writezint((int64)4);
    qc_support_writezint(var_decls_ndllproctable);
L853:;
    for (i=(int64)1;i<=var_decls_ndllproctable;++i) {
L854:;
        qc_support_writezstring(var_decls_dllproctable[(i)-1].name);
        qc_support_writezint((int64)(var_decls_dllproctable[(i)-1].dllindex));
L855:;
    }
L856:;
    qc_support_writezint((int64)5);
    symbolpos = qc_support_getpcpos();
    qc_support_writezint4((int64)0);
L857:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L858:;
        qc_showpcsymbol(var_decls_moduletable[(i)].stmodule);
L859:;
    }
L860:;
L861:;
    for (i=(int64)53;i<=var_decls_ntypes;++i) {
L862:;
        qc_showpcsymbol(var_decls_ttnamedef[(i)]);
L863:;
    }
L864:;
L865:;
    for (i=(int64)0;i<=var_decls_nmodules;++i) {
L866:;
        qc_writesymbols(i);
L867:;
    }
L868:;
    currpos = qc_support_getpcpos();
    qc_support_setpcpos(symbolpos);
    qc_support_writezint4(var_decls_nsymbols);
    qc_support_setpcpos(currpos);
    qc_support_writezint((int64)6);
    qc_support_writezint(((var_decls_ntypes - (int64)53) + (int64)1));
L869:;
    for (i=(int64)53;i<=var_decls_ntypes;++i) {
L870:;
        qc_support_writezint(i);
        qc_support_writezstring(var_decls_ttname[(i)]);
        qc_support_writezint((int64)((*var_decls_ttnamedef[(i)]).bcindex));
        qc_support_writezint((int64)(var_decls_ttbasetype[(i)]));
        qc_support_writezint((int64)(var_decls_tttarget[(i)]));
        qc_support_writezint((int64)(var_decls_ttlower[(i)]));
        qc_support_writezint((int64)(var_decls_ttlength[(i)]));
        qc_support_writezint((int64)(var_decls_ttsize[(i)]));
L871:;
    }
L872:;
    qc_fixup_genfields();
    qc_support_writezint((int64)13);
    qc_support_writezint(var_decls_nstrings);
L873:;
    for (i=(int64)1;i<=var_decls_nstrings;++i) {
L874:;
        qc_support_writezint((*var_decls_stringlentable)[(i)-1]);
        qc_support_writezblock((*var_decls_stringtable)[(i)-1],(*var_decls_stringlentable)[(i)-1]);
L875:;
    }
L876:;
    qc_writestructfields();
L877:;
    for (i=(int64)0;i<=var_decls_nmodules;++i) {
L878:;
        qc_writepccode2pc(i);
L879:;
    }
L880:;
    qc_support_writezint((int64)7);
    qc_support_writezint(var_decls_ngenfieldnames);
L881:;
    for (i=(int64)1;i<=var_decls_ngenfieldnames;++i) {
L882:;
        qc_support_writezstring((*var_decls_genfieldnames[(i)-1].def).name);
        qc_support_writezint((int64)(var_decls_genfieldnames[(i)-1].dataindex));
        qc_support_writezint((int64)(var_decls_genfieldnames[(i)-1].datalength));
L883:;
    }
L884:;
    qc_support_writezint((int64)8);
    qc_support_writezint(var_decls_ngenfielddata);
L885:;
    for (i=(int64)1;i<=var_decls_ngenfielddata;++i) {
L886:;
        qc_support_writezint((int64)(var_decls_genfielddata[(i)-1].fieldindex));
        qc_support_writezint((int64)(var_decls_genfielddata[(i)-1].recordtype));
        qc_support_writezint((int64)(var_decls_genfielddata[(i)-1].fieldtype));
        qc_support_writezint((int64)(var_decls_genfielddata[(i)-1].offset));
L887:;
    }
L888:;
    qc_support_writezint((int64)12);
    qc_support_writezeof();
    length = qc_support_getpcpos();
    qc_support_writepcdata(filename);
    if (!!(var_decls_fverbose)) {
        printf("%s %s %lld %s\n",(char*)((byte*)"Finished writing"),(char*)(filename),(int64)length,(char*)((byte*)"bytes"));
    }
}

static void qc_writesymbols(int64 mx) {
    int64 *  p;
    int64 *  pccode;
    struct var_decls_strec *  d;
    int64 cmd;
    int64 i;
    int64 index;
    int64 av_1;
    pccode = (p = (int64 *)(var_decls_moduletable[(mx)].pccode));
L889:;
    while (1) {
        cmd = (*p++);
L891:;
        for (i=(int64)1;i<=(int64)(qc_pcllib_cmdnopnds[(cmd)]);++i) {
L892:;
            switch ((int64)(pq_common_cmdfmt[(cmd)][(i)-1])) {
            case 3:;
                d = (struct var_decls_strec *)((*p));
                qc_showpcsymbol(d);
                (*p) = (int64)((*d).bcindex);
                break;
            case 4:;
                d = (struct var_decls_strec *)((*p));
                (*p) = (int64)((*d).index);
                break;
            case 1:;
                d = (struct var_decls_strec *)((*p));
                qc_showpcsymbol(d);
                (*p) = (int64)((*d).bcindex);
                break;
            case 2:;
                d = (struct var_decls_strec *)((*p));
                (*p) = ((int64)((*d).index) * (int64)16);
                break;
            case 9:;
                if (((cmd == (int64)63) && (i == (int64)2))                ) {
                    (*p) = ((*p) * (int64)16);
                }
                else if (((cmd == (int64)64) && (i == (int64)2))) {
                    (*p) = ((*p) * (int64)16);
                }
                else if (((cmd == (int64)72) && (i == (int64)1))) {
                    (*p) = ((*p) * (int64)16);
                }
                break;
            default:;
            }
            ++p;
L893:;
        }
L894:;
        if (((cmd == (int64)4) || (cmd == (int64)0))) {
            goto L890;
        }
    }
L890:;
}

static void qc_showpcsymbol(struct var_decls_strec * d) {
    int64 a;
    int64 b;
    byte c;
    a = (b = (int64)0);
    if (((int64)((*d).bcindex) == (int64)0)) {
        (*d).bcindex = (int32)(++var_decls_nsymbols);
        if (((int64)((*d).nameid)==(int64)6)) {
            c = (uint8)80u;
            a = (int64)((*d).index);
        } else if (((int64)((*d).nameid)==(int64)10)) {
            c = (uint8)83u;
        } else if (((int64)((*d).nameid)==(int64)2) || ((int64)((*d).nameid)==(int64)3)) {
            c = (uint8)77u;
            a = (int64)((*d).attribs.ax_moduleno);
        } else if (((int64)((*d).nameid)==(int64)5)) {
            c = (uint8)84u;
            a = (int64)((*d).mode);
        } else if (((int64)((*d).nameid)==(int64)1)) {
            return;
        }
        else {
            qc_loaderror((byte*)"SHOWPCSYM?",(byte*)"");
        }
        qc_support_writezint((int64)(c));
        qc_support_writezstring((*d).name);
        qc_support_writezint((int64)((*(*d).owner).bcindex));
        qc_support_writezint(a);
        qc_support_writezint(b);
        if (((int64)(c) == (int64)80)) {
            if (!!((*d).metadata)) {
                qc_support_writezstring((*d).metadata);
            }
            else {
                qc_support_writezstring((byte*)"");
            }
        }
    }
}

static void qc_writepccode2pc(int64 mx) {
    int64 *  p;
    int64 *  pccode;
    uint16 (*linetable)[];
    struct var_decls_strec *  d;
    int64 cmd;
    int64 i;
    int64 index;
    int64 pcindex;
    int64 startindex;
    int64 av_1;
    qc_support_writezint((int64)11);
    qc_support_writezint(mx);
    qc_support_writezint((int64)(var_decls_moduletable[(mx)].pcindex));
    pccode = (p = (int64 *)(var_decls_moduletable[(mx)].pccode));
    linetable = var_decls_moduletable[(mx)].linetable;
    pcindex = (int64)1;
L895:;
    while (1) {
        cmd = (*p++);
        qc_support_writezint((int64)((*linetable)[(pcindex)]));
        qc_support_writezint(cmd);
        startindex = pcindex++;
L897:;
        for (i=(int64)1;i<=(int64)(qc_pcllib_cmdnopnds[(cmd)]);++i) {
L898:;
            switch ((int64)(pq_common_cmdfmt[(cmd)][(i)-1])) {
            case 8:;
            case 3:;
            case 4:;
            case 1:;
            case 2:;
            case 9:;
            case 10:;
            case 11:;
            case 14:;
            case 15:;
            case 7:;
            case 16:;
                qc_support_writezint((*p));
                break;
            case 12:;
                qc_support_writezreal(*(double*)&(*p));
                break;
            case 13:;
                qc_support_writezrange((byte *)(p));
                break;
            default:;
                printf("%s\n",(char*)(pq_common_opndnames[((int64)(pq_common_cmdfmt[(cmd)][(i)-1]))]));
                qc_loaderror((byte*)"writepc2bc/opnd?",(byte*)"");
            }
            ++pcindex;
            ++p;
L899:;
        }
L900:;
        if (((cmd == (int64)4) || (cmd == (int64)0))) {
            goto L896;
        }
    }
L896:;
}

static void qc_writestructfields(void) {
    int64 structpos;
    int64 currpos;
    int64 nstructfields;
    int64 i;
    int64 j;
    int64 t;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    struct var_decls_strec *  fieldlist[100];
    byte ignore[100];
    int64 nfields;
    qc_support_writezint((int64)10);
    structpos = qc_support_getpcpos();
    qc_support_writezint4((int64)0);
    nstructfields = (int64)0;
L901:;
    for (t=(int64)53;t<=var_decls_ntypes;++t) {
L902:;
        if (((int64)(var_decls_ttbasetype[(t)]) == (int64)33)) {
            d = (*var_decls_ttnamedef[(t)]).deflist;
            nfields = (int64)0;
L905:;
            while (!!(d)) {
                if ((((int64)((*d).nameid) == (int64)13) && !(!!((*d).attribs.ax_at)))) {
                    ++nfields;
                    if ((nfields > (int64)100)) {
                        qc_loaderror((byte*)"wsf: too many fields in struct",(byte*)"");
                    }
                    fieldlist[(nfields)-1] = d;
                    ignore[(nfields)-1] = (uint8)0u;
                }
                d = (*d).nextdef;
L906:;
            }
L907:;
L908:;
            for (i=(int64)1;i<=nfields;++i) {
L909:;
                d = fieldlist[(i)-1];
L912:;
                for (j=(i + (int64)1);j<=nfields;++j) {
L913:;
                    if ((i != j)) {
                        e = fieldlist[(j)-1];
                        if (((*d).offset == (*e).offset)) {
                            ignore[(i)-1] = (uint8)1u;
                        }
                    }
L914:;
                }
L915:;
L910:;
            }
L911:;
L916:;
            for (i=nfields;i>=(int64)1;--i) {
L917:;
                if (!(!!(ignore[(i)-1]))) {
                    d = fieldlist[(i)-1];
                    ++nstructfields;
                    qc_support_writezint(t);
                    qc_support_writezstring((*d).name);
                    qc_support_writezint((int64)((*d).mode));
                    qc_support_writezint((int64)((*d).offset));
                }
L918:;
            }
L919:;
        }
L903:;
    }
L904:;
    currpos = qc_support_getpcpos();
    qc_support_setpcpos(structpos);
    qc_support_writezint4(nstructfields);
    qc_support_setpcpos(currpos);
}

static void qc_fixup_genfields(void) {
    int64 recordtype;
    int64 fieldtype;
    int64 i;
    int64 offset;
    struct var_decls_strec *  d;
    struct var_decls_strec *  p;
    struct var_decls_strec *  q;
    var_decls_ngenfielddata = (int64)0;
L920:;
    for (i=(int64)1;i<=var_decls_ngenfieldnames;++i) {
L921:;
        d = var_decls_genfieldnames[(i)-1].def;
        var_decls_genfieldnames[(i)-1].dataindex = (int32)((var_decls_ngenfielddata + (int64)1));
        p = (*d).nextdupl;
L924:;
        while (!!(p)) {
            offset = (int64)((*p).offset);
            if (((int64)((*p).nameid) == (int64)13)            ) {
                recordtype = (int64)((*(*p).owner).mode);
                fieldtype = (int64)((*p).mode);
            }
            else if ((((int64)((*p).nameid) == (int64)6) && (((int64)((*(*p).owner).nameid) != (int64)2) && ((int64)((*(*p).owner).nameid) != (int64)3)))) {
                recordtype = (int64)((*(*p).owner).mode);
                fieldtype = (int64)18;
            }
            else if ((((int64)((*p).nameid) == (int64)19) && ((int64)((*(*p).owner).nameid) != (int64)2))) {
                q = p;
L927:;
                do {
                    q = (*q).equiv;
L928:;
                } while (!((int64)((*q).nameid) != (int64)19));;
L929:;
                recordtype = (int64)((*(*p).owner).mode);
                fieldtype = (int64)18;
                offset = (int64)((*q).offset);
            }
            else {
                goto L930;
            }
            if ((var_decls_ngenfielddata >= (int64)1000)) {
                qc_loaderror((byte*)"GENFIELDDATA OVERFLOW",(byte*)"");
            }
            ++var_decls_ngenfielddata;
            var_decls_genfielddata[(var_decls_ngenfielddata)-1].fieldindex = (int32)(i);
            var_decls_genfielddata[(var_decls_ngenfielddata)-1].recordtype = (int32)(recordtype);
            var_decls_genfielddata[(var_decls_ngenfielddata)-1].fieldtype = (int32)(fieldtype);
            var_decls_genfielddata[(var_decls_ngenfielddata)-1].offset = (int32)(offset);
//skip:
L930:;
            p = (*p).nextdupl;
L925:;
        }
L926:;
        var_decls_genfieldnames[(i)-1].datalength = (int32)(((var_decls_ngenfielddata - (int64)(var_decls_genfieldnames[(i)-1].dataindex)) + (int64)1));
L922:;
    }
L923:;
}

static void qc_showoptions(void) {
    int64 i;
puts("");
    printf("%s\n",(char*)((byte*)"Options:"));
    printf("%s\n",(char*)((byte*)"--------"));
    if (!!((qc_passes & (int64)1))) {
        printf("%s\n",(char*)((byte*)"-load"));
    }
    if (!!((qc_passes & (int64)16))) {
        printf("%s\n",(char*)((byte*)"-parse"));
    }
    if (!!((qc_passes & (int64)32))) {
        printf("%s\n",(char*)((byte*)"-gen"));
    }
    if (!!((qc_passes & (int64)64))) {
        printf("%s\n",(char*)((byte*)"-pc"));
    }
    if (!!(qc_fshowoptions)) {
        printf("%s\n",(char*)((byte*)"-options"));
    }
    if (!!(qc_fshowmodules)) {
        printf("%s\n",(char*)((byte*)"-modules"));
    }
    if (!!(qc_fshowast)) {
        printf("%s\n",(char*)((byte*)"-ast"));
    }
    if (!!(qc_fshowst)) {
        printf("%s\n",(char*)((byte*)"-st"));
    }
    if (!!(qc_fshowstflat)) {
        printf("%s\n",(char*)((byte*)"-stflat"));
    }
    if (!!(qc_fshowtypes)) {
        printf("%s\n",(char*)((byte*)"-types"));
    }
    if (!!(qc_fshowfields)) {
        printf("%s\n",(char*)((byte*)"-fields"));
    }
    if (!!(qc_fshowpcl)) {
        printf("%s\n",(char*)((byte*)"-pcl"));
    }
    if (!!(qc_fshowdis)) {
        printf("%s\n",(char*)((byte*)"-dis"));
    }
    if (!!(qc_fshowtiming)) {
        printf("%s\n",(char*)((byte*)"-time"));
    }
    if (!!(qc_fshowlog)) {
        printf("%s\n",(char*)((byte*)"-d"));
    }
    if (!!(qc_fshowlog)) {
        printf("%s\n",(char*)((byte*)"<showlog>"));
    }
puts("");
}

static void qc_showoutput(void) {
    if (!!(qc_fshowmodules)) {
        qc_showmodules();
    }
    if (!!(qc_fshowast)) {
        qc_showast();
    }
    if (!!(qc_fshowst)) {
        qc_showsttree();
    }
    if (!!(qc_fshowstflat)) {
        qc_showstflat((byte*)"FST");
    }
    if (!!(qc_fshowtypes)) {
        qc_lib_printmodelist(var_decls_logdev);
    }
    if (!!(qc_fshowfields)) {
        qc_showgenfields();
    }
    if (!!(qc_fshowtiming)) {
        qc_showtiming();
    }
}

static void qc_showhelp(void) {
    static byte *  helptext = (byte*)"THIS IS THE HELP TEXT";
    printf("%s\n",(char*)(helptext));
    exit(0);
}

int64 qc_nextcmd(int64 * paramno,byte * * name,byte * * value,byte * defext) {
    static int64 infile = (int64)0;
    static byte *  filestart = 0;
    static byte *  fileptr = 0;
    static byte colonnext = (uint8)0u;
    byte *  q;
    byte *  item;
    byte *  fileext;
    int64 length;
    static byte str[300];
    return (int64)0;
}

static void qc_writedocs(void) {
    byte filename[300];
    struct var_decls_strec *  params[50];
    int64 nparams;
    void *  f;
    struct var_decls_strec *  def;
    struct var_decls_strec *  e;
    struct var_decls_procrec *  p;
    int64 i;
    strcpy(filename,var_decls_moduletable[(var_decls_nmodules)].filename);
    strcpy(filename,mlib_changeext(filename,(byte*)".txt"));
    f = fopen(filename,(byte*)"w");
    printf("%s %s\n",(char*)((byte*)"Writing Docstring file"),(char*)(filename));
    p = var_decls_proclist;
L931:;
    while (!!(p)) {
        def = (*p).def;
        if ((!!((*def).docstring) && !(!!((*def).attribs.ax_at)))) {
            e = (*def).deflist;
            nparams = (int64)0;
L934:;
            while (!!(e)) {
                if ((((int64)((*e).nameid) == (int64)12) && ((int64)((*(*e).name)) != (int64)36))) {
                    params[(++nparams)-1] = e;
                }
                e = (*e).nextdef;
L935:;
            }
L936:;
            fprintf(f,"%s\n",(char*)((byte*)"================================================"));
            fprintf(f,"%s",(char*)((((int64)((*def).mode) == (int64)0)?(byte*)"Proc ":(byte*)"Function ")));
            fprintf(f,"%s%s%s%s",(char*)((*(*def).owner).name),(char*)((byte*)"."),(char*)((*def).name),(char*)((byte*)"("));
L937:;
            for (i=nparams;i>=(int64)1;--i) {
L938:;
                e = params[(i)-1];
                if (!!((*e).attribs.ax_byrefmode)) {
                    fprintf(f,"%s",(char*)((byte*)"&"));
                }
                fprintf(f,"%s",(char*)((*e).name));
                if (!!((*e).code)) {
                    fprintf(f,"%s %s",(char*)((byte*)" ="),(char*)((*qc_lib_strexpr((*e).code)).strptr));
                }
                if ((i != (int64)1)) {
                    fprintf(f,"%s",(char*)((byte*)","));
                }
L939:;
            }
L940:;
            fprintf(f,"%s\n",(char*)((byte*)")"));
            fprintf(f,"%s\n",(char*)((byte*)"================================================"));
            fprintf(f,"%s\n",(char*)((*def).docstring));
        }
        p = (*p).nextproc;
L932:;
    }
L933:;
    fclose(f);
}

void qc_support_prterror(byte * mess) {
    printf("%s %s\n",(char*)((byte*)"Print error:"),(char*)(mess));
    osnos_os_getch();
    exit((int64)1);
}

void qc_support_serror(byte * mess) {
    printf("%s %s %s %lld %s\n",(char*)((byte*)"Syntax error:"),(char*)(mess),(char*)((byte*)"on line"),(int64)qc_lex_lx.lineno,(char*)((*var_decls_stmodule).name));
    osnos_os_getch();
puts("");
puts("");
puts("");
puts("");
puts("");
    printf("%s\n",(char*)((byte*)"--"));
    exit((int64)1);
}

void qc_support_gerror(byte * mess,struct var_decls_unitrec * p) {
    int64 lineno;
    if (!!(p)) {
        lineno = (int64)((*p).lineno);
    }
    else {
        lineno = var_decls_mlineno;
    }
    printf("%s %s %s %lld %s\n",(char*)((byte*)"Code gen error:"),(char*)(mess),(char*)((byte*)"on line"),(int64)lineno,(char*)((*var_decls_stmodule).name));
    osnos_os_getch();
    exit((int64)1);
}

void qc_support_nxerror(byte * mess,struct var_decls_unitrec * p) {
    int64 lineno;
    if (!!(p)) {
        lineno = (int64)((*p).lineno);
    }
    else {
        lineno = (int64)0;
    }
    printf("%s %s %s %lld %s\n",(char*)((byte*)"NX error:"),(char*)(mess),(char*)((byte*)"on line"),(int64)lineno,(char*)((*var_decls_stmodule).name));
    osnos_os_getch();
    exit((int64)1);
}

int64 qc_support_testelem(byte (*p)[],int64 n) {
    return (!!(((*p)[((n >> (int64)3))] & qc_support_bytemasks[((n & (int64)7))]))?(int64)1:(int64)0);
}

void qc_support_setelem(byte (*p)[],int64 n) {
    (*p)[((n >> (int64)3))] |= qc_support_bytemasks[((n & (int64)7))];
}

void qc_support_inittypetables(void) {
    int64 i;
    int64 size;
    int64 bitsize;
    int64 av_1;
L941:;
    for (i=(int64)0;i<=(int64)52;++i) {
L942:;
        var_decls_ttname[(i)] = var_types_stdtypenames[(i)];
        var_decls_ttbasetype[(i)] = (int32)(i);
        if ((i==(int64)50) || (i==(int64)51) || (i==(int64)52)) {
            bitsize = (int64)64;
        }
        else {
            bitsize = var_types_stdtypewidths[(i)];
        }
        switch (bitsize) {
        case 0:;
            break;
        case 1:;
        case 2:;
        case 4:;
            size = (int64)1;
            break;
        default:;
            size = (bitsize / (int64)8);
        }
        var_decls_ttsize[(i)] = (int32)(size);
        var_decls_ttbitwidth[(i)] = (int32)(bitsize);
        var_decls_ttlower[(i)] = (int32)1;
L943:;
    }
L944:;
    var_decls_ntypes = (int64)52;
    var_decls_tttarget[((int64)22)] = (int32)35;
}

int64 qc_support_nextpoweroftwo(int64 x) {
    int64 a = (int64)1;
    if ((x == (int64)0)) {
        return (int64)0;
    }
L945:;
    while ((a < x)) {
        a <<= (int64)1;
L946:;
    }
L947:;
    return a;
}

void qc_support_initpcdest(void) {
    qc_support_pcalloc = (int64)16384;
    qc_support_pcstart = (byte *)(mlib_pcm_alloc(qc_support_pcalloc));
    qc_support_pcend = (qc_support_pcstart + qc_support_pcalloc);
    qc_support_pcdest = qc_support_pcstart;
}

int64 qc_support_getpcpos(void) {
    return (qc_support_pcdest - qc_support_pcstart);
}

void qc_support_setpcpos(int64 pos) {
    qc_support_pcdest = (qc_support_pcstart + pos);
}

int64 qc_support_writepcdata(byte * filename) {
    int64 nbytes;
    void *  f;
    f = fopen(filename,(byte*)"wb");
    if ((f == 0)) {
        printf("%s %s\n",(char*)((byte*)"Couldn't create"),(char*)(filename));
        exit((int64)1);
    }
    fwrite((void *)(qc_support_pcstart),(uint64)((qc_support_pcdest - qc_support_pcstart)),(uint64)((int64)1),f);
    fclose(f);
    return (int64)1;
}

void qc_support_writezstring(byte * s) {
    int64 i;
    int64 n;
    int64 av_1;
    qc_support_outpcbyte((int64)254);
    n = (int64)(strlen(s));
    av_1 = n;
    while (av_1-- > 0) {
L948:;
        qc_support_outpcbyte((int64)((*s++)));
L949:;
    }
L950:;
    qc_support_outpcbyte((int64)0);
}

void qc_support_writezblock(byte * s,int64 length) {
    int64 i;
    int64 av_1;
    av_1 = length;
    while (av_1-- > 0) {
L951:;
        qc_support_outpcbyte((int64)((*s++)));
L952:;
    }
L953:;
}

void qc_support_writezint(int64 x) {
    byte *  p;
    int64 av_1;
    if (((x >= (int64)0) && (x <= (int64)239))    ) {
        qc_support_outpcbyte(x);
    }
    else if (((x >= (int64)240) && (x < (int64)480))) {
        qc_support_outpcbyte((int64)245);
        qc_support_outpcbyte((x - (int64)240));
    }
    else if (((x >= (int64)480) && (x < (int64)720))) {
        qc_support_outpcbyte((int64)246);
        qc_support_outpcbyte((x - (int64)480));
    }
    else if (((x >= (int64)720) && (x < (int64)960))) {
        qc_support_outpcbyte((int64)247);
        qc_support_outpcbyte((x - (int64)720));
    }
    else if (((x >= (int64)-127) && (x < (int64)0))) {
        qc_support_outpcbyte((int64)248);
        qc_support_outpcbyte(-(x));
    }
    else if (((x >= (int64)-32768) && (x <= (int64)32767))) {
        qc_support_outpcbyte((int64)249);
        qc_support_outpcword16(x);
    }
    else if (((x > (int64)-2147483648) && (x <= (int64)2147483647))) {
        qc_support_outpcbyte((int64)250);
        qc_support_outpcword(x);
    }
    else {
        p = (byte *)(&x);
        qc_support_outpcbyte((int64)251);
        av_1 = (int64)8;
        while (av_1-- > 0) {
L954:;
            qc_support_outpcbyte((int64)((*p++)));
L955:;
        }
L956:;
    }
}

void qc_support_writezint4(int64 x) {
    qc_support_outpcbyte((int64)250);
    qc_support_outpcword(x);
}

void qc_support_writezrange(byte * p) {
    int64 av_1;
    qc_support_outpcbyte((int64)251);
    av_1 = (int64)8;
    while (av_1-- > 0) {
L957:;
        qc_support_outpcbyte((int64)((*p++)));
L958:;
    }
L959:;
}

void qc_support_writezreal(double x) {
    byte *  p;
    int64 *  q;
    int64 av_1;
    int64 av_2;
    p = (byte *)(&x);
    q = (int64 *)(&x);
    if ((q != 0)) {
        qc_support_outpcbyte((int64)253);
        av_1 = (int64)8;
        while (av_1-- > 0) {
L960:;
            qc_support_outpcbyte((int64)((*p++)));
L961:;
        }
L962:;
    }
    else {
        qc_support_outpcbyte((int64)252);
        p += (int64)4;
        av_2 = (int64)4;
        while (av_2-- > 0) {
L963:;
            qc_support_outpcbyte((int64)((*p++)));
L964:;
        }
L965:;
    }
}

void qc_support_writezeof(void) {
    qc_support_outpcbyte((int64)255);
}

int64 qc_support_ipower(int64 a,int64 n) {
    if ((n <= (int64)0)    ) {
        return (int64)0;
    }
    else if ((n == (int64)0)) {
        return (int64)1;
    }
    else if ((n == (int64)1)) {
        return a;
    }
    else if (((n & (int64)1) == (int64)0)) {
        return qc_support_ipower((a * a),(n / (int64)2));
    }
    else {
        return (a * qc_support_ipower((a * a),((n - (int64)1) / (int64)2)));
    }
}

void qc_support_gs_additem(struct mlib_strbuffer * dest,byte * s) {
    byte *  d;
    int64 lastchar;
    int64 nextchar;
    d = (*dest).strptr;
    if (!!((*dest).length)) {
        lastchar = (int64)((*((d + (int64)((*dest).length)) - (int64)1)));
        nextchar = (int64)((*s));
        if ((!!(qc_support_isalphanum(lastchar)) && !!(qc_support_isalphanum(nextchar)))) {
            mlib_strbuffer_add(dest,(byte*)" ",(int64)-1);
        }
    }
    mlib_strbuffer_add(dest,s,(int64)-1);
}

static int64 qc_support_isalphanum(int64 c) {
    if (((((c >= (int64)65) && (c <= (int64)90)) || ((c >= (int64)97) && (c <= (int64)122))) || ((c >= (int64)48) && (c <= (int64)57)))) {
        return (int64)1;
    }
    return (int64)0;
}

static void qc_support_gs_copytostr(struct mlib_strbuffer * source,byte * s) {
    if (!!((*source).length)) {
        memcpy((void *)(s),(void *)((*source).strptr),(uint64)((*source).length));
        (*(s + (int64)((*source).length))) = (uint8)0u;
    }
    else {
        (*s) = (uint8)0u;
    }
}

static void qc_support_outpcbyte(int64 x) {
    int64 newalloc;
    int64 oldbytes;
    byte *  pcnew;
    if ((qc_support_pcdest >= qc_support_pcend)) {
        newalloc = (qc_support_pcalloc * (int64)2);
        pcnew = (byte *)(mlib_pcm_alloc(newalloc));
        oldbytes = (qc_support_pcdest - qc_support_pcstart);
        memcpy((void *)(pcnew),(void *)(qc_support_pcstart),(uint64)(oldbytes));
        qc_support_pcstart = pcnew;
        qc_support_pcend = (qc_support_pcstart + newalloc);
        qc_support_pcdest = (qc_support_pcstart + oldbytes);
        qc_support_pcalloc = newalloc;
    }
    (*qc_support_pcdest++) = (byte)(x);
}

static void qc_support_outpcword(int64 x) {
    byte *  p = (byte *)(&x);
    qc_support_outpcbyte((int64)((*p++)));
    qc_support_outpcbyte((int64)((*p++)));
    qc_support_outpcbyte((int64)((*p++)));
    qc_support_outpcbyte((int64)((*p)));
}

static void qc_support_outpcword16(int64 x) {
    byte *  p = (byte *)(&x);
    qc_support_outpcbyte((int64)((*p++)));
    qc_support_outpcbyte((int64)((*p)));
}

void qc_lex_lexreadtoken(void) {
    int64 c;
    int64 csum;
    int64 hsum;
    int64 commentseen;
    byte *  pstart;
    byte *  pnext;
    byte *  p;
    if (!!(var_decls_debug)) {
        printf("%s\n",(char*)((byte*)"/LEXREADTOKEN"));
    }
    qc_lex_nextlx.subcode = (int64)0;
L966:;
    switch ((int64)((*qc_lex_lxsptr++))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
        qc_lex_nextlx.svalue = (qc_lex_lxsptr - (int64)1);
//doname:
L968:;
        hsum = (csum = (int64)((*qc_lex_nextlx.svalue)));
        qc_lex_nextlx.hashvalue = (int64)0;
L969:;
        switch ((c = (int64)((*qc_lex_lxsptr++)))) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
            c += (int64)32;
            (*(qc_lex_lxsptr - (int64)1)) = (byte)(c);
            csum += c;
            hsum = ((hsum << (int64)3) + csum);
            break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 95:;
        case 36:;
            csum += c;
            hsum = ((hsum << (int64)3) + csum);
            break;
        case 34:;
            --qc_lex_lxsptr;
            if ((((qc_lex_nextlx.svalue + (int64)1) == qc_lex_lxsptr) && (((int64)((*qc_lex_nextlx.svalue)) == (int64)70) || ((int64)((*qc_lex_nextlx.svalue)) == (int64)102)))) {
                qc_lex_readrawstring();
                return;
            }
            goto L970;
            break;
        default:;
            --qc_lex_lxsptr;
            goto L970;
        }
        goto L969;
L970:;
        qc_lex_nextlx.symbol = (int64)34;
        qc_lex_nextlx.length = (qc_lex_lxsptr - qc_lex_nextlx.svalue);
        qc_lex_nextlx.hashvalue = ((hsum << (int64)5) ^ csum);
        return;
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
        qc_lex_nextlx.svalue = (qc_lex_lxsptr - (int64)1);
        (*qc_lex_nextlx.svalue) += (uint8)32u;
        goto L968;
        break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        c = (int64)((*(qc_lex_lxsptr - (int64)1)));
        if (((int64)((*qc_lex_lxsptr))==(int64)32) || ((int64)((*qc_lex_lxsptr))==(int64)41) || ((int64)((*qc_lex_lxsptr))==(int64)13) || ((int64)((*qc_lex_lxsptr))==(int64)44) || ((int64)((*qc_lex_lxsptr))==(int64)124)) {
            qc_lex_nextlx.symbol = (int64)37;
            qc_lex_nextlx.subcode = (int64)1;
            qc_lex_nextlx.value = (c - (int64)48);
        } else if (((int64)((*qc_lex_lxsptr))==(int64)120) || ((int64)((*qc_lex_lxsptr))==(int64)88)) {
            if ((c==(int64)48)) {
                ++qc_lex_lxsptr;
                qc_lex_readnumber((int64)16);
            } else if ((c==(int64)49)) {
                qc_lex_lxerror((byte*)"Bad base");
            }
            else {
                ++qc_lex_lxsptr;
                qc_lex_readnumber((c - (int64)48));
            }
        }
        else {
            --qc_lex_lxsptr;
            qc_lex_readnumber((int64)10);
        }
        return;
        break;
    case 33:;
//docomment:
L971:;
L972:;
        switch ((c = (int64)((*qc_lex_lxsptr++)))) {
        case 13:;
            ++qc_lex_lxsptr;
            goto L973;
            break;
        case 10:;
            goto L973;
            break;
        case 26:;
        case 0:;
            --qc_lex_lxsptr;
            goto L973;
            break;
        default:;
        }
        goto L972;
L973:;
        ++qc_lex_nextlx.lineno;
        qc_lex_nextlx.symbol = (int64)32;
        return;
        break;
    case 35:;
        qc_lex_nextlx.svalue = qc_lex_lxsptr;
L974:;
        switch ((c = (int64)((*qc_lex_lxsptr++)))) {
        case 13:;
        case 10:;
        case 26:;
        case 0:;
            --qc_lex_lxsptr;
            goto L975;
            break;
        default:;
        }
        goto L974;
L975:;
        qc_lex_nextlx.length = (qc_lex_lxsptr - qc_lex_nextlx.svalue);
        qc_lex_nextlx.symbol = (int64)35;
        return;
        break;
    case 92:;
        commentseen = (int64)0;
L976:;
        switch ((int64)((*qc_lex_lxsptr++))) {
        case 13:;
            ++qc_lex_nextlx.lineno;
            ++qc_lex_lxsptr;
            goto L977;
            break;
        case 10:;
            ++qc_lex_nextlx.lineno;
            goto L977;
            break;
        case 26:;
        case 0:;
            qc_lex_nextlx.symbol = (int64)33;
            --qc_lex_lxsptr;
            return;
            break;
        case 32:;
        case 9:;
            break;
        case 33:;
            commentseen = (int64)1;
            break;
        default:;
            if (!(!!(commentseen))) {
                qc_lex_lxerror((byte*)"\\ not followed by eol");
            }
        }
        goto L976;
L977:;
L978:;
        switch ((int64)((*qc_lex_lxsptr++))) {
        case 13:;
            ++qc_lex_nextlx.lineno;
            ++qc_lex_lxsptr;
            break;
        case 10:;
            ++qc_lex_nextlx.lineno;
            break;
        case 32:;
        case 9:;
            break;
        default:;
            --qc_lex_lxsptr;
            goto L979;
        }
        goto L978;
L979:;
        break;
    case 123:;
        qc_lex_nextlx.symbol = (int64)16;
        return;
        break;
    case 125:;
        qc_lex_nextlx.symbol = (int64)17;
        return;
        break;
    case 46:;
        switch ((int64)((*qc_lex_lxsptr))) {
        case 46:;
            ++qc_lex_lxsptr;
            if (((int64)((*qc_lex_lxsptr)) == (int64)46)) {
                ++qc_lex_lxsptr;
                qc_lex_nextlx.symbol = (int64)30;
            }
            else {
                qc_lex_nextlx.symbol = (int64)29;
                qc_lex_nextlx.subcode = (int64)80;
            }
            return;
            break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            --qc_lex_lxsptr;
            qc_lex_readrealnumber((byte *)(0),(int64)0,(int64)10);
            return;
            break;
        default:;
            p = (qc_lex_lxsptr - (int64)2);
            if ((((p < qc_lex_lxstart) || ((int64)((*p)) == (int64)13)) || ((int64)((*p)) == (int64)10))) {
                qc_lex_nextlx.symbol = (int64)3;
            }
            else {
                qc_lex_nextlx.symbol = (int64)2;
            }
            return;
        }
        break;
    case 44:;
        qc_lex_nextlx.symbol = (int64)5;
        return;
        break;
    case 59:;
        qc_lex_nextlx.symbol = (int64)6;
        return;
        break;
    case 58:;
        switch ((int64)((*qc_lex_lxsptr))) {
        case 61:;
            ++qc_lex_lxsptr;
            if (((int64)((*qc_lex_lxsptr))==(int64)61)) {
                ++qc_lex_lxsptr;
                qc_lex_nextlx.symbol = (int64)10;
                qc_lex_nextlx.subcode = (int64)87;
            }
            else {
                qc_lex_nextlx.symbol = (int64)9;
                qc_lex_nextlx.subcode = (int64)86;
            }
            break;
        case 58:;
            ++qc_lex_lxsptr;
            if (((int64)((*qc_lex_lxsptr))==(int64)61)) {
                ++qc_lex_lxsptr;
                qc_lex_nextlx.symbol = (int64)10;
                qc_lex_nextlx.subcode = (int64)87;
            }
            else {
                qc_lex_nextlx.symbol = (int64)8;
            }
            break;
        default:;
            qc_lex_nextlx.symbol = (int64)7;
        }
        return;
        break;
    case 40:;
        qc_lex_nextlx.symbol = (int64)12;
        return;
        break;
    case 41:;
        qc_lex_nextlx.symbol = (int64)13;
        return;
        break;
    case 91:;
        qc_lex_nextlx.symbol = (int64)14;
        return;
        break;
    case 93:;
        qc_lex_nextlx.symbol = (int64)15;
        return;
        break;
    case 124:;
        if (((int64)((*qc_lex_lxsptr)) == (int64)124)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64)20;
        }
        else {
            qc_lex_nextlx.symbol = (int64)19;
        }
        return;
        break;
    case 94:;
        qc_lex_nextlx.symbol = (int64)18;
        qc_lex_nextlx.subcode = (int64)145;
        return;
        break;
    case 64:;
        if (((int64)((*qc_lex_lxsptr)) == (int64)64)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64)22;
        }
        else {
            qc_lex_nextlx.symbol = (int64)21;
        }
        return;
        break;
    case 63:;
        qc_lex_nextlx.symbol = (int64)23;
        return;
        break;
    case 178:;
        printf("%s\n",(char*)((byte*)"SUPERSCRIPT 2"));
        qc_lex_nextlx.symbol = (int64)31;
        qc_lex_nextlx.subcode = (int64)160;
        return;
        break;
    case 126:;
        qc_lex_nextlx.symbol = (int64)27;
        return;
        break;
    case 43:;
        qc_lex_nextlx.symbol = (int64)31;
        if (((int64)((*qc_lex_lxsptr)) == (int64)43)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64)36;
            qc_lex_nextlx.subcode = (int64)207;
            return;
        }
        else {
            qc_lex_nextlx.subcode = (int64)103;
        }
        return;
        break;
    case 45:;
        qc_lex_nextlx.symbol = (int64)31;
        if (((int64)((*qc_lex_lxsptr)) == (int64)45)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64)36;
            qc_lex_nextlx.subcode = (int64)208;
            return;
        }
        else {
            qc_lex_nextlx.subcode = (int64)104;
        }
        return;
        break;
    case 42:;
        qc_lex_nextlx.symbol = (int64)31;
        if (((int64)((*qc_lex_lxsptr)) == (int64)42)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64)143;
        }
        else {
            qc_lex_nextlx.subcode = (int64)105;
        }
        return;
        break;
    case 47:;
        qc_lex_nextlx.symbol = (int64)31;
        if (((int64)((*qc_lex_lxsptr))==(int64)47)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64)109;
        }
        else {
            qc_lex_nextlx.subcode = (int64)106;
        }
        return;
        break;
    case 37:;
        qc_lex_nextlx.symbol = (int64)31;
        qc_lex_nextlx.subcode = (int64)107;
        return;
        break;
    case 61:;
        if (((int64)((*qc_lex_lxsptr))==(int64)62)) {
            qc_lex_nextlx.symbol = (int64)11;
            ++qc_lex_lxsptr;
        } else if (((int64)((*qc_lex_lxsptr))==(int64)61)) {
            qc_lex_nextlx.symbol = (int64)31;
            qc_lex_nextlx.subcode = (int64)102;
            ++qc_lex_lxsptr;
        }
        else {
            qc_lex_nextlx.symbol = (int64)31;
            qc_lex_nextlx.subcode = (int64)96;
        }
        return;
        break;
    case 60:;
        qc_lex_nextlx.symbol = (int64)31;
        switch ((int64)((*qc_lex_lxsptr))) {
        case 61:;
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64)99;
            break;
        case 62:;
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64)97;
            break;
        case 60:;
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64)115;
            break;
        default:;
            qc_lex_nextlx.subcode = (int64)98;
        }
        return;
        break;
    case 62:;
        qc_lex_nextlx.symbol = (int64)31;
        switch ((int64)((*qc_lex_lxsptr))) {
        case 61:;
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64)101;
            break;
        case 62:;
            ++qc_lex_lxsptr;
            qc_lex_nextlx.subcode = (int64)116;
            break;
        default:;
            qc_lex_nextlx.subcode = (int64)100;
        }
        return;
        break;
    case 38:;
        if (((int64)((*qc_lex_lxsptr))==(int64)38)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64)31;
            qc_lex_nextlx.subcode = (int64)95;
        } else if (((int64)((*qc_lex_lxsptr))==(int64)46)) {
            ++qc_lex_lxsptr;
            qc_lex_nextlx.symbol = (int64)4;
            qc_lex_nextlx.subcode = (int64)0;
        }
        else {
            qc_lex_nextlx.symbol = (int64)24;
            qc_lex_nextlx.subcode = (int64)146;
        }
        return;
        break;
    case 39:;
    case 96:;
        qc_lex_lxreadstring((int64)39);
        return;
        break;
    case 34:;
        qc_lex_lxreadstring((int64)34);
        return;
        break;
    case 32:;
    case 9:;
        break;
    case 13:;
        ++qc_lex_lxsptr;
        ++qc_lex_nextlx.lineno;
        qc_lex_nextlx.symbol = (int64)32;
        return;
        break;
    case 10:;
        ++qc_lex_nextlx.lineno;
        qc_lex_nextlx.symbol = (int64)32;
        return;
        break;
    case 26:;
    case 0:;
        if (!!(qc_lex_macrolevel)) {
            qc_lex_unstackmacro();
        }
        else {
            qc_lex_nextlx.symbol = (int64)33;
            --qc_lex_lxsptr;
            return;
        }
        break;
    default:;
        qc_lex_nextlx.symbol = (int64)1;
        qc_lex_nextlx.value = c;
        return;
    }
    goto L966;
L967:;
}

static void qc_lex_lxreadstring(int64 termchar) {
    byte *  dest;
    int64 c;
    int64 d;
    int64 av_1;
    if ((termchar == (int64)34)) {
        qc_lex_nextlx.symbol = (int64)42;
        qc_lex_nextlx.subcode = (int64)5;
    }
    else {
        qc_lex_nextlx.symbol = (int64)40;
        qc_lex_nextlx.subcode = (int64)1;
    }
    qc_lex_nextlx.svalue = qc_lex_lxsptr;
    dest = qc_lex_lxsptr;
L980:;
    while (1) {
        switch ((c = (int64)((*qc_lex_lxsptr++)))) {
        case 92:;
            c = (int64)((*qc_lex_lxsptr));
            if (((c >= (int64)65) && (c <= (int64)90))) {
                c += (int64)32;
            }
            ++qc_lex_lxsptr;
            switch (c) {
            case 97:;
                c = (int64)7;
                break;
            case 98:;
                c = (int64)8;
                break;
            case 99:;
            case 114:;
                c = (int64)13;
                break;
            case 101:;
                c = (int64)26;
                break;
            case 102:;
                c = (int64)12;
                break;
            case 108:;
            case 110:;
                c = (int64)10;
                break;
            case 115:;
                c = (int64)27;
                break;
            case 116:;
                c = (int64)9;
                break;
            case 118:;
                c = (int64)11;
                break;
            case 119:;
                (*dest++) = (uint8)13u;
                c = (int64)10;
                break;
            case 120:;
                c = (int64)0;
                av_1 = (int64)2;
                while (av_1-- > 0) {
L982:;
                    if (((d = (int64)((*qc_lex_lxsptr++)))==(int64)65) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)66) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)67) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)68) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)69) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)70)) {
                        c = ((((c * (int64)16) + d) - (int64)65) + (int64)10);
                    } else if (((d = (int64)((*qc_lex_lxsptr++)))==(int64)97) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)98) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)99) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)100) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)101) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)102)) {
                        c = ((((c * (int64)16) + d) - (int64)97) + (int64)10);
                    } else if (((d = (int64)((*qc_lex_lxsptr++)))==(int64)48) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)49) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)50) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)51) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)52) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)53) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)54) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)55) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)56) || ((d = (int64)((*qc_lex_lxsptr++)))==(int64)57)) {
                        c = (((c * (int64)16) + d) - (int64)48);
                    }
                    else {
                        qc_lex_lxerror((byte*)"Bad \\x code");
                    }
L983:;
                }
L984:;
                break;
            case 121:;
                c = (int64)16;
                break;
            case 122:;
            case 48:;
                c = (int64)0;
                break;
            case 34:;
            case 81:;
                c = (int64)34;
                break;
            case 92:;
                c = (int64)92;
                break;
            case 39:;
                c = (int64)39;
                break;
            default:;
                printf("%lld %u %s %lld\n",(int64)c,(byte)(c),(char*)((byte*)"NEXTLX.LINENO="),(int64)qc_lex_nextlx.lineno);
                qc_lex_lxerror((byte*)"Unknown string escape");
            }
            break;
        case 34:;
        case 39:;
            if ((c == termchar)) {
                if (((int64)((*qc_lex_lxsptr)) == c)) {
                    ++qc_lex_lxsptr;
                }
                else {
                    goto L981;
                }
            }
            break;
        case 13:;
        case 10:;
        case 26:;
        case 0:;
            printf("%s %lld\n",(char*)((byte*)"NEXTLX.LINENO="),(int64)qc_lex_nextlx.lineno);
            qc_lex_lxerror((byte*)"String not terminated");
            break;
        default:;
        }
        (*dest++) = (byte)(c);
    }
L981:;
    qc_lex_nextlx.length = (dest - qc_lex_nextlx.svalue);
    (*(qc_lex_nextlx.svalue + qc_lex_nextlx.length)) = (uint8)0u;
}

static void qc_lex_readnumber(int64 base) {
    byte *  pstart;
    byte *  dest;
    int64 numtype;
    int64 c;
    byte *  p;
    dest = (pstart = qc_lex_lxsptr);
    if ((base == (int64)10)) {
L985:;
        switch ((c = (int64)((*qc_lex_lxsptr++)))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
            (*dest++) = (byte)(c);
            break;
        case 95:;
        case 39:;
        case 96:;
            break;
        default:;
            --qc_lex_lxsptr;
            goto L986;
        }
        goto L985;
L986:;
    }
    else {
        dest = qc_lex_scannumber(base);
        c = (int64)((*qc_lex_lxsptr));
    }
    numtype = (int64)0;
    switch (c) {
    case 46:;
        if (((int64)((*(qc_lex_lxsptr + (int64)1))) != (int64)46)) {
            qc_lex_readrealnumber(pstart,(dest - pstart),base);
            return;
        }
        break;
    case 101:;
    case 69:;
        if ((base <= (int64)10)) {
            qc_lex_readrealnumber(pstart,(dest - pstart),base);
            return;
        }
        break;
    case 112:;
    case 80:;
        if ((base == (int64)16)) {
            qc_lex_readrealnumber(pstart,(dest - pstart),base);
            return;
        }
        break;
    case 105:;
    case 73:;
        ++qc_lex_lxsptr;
        numtype = (int64)1;
        break;
    case 119:;
    case 87:;
    case 117:;
    case 85:;
        ++qc_lex_lxsptr;
        numtype = (int64)2;
        break;
    case 76:;
    case 108:;
        ++qc_lex_lxsptr;
        numtype = (int64)7;
        break;
    default:;
    }
    qc_lex_stringtonumber(pstart,(dest - pstart),base,numtype);
}

static void qc_lex_readrealnumber(byte * intstart,int64 intlen,int64 base) {
    byte *  fractstart;
    int64 fractlen;
    int64 expon;
    int64 i;
    int64 c;
    double basex;
    double x;
    byte realstr[500];
    int64 av_1;
    int64 av_2;
    int64 av_3;
    fractstart = (byte *)(0);
    fractlen = (int64)0;
    expon = (int64)0;
    if (((int64)((*qc_lex_lxsptr)) == (int64)46)) {
        fractstart = ++qc_lex_lxsptr;
        fractlen = (qc_lex_scannumber(base) - fractstart);
    }
    if (((int64)((*qc_lex_lxsptr))==(int64)101) || ((int64)((*qc_lex_lxsptr))==(int64)69)) {
        if ((base != (int64)16)) {
            ++qc_lex_lxsptr;
            expon = qc_lex_readexponent(base);
        }
    } else if (((int64)((*qc_lex_lxsptr))==(int64)112) || ((int64)((*qc_lex_lxsptr))==(int64)80)) {
        if ((base == (int64)16)) {
            ++qc_lex_lxsptr;
            expon = qc_lex_readexponent(base);
        }
    }
    if (((intlen + fractlen) > (int64)500)) {
        qc_lex_lxerror((byte*)"Real too long");
    }
    if (!!(intlen)) {
        memcpy((void *)(&realstr),(void *)(intstart),(uint64)(intlen));
    }
    if (!!(fractlen)) {
        memcpy((void *)((&realstr[((int64)1)-1] + intlen)),(void *)(fractstart),(uint64)(fractlen));
    }
    basex = (double)(base);
    expon -= fractlen;
    x = (float)0.000000;
L987:;
    for (i=(int64)1;i<=(intlen + fractlen);++i) {
L988:;
        c = (int64)(realstr[(i)-1]);
        if (((c >= (int64)48) && (c <= (int64)57))        ) {
            x = (((x * basex) + (double)(c)) - (float)48.000000);
        }
        else if ((c > (int64)97)) {
            x = ((((x * basex) + (double)(c)) - (float)97.000000) + (float)10.000000);
        }
        else {
            x = ((((x * basex) + (double)(c)) - (float)65.000000) + (float)10.000000);
        }
L989:;
    }
L990:;
    if ((expon >= (int64)0)) {
        av_2 = expon;
        while (av_2-- > 0) {
L991:;
            x *= basex;
L992:;
        }
L993:;
    }
    else {
        av_3 = -(expon);
        while (av_3-- > 0) {
L994:;
            x /= basex;
L995:;
        }
L996:;
    }
    qc_lex_nextlx.symbol = (int64)39;
    qc_lex_nextlx.subcode = (int64)3;
    qc_lex_nextlx.xvalue = x;
}

static int64 qc_lex_readexponent(int64 base) {
    byte *  numstart;
    byte *  numend;
    int64 expon;
    int64 length;
    int64 neg;
    neg = (int64)0;
    if (((int64)((*qc_lex_lxsptr))==(int64)43)) {
        ++qc_lex_lxsptr;
    } else if (((int64)((*qc_lex_lxsptr))==(int64)45)) {
        ++qc_lex_lxsptr;
        neg = (int64)1;
    }
    numstart = qc_lex_lxsptr;
    length = (qc_lex_scannumber(base) - numstart);
    if ((length == (int64)0)) {
        qc_lex_lxerror((byte*)"Bad expon");
    }
    qc_lex_stringtonumber(numstart,length,base,(int64)0);
    return (!!(neg)?-(qc_lex_nextlx.value):qc_lex_nextlx.value);
}

static void qc_lex_lxerror(byte * mess) {
    printf("%lld %s %s %s %s\n",(int64)qc_lex_nextlx.lineno,(char*)((byte*)"LEX ERROR"),(char*)(mess),(char*)((byte*)"in"),(char*)((*var_decls_stmodule).name));
    mlib_abortprogram((byte*)"Stopping");
}

void qc_lex_printsymbol(struct qc_lex_lexrec * lp) {
    struct qc_lex_lexrec l;
    memcpy(&l,lp,56);
    printf((byte*)"%-18s",qc_tables_symbolnames[(l.symbol)-1]);
    if ((l.symbol==(int64)34)) {
        qc_lex_printstrn(l.svalue,l.length);
        printf("%s%lld%s",(char*)((byte*)" ("),(int64)l.hashvalue,(char*)((byte*)")"));
    } else if ((l.symbol==(int64)45)) {
        qc_lex_printstrn((*l.symptr).name,(int64)((*l.symptr).namelen));
    } else if ((l.symbol==(int64)37)) {
        if ((l.subcode==(int64)1)) {
            printf("%lld %s",(int64)l.value,(char*)((byte*)"int"));
        } else if ((l.subcode==(int64)2)) {
            printf("%llu %s",(uint64)l.uvalue,(char*)((byte*)"word"));
        }
        else {
            printf("%lld",(int64)l.value);
        }
    } else if ((l.symbol==(int64)39)) {
        printf("%f",l.xvalue);
    } else if ((l.symbol==(int64)42)) {
        printf("%s",(char*)((byte*)"\""));
        qc_lex_printstrn(l.svalue,l.length);
        printf("%s",(char*)((byte*)"\""));
    } else if ((l.symbol==(int64)40)) {
        printf("%s",(char*)((byte*)"'"));
        qc_lex_printstrn(l.svalue,l.length);
        printf("%s",(char*)((byte*)"'"));
    } else if ((l.symbol==(int64)38)) {
        qc_lex_printstrn(l.svalue,l.length);
        printf("%s",(char*)((byte*)"L"));
    } else if ((l.symbol==(int64)31) || (l.symbol==(int64)9) || (l.symbol==(int64)24) || (l.symbol==(int64)18) || (l.symbol==(int64)10) || (l.symbol==(int64)29)) {
        printf("%s",(char*)(qc_tables_jtagnames[(l.subcode)]));
    }
    else {
        if (!!(l.subcode)) {
            printf("%s %lld",(char*)((byte*)"#"),(int64)l.subcode);
        }
    }
puts("");
}

static void qc_lex_stringtonumber(byte * s,int64 length,int64 base,int64 numtype) {
    int64 a;
    uint64 b;
    int64 c;
    byte *  t;
    int64 av_1;
    int64 av_2;
L997:;
    while (((length >= (int64)2) && ((int64)((*s)) == (int64)48))) {
        ++s;
        --length;
L998:;
    }
L999:;
    if ((((numtype == (int64)7) || (length > qc_lex_maxnumlen[(base)-1])) || ((length == qc_lex_maxnumlen[(base)-1]) && (mlib_cmpstringn(s,qc_lex_maxnumlist[(base)-1],length) > (int64)0)))) {
        qc_lex_nextlx.symbol = (int64)38;
        qc_lex_nextlx.svalue = s;
        qc_lex_nextlx.length = length;
        switch (base) {
        case 10:;
            break;
        case 16:;
            t = (byte *)(mlib_pcm_alloc((((int64)2 + length) + (int64)1)));
            strcpy(t,(byte*)"0x");
            strcat(t,s);
            qc_lex_nextlx.svalue = t;
            qc_lex_nextlx.length += (int64)2;
            break;
        case 2:;
        case 3:;
        case 4:;
        case 5:;
        case 6:;
        case 7:;
        case 8:;
        case 9:;
            t = (byte *)(mlib_pcm_alloc((((int64)2 + length) + (int64)1)));
            qc_lex_nextlx.svalue = t;
            (*t++) = (byte)((base + (int64)48));
            (*t++) = (uint8)120u;
            strcat(t,s);
            qc_lex_nextlx.length += (int64)2;
            break;
        default:;
            qc_lex_lxerror((byte*)"longint/base?");
        }
        if ((!!(numtype) && (numtype != (int64)7))) {
            qc_lex_lxerror((byte*)"Can't apply width override to longint");
        }
        return;
    }
    a = (int64)0;
    if ((base <= (int64)10)) {
        av_1 = length;
        while (av_1-- > 0) {
L1000:;
            a = (((a * base) + (int64)((*s++))) - (int64)48);
L1001:;
        }
L1002:;
    }
    else {
        av_2 = length;
        while (av_2-- > 0) {
L1003:;
            c = (int64)((*s++));
            if ((c >= (int64)97)            ) {
                a = ((((a * base) + c) - (int64)97) + (int64)10);
            }
            else if ((c >= (int64)65)) {
                a = ((((a * base) + c) - (int64)65) + (int64)10);
            }
            else {
                a = (((a * base) + c) - (int64)48);
            }
L1004:;
        }
L1005:;
    }
    qc_lex_nextlx.symbol = (int64)37;
    qc_lex_nextlx.value = a;
    if (!!(numtype)) {
        qc_lex_nextlx.subcode = numtype;
        return;
    }
    b = (uint64)(a);
    if ((b < (uint64)9223372036854775807u)) {
        qc_lex_nextlx.subcode = (int64)1;
    }
    else {
        qc_lex_nextlx.subcode = (int64)2;
    }
}

void qc_lex_lexsetup(void) {
    int64 i;
    static int64 n;
    int64 av_1;
L1006:;
    for (i=(int64)1;i<=(int64)16;++i) {
L1007:;
        qc_lex_maxnumlen[(i)-1] = (int64)(strlen(qc_lex_maxnumlist[(i)-1]));
L1008:;
    }
L1009:;
    qc_lex_inithashtable();
    n = (int64)0;
L1010:;
    for (i=(int64)0;i<=(int64)131071;++i) {
L1011:;
        if (!!(qc_lex_hashtable[(i)].name)) {
            ++n;
        }
L1012:;
    }
L1013:;
}

void qc_lex_printstrn(byte * s,int64 length) {
    if (!!(length)) {
        printf((byte*)"%.*s",length,s);
    }
}

static byte * qc_lex_scannumber(int64 base) {
    byte *  dest;
    int64 c;
    dest = qc_lex_lxsptr;
L1014:;
    switch ((c = (int64)((*qc_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
        (*dest++) = (byte)(c);
        if ((c >= ((int64)48 + base))) {
            qc_lex_lxerror((byte*)"Digit out of range");
        }
        break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
        if ((base == (int64)16)) {
            (*dest++) = (byte)(c);
        }
        else {
            --qc_lex_lxsptr;
            goto L1015;
        }
        break;
    case 95:;
    case 39:;
    case 96:;
        break;
    default:;
        --qc_lex_lxsptr;
        goto L1015;
    }
    goto L1014;
L1015:;
    return dest;
}

static void qc_lex_readrawstring(void) {
    byte *  dest;
    int64 c;
    qc_lex_nextlx.symbol = (int64)42;
    qc_lex_nextlx.subcode = (int64)5;
    qc_lex_nextlx.svalue = ++qc_lex_lxsptr;
    dest = qc_lex_lxsptr;
L1016:;
    switch ((c = (int64)((*qc_lex_lxsptr++)))) {
    case 34:;
        if (((int64)((*qc_lex_lxsptr)) == (int64)34)) {
            (*dest++) = (uint8)34u;
            ++qc_lex_lxsptr;
        }
        else {
            (*(qc_lex_lxsptr - (int64)1)) = (uint8)0u;
            goto L1017;
        }
        break;
    case 13:;
    case 10:;
    case 26:;
    case 0:;
        qc_lex_lxerror((byte*)"Raw string not terminated");
        --qc_lex_lxsptr;
        goto L1017;
        break;
    default:;
        (*dest++) = (byte)(c);
    }
    goto L1016;
L1017:;
    qc_lex_nextlx.length = (dest - qc_lex_nextlx.svalue);
}

static int64 qc_lex_lookup(void) {
    int64 j;
    int64 wrapped;
    ++var_decls_nlookups;
    j = (qc_lex_nextlx.hashvalue & (int64)131071);
    qc_lex_lxsymptr = &qc_lex_hashtable[(j)];
    wrapped = (int64)0;
L1018:;
    while (1) {
        if (((*qc_lex_lxsymptr).name == 0)) {
            goto L1019;
        }
        if (((int64)((*qc_lex_lxsymptr).namelen) == qc_lex_nextlx.length)) {
            if (((int64)(memcmp((void *)((*qc_lex_lxsymptr).name),(void *)(qc_lex_nextlx.svalue),(uint64)(qc_lex_nextlx.length))) == (int64)0)) {
                return (int64)1;
            }
        }
        ++var_decls_nclashes;
        ++qc_lex_lxsymptr;
        if ((++j >= (int64)131072)) {
            if (!!(wrapped)) {
                mlib_abortprogram((byte*)"HASHTABLE FULL");
            }
            wrapped = (int64)1;
            qc_lex_lxsymptr = &qc_lex_hashtable[((int64)0)];
            j = (int64)0;
        }
    }
L1019:;
    (*qc_lex_lxsymptr).name = qc_lex_nextlx.svalue;
    (*qc_lex_lxsymptr).namelen = (byte)(qc_lex_nextlx.length);
    (*qc_lex_lxsymptr).symbol = (uint8)34u;
    return (int64)0;
}

static int64 qc_lex_gethashvaluez(byte * s) {
    int64 c;
    int64 csum;
    int64 hsum;
    if (((int64)((*s)) == (int64)0)) {
        return (int64)0;
    }
    hsum = (csum = (int64)((*s++)));
L1020:;
    while (1) {
        c = (int64)((*s++));
        if ((c == (int64)0)) {
            goto L1021;
        }
        csum += c;
        hsum = ((hsum << (int64)3) + csum);
    }
L1021:;
    return ((hsum << (int64)5) ^ csum);
}

static void qc_lex_inithashtable(void) {
    int64 i;
    int64 av_1;
    memset((void *)(&qc_lex_hashtable),(int32)0,(uint64)((int64)16777216));
L1022:;
    for (i=(int64)1;i<=(int64)323;++i) {
L1023:;
        qc_lex_nextlx.svalue = qc_tables_stnames[(i)-1];
        qc_lex_nextlx.length = (int64)(strlen(qc_lex_nextlx.svalue));
        qc_lex_nextlx.hashvalue = qc_lex_gethashvaluez(qc_lex_nextlx.svalue);
        if (!!(qc_lex_lookup())) {
            printf("%s\n",(char*)(qc_tables_stnames[(i)-1]));
            mlib_abortprogram((byte*)"Duplicate symbol table entry");
        }
        (*qc_lex_lxsymptr).symbol = (byte)(qc_tables_stsymbols[(i)-1]);
        if ((qc_tables_stsymbols[(i)-1]==(int64)44)) {
            (*qc_lex_lxsymptr).index = (int32)(qc_tables_stsubcodes[(i)-1]);
            (*qc_lex_lxsymptr).subcode = (int16)44;
            (*qc_lex_lxsymptr).symbol = (uint8)34u;
        }
        else {
            (*qc_lex_lxsymptr).subcode = (int16)(qc_tables_stsubcodes[(i)-1]);
        }
L1024:;
    }
L1025:;
}

static int64 qc_lex_dolexdirective(int64 index) {
    struct var_decls_strec *  symptr;
    byte *  p;
    byte *  file;
    int64 i;
    if ((index==(int64)1)) {
        qc_lex_lexreadtoken();
        if ((qc_lex_nextlx.symbol != (int64)34)) {
            qc_lex_lxerror((byte*)"define: name expected");
        }
        if ((!!(qc_lex_lookup()) && ((int64)((*qc_lex_lxsymptr).symbol) == (int64)47))) {
            qc_lex_printstrn(qc_lex_nextlx.svalue,qc_lex_nextlx.length);
            qc_lex_lxerror((byte*)"Macro already defined");
        }
        symptr = qc_lex_lxsymptr;
        qc_lex_lexreadtoken();
        if (!(((qc_lex_nextlx.symbol == (int64)31) && (qc_lex_nextlx.subcode == (int64)96)))) {
            qc_lex_lxerror((byte*)"\"=\" expected");
        }
        p = qc_lex_lxsptr;
        qc_lex_lexreadline();
        qc_lex_addmacro(symptr,p,(qc_lex_lxsptr - p));
        qc_lex_lexreadtoken();
        if ((qc_lex_nextlx.symbol != (int64)32)) {
            qc_lex_lxerror((byte*)"Bad define");
        }
        return (int64)0;
    } else if ((index==(int64)14)) {
        qc_lex_lexreadtoken();
        if ((qc_lex_nextlx.symbol != (int64)42)) {
            qc_lex_lxerror((byte*)"strincl: string expected");
        }
        file = qc_lex_nextlx.svalue;
        qc_lex_nextlx.svalue = mlib_readfile(file);
        if ((qc_lex_nextlx.svalue == 0)) {
L1026:;
            for (i=(int64)1;i<=var_decls_nextra;++i) {
L1027:;
                if (!!(mlib_eqstring(file,var_decls_extrafiles[(i)-1]))) {
                    qc_lex_nextlx.svalue = var_decls_extratext[(i)-1];
                    goto L1029;
                }
L1028:;
            }
L1029:;
            if ((qc_lex_nextlx.svalue == 0)) {
                printf("%s\n",(char*)(file));
                qc_lex_lxerror((byte*)"Can't find strinclude file");
            }
        }
        qc_lex_nextlx.symbol = (int64)42;
        qc_lex_nextlx.subcode = (int64)5;
        qc_lex_nextlx.length = mlib_rfsize;
        printf("%s %lld\n",(char*)((byte*)"RFSIZE="),(int64)mlib_rfsize);
        (*(qc_lex_nextlx.svalue + mlib_rfsize)) = (uint8)0u;
        return (int64)1;
    } else if ((index==(int64)10)) {
    } else if ((index==(int64)11)) {
    }
    else {
        printf("%s\n",(char*)(qc_tables_sourcedirnames[(index)-1]));
        qc_lex_lxerror((byte*)"Directive not implemented");
    }
    return (int64)0;
}

static void qc_lex_lexreadline(void) {
L1030:;
    switch ((int64)((*qc_lex_lxsptr))) {
    case 13:;
    case 10:;
        return;
        break;
    case 26:;
    case 0:;
        --qc_lex_lxsptr;
        return;
        break;
    default:;
        ++qc_lex_lxsptr;
    }
    goto L1030;
L1031:;
}

void qc_lex_startlex(byte * caption,byte * sourcecode) {
    qc_lex_lxsptr = sourcecode;
    qc_lex_nextlx.lineno = (int64)1;
    qc_lex_nextlx.symbol = (int64)6;
    qc_lex_nextlx.subcode = (int64)0;
}

byte * qc_lex_convertzstring(byte * s,int64 length) {
    static byte str[300];
    if ((length > (int64)300)) {
        mlib_abortprogram((byte*)"convertzstr");
    }
    memcpy((void *)(&str),(void *)(s),(uint64)(length));
    str[((length + (int64)1))-1] = (uint8)0u;
    return str;
}

struct var_decls_strec * qc_lex_addnamestr(byte * name) {
    struct qc_lex_lexrec oldlx;
    memcpy(&oldlx,&qc_lex_nextlx,56);
    qc_lex_nextlx.hashvalue = qc_lex_gethashvaluez(name);
    qc_lex_nextlx.length = (int64)(strlen(name));
    qc_lex_nextlx.svalue = (byte *)(mlib_pcm_alloc((qc_lex_nextlx.length + (int64)1)));
    memcpy((void *)(qc_lex_nextlx.svalue),(void *)(name),(uint64)((qc_lex_nextlx.length + (int64)1)));
    qc_lex_lookup();
    memcpy(&qc_lex_nextlx,&oldlx,56);
    return qc_lex_lxsymptr;
}

void qc_lex_ps1(byte * caption) {
    printf("%s%s",(char*)(caption),(char*)((byte*)":::"));
    qc_lex_printsymbol(&qc_lex_lx);
}

void qc_lex_ps2(byte * caption) {
    printf("%s%s%s",(char*)((byte*)"\t"),(char*)(caption),(char*)((byte*)":##"));
    qc_lex_printsymbol(&qc_lex_nextlx);
}

void qc_lex_ps(byte * caption) {
    qc_lex_ps1(caption);
    qc_lex_ps2(caption);
}

void qc_lex_lex(void) {
    int64 lineno;
    int64 n;
    byte *  p;
    memcpy(&qc_lex_lx,&qc_lex_nextlx,56);
//reenter:
L1032:;
    qc_lex_lexreadtoken();
    if ((qc_lex_lx.symbol == (int64)45)) {
        (*((*qc_lex_lx.symptr).name + qc_lex_lx.length)) = (uint8)0u;
    }
    switch (qc_lex_nextlx.symbol) {
    case 32:;
        if ((qc_lex_lx.symbol==(int64)5) || (qc_lex_lx.symbol==(int64)14) || (qc_lex_lx.symbol==(int64)12)) {
            goto L1032;
        } else if ((qc_lex_lx.symbol==(int64)6)) {
            goto L1032;
        }
        else {
            qc_lex_nextlx.symbol = (int64)6;
        }
        break;
    case 34:;
        if (!(!!(qc_lex_lookup()))) {
            qc_lex_nextlx.symbol = (int64)45;
            qc_lex_nextlx.symptr = qc_lex_lxsymptr;
            return;
        }
        qc_lex_nextlx.symbol = (int64)((*qc_lex_lxsymptr).symbol);
        qc_lex_nextlx.subcode = (int64)((*qc_lex_lxsymptr).subcode);
        switch (qc_lex_nextlx.symbol) {
        case 47:;
            qc_lex_stackmacro((*qc_lex_lxsymptr).macrovalue);
            goto L1032;
            break;
        case 46:;
            if (!(!!(qc_lex_dolexdirective(qc_lex_nextlx.subcode)))) {
                goto L1032;
            }
            break;
        case 34:;
            if (((qc_lex_nextlx.subcode == (int64)44) && ((qc_lex_lx.symbol == (int64)37) || (qc_lex_lx.symbol == (int64)39)))) {
                if ((qc_lex_lx.symbol==(int64)37)) {
                    if (((int64)((*qc_lex_lxsymptr).index)==(int64)2)) {
                        qc_lex_lx.value *= (int64)1000000;
                    } else if (((int64)((*qc_lex_lxsymptr).index)==(int64)3)) {
                        qc_lex_lx.value *= (int64)1000000000;
                    } else if (((int64)((*qc_lex_lxsymptr).index)==(int64)1)) {
                        qc_lex_lx.value *= (int64)1000;
                    }
                    else {
                        qc_lex_lxerror((byte*)"Can't do this unit index");
                    }
                }
                else {
                    qc_lex_lxerror((byte*)"Unit suffix after float not implem");
                }
                goto L1032;
            }
            else {
                qc_lex_nextlx.symbol = (int64)45;
                qc_lex_nextlx.symptr = qc_lex_lxsymptr;
            }
            break;
        case 45:;
            qc_lex_lxerror((byte*)"NEXT NAME!!!");
            break;
        case 50:;
        case 59:;
        case 75:;
        case 60:;
        case 76:;
        case 62:;
        case 63:;
        case 66:;
        case 64:;
        case 83:;
        case 84:;
        case 85:;
        case 90:;
        case 58:;
        case 86:;
        case 87:;
        case 88:;
        case 92:;
        case 67:;
        case 102:;
        case 110:;
        case 122:;
            if ((qc_lex_lx.symbol == (int64)57)) {
                qc_lex_lx.subcode = qc_lex_nextlx.symbol;
                goto L1032;
            }
            break;
        case 31:;
            goto L1033;
            break;
        case 131:;
            if ((qc_lex_nextlx.subcode==(int64)1) || (qc_lex_nextlx.subcode==(int64)4)) {
                qc_lex_nextlx.symbol = (int64)37;
                qc_lex_nextlx.value = (int64)0;
                qc_lex_nextlx.subcode = (int64)1;
            } else if ((qc_lex_nextlx.subcode==(int64)2)) {
                qc_lex_nextlx.symbol = (int64)39;
                qc_lex_nextlx.xvalue = (float)3.141593;
                qc_lex_nextlx.subcode = (int64)3;
            } else if ((qc_lex_nextlx.subcode==(int64)3)) {
                qc_lex_nextlx.symbol = (int64)42;
                qc_lex_nextlx.subcode = (int64)5;
                qc_lex_nextlx.svalue = (byte*)"\t";
                qc_lex_nextlx.length = (int64)1;
            }
            else {
                qc_lex_lxerror((byte*)"sysconst?");
            }
            break;
        default:;
        }
        break;
    case 3:;
        goto L1032;
        break;
    case 33:;
        break;
    case 42:;
        if ((qc_lex_lx.symbol == (int64)42)) {
            n = (qc_lex_nextlx.length + qc_lex_lx.length);
            p = (byte *)(mlib_pcm_alloc((n + (int64)1)));
            memcpy((void *)(p),(void *)(qc_lex_lx.svalue),(uint64)(qc_lex_lx.length));
            memcpy((void *)((p + qc_lex_lx.length)),(void *)(qc_lex_nextlx.svalue),(uint64)(qc_lex_nextlx.length));
            (*(p + n)) = (uint8)0u;
            qc_lex_lx.svalue = p;
            qc_lex_lx.length = n;
            goto L1032;
        }
        break;
    case 31:;
//doopsym:
L1033:;
        if ((((qc_lex_nextlx.subcode == (int64)117) && (qc_lex_lx.symbol == (int64)31)) && (qc_lex_lx.subcode == (int64)75))) {
            qc_lex_lx.subcode = (int64)118;
            goto L1032;
        }
        break;
    default:;
    }
}

void qc_lex_showhashtablesize(void) {
    int64 i;
    int64 n;
    n = (int64)0;
L1034:;
    for (i=(int64)0;i<=(int64)131071;++i) {
L1035:;
        if (!!(qc_lex_hashtable[(i)].name)) {
            ++n;
        }
L1036:;
    }
L1037:;
    printf("%s %lld %lld\n",(char*)((byte*)"FINAL HASHTABLE"),(int64)n,(int64)(int64)131072);
}

static void qc_lex_addmacro(struct var_decls_strec * symptr,byte * value,int64 length) {
    byte *  s;
    int64 i;
    s = value;
L1038:;
    for (i=(int64)1;i<=length;++i) {
L1039:;
        if (((int64)((*s))==(int64)34)) {
        } else if (((int64)((*s))==(int64)35) || ((int64)((*s))==(int64)33)) {
            length = (i - (int64)1);
            if ((length == (int64)0)) {
                qc_lex_lxerror((byte*)"Null macro");
            }
            goto L1041;
        }
        ++s;
L1040:;
    }
L1041:;
    (*symptr).symbol = (uint8)47u;
    (*((*symptr).name + (int64)((*symptr).namelen))) = (uint8)0u;
    s = (byte *)(mlib_pcm_alloc((length + (int64)2)));
    memcpy((void *)(s),(void *)(value),(uint64)(length));
    (*((s + length) + (int64)1)) = (uint8)26u;
    (*((s + length) + (int64)2)) = (uint8)0u;
    (*symptr).macrovalue = s;
}

static void qc_lex_stackmacro(byte * s) {
    if ((qc_lex_macrolevel >= (int64)10)) {
        qc_lex_lxerror((byte*)"Too many nested macros");
    }
    ++qc_lex_macrolevel;
    qc_lex_macrostack[(qc_lex_macrolevel)-1] = qc_lex_lxsptr;
    qc_lex_lxsptr = mlib_pcm_copyheapstring(s);
}

static void qc_lex_unstackmacro(void) {
    if ((qc_lex_macrolevel <= (int64)0)) {
        qc_lex_lxerror((byte*)"unstack macro?");
    }
    qc_lex_lxsptr = qc_lex_macrostack[(qc_lex_macrolevel--)-1];
}

int64 qc_parse_parsemodule(int64 n) {
    struct var_decls_modulerec m;
    struct var_decls_strec *  p;
    struct var_decls_strec *  owner;
    int64 globalflag;
    int64 status;
    qc_parse_initparser();
    memcpy(&m,&var_decls_moduletable[(n)],118);
    var_decls_stmodule = var_decls_moduletable[(n)].stmodule;
    qc_lex_startlex((byte*)"PARSEMODULE",m.sourcecode);
    owner = var_decls_stmodule;
    qc_lex_lex();
    status = qc_parse_readmoduledefs(owner);
    if (!(!!(status))) {
        return (int64)0;
    }
    p = (*var_decls_stmodule).deflist;
L1042:;
    while (!!(p)) {
        if ((((int64)((*p).nameid) == (int64)6) && !!((*p).attribs.ax_forward))) {
            printf("%s %s\n",(char*)((*p).name),(char*)(pq_common_namenames[((int64)((*p).nameid))]));
            qc_support_serror((byte*)"Proc not defined");
        }
        p = (*p).nextdef;
L1043:;
    }
L1044:;
    return status;
}

int64 qc_parse_readmoduledefs(struct var_decls_strec * owner) {
    struct var_decls_strec *  p;
    int64 globalflag;
    int64 i;
    int64 found;
    globalflag = (int64)0;
L1045:;
    while (1) {
        switch (qc_lex_lx.symbol) {
        case 107:;
            if (!!(globalflag)) {
                qc_support_serror((byte*)"global global?");
            }
            globalflag = (int64)1;
            qc_lex_lex();
            break;
        case 83:;
        case 84:;
        case 85:;
            qc_parse_readprocdef(owner,globalflag,(int64)0);
            ++qc_parse_nprocs;
            globalflag = (int64)0;
            break;
        case 97:;
            qc_parse_readvardef(owner,globalflag,(int64)0,(int64)10);
            globalflag = (int64)0;
            break;
        case 90:;
            qc_parse_readimportmodule(owner);
            break;
        case 92:;
            qc_parse_readtypedef(owner,globalflag);
            globalflag = (int64)0;
            break;
        case 96:;
            qc_parse_readconstdef(owner,globalflag);
            globalflag = (int64)0;
            break;
        case 102:;
        case 86:;
            qc_parse_readclassdef(owner,globalflag);
            globalflag = (int64)0;
            break;
        case 100:;
            qc_lex_lex();
            qc_parse_readenumtype(owner,(int64)0,(int64)0);
            break;
        case 122:;
            qc_parse_readtabledef(owner,globalflag);
            globalflag = (int64)0;
            break;
        case 35:;
            mlib_gs_strn(var_decls_docstring,qc_lex_lx.svalue,qc_lex_lx.length);
            mlib_gs_line(var_decls_docstring);
            qc_lex_lex();
            break;
        case 89:;
            if (!!(globalflag)) {
                qc_support_serror((byte*)"glob/import?");
            }
            qc_lex_lex();
            if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)105))) {
                qc_lex_lex();
            }
            qc_parse_checksymbol((int64)45);
            found = (int64)0;
L1047:;
            for (i=(int64)1;i<=var_decls_nmodules;++i) {
L1048:;
                if (!!(mlib_eqstring((*qc_lex_lx.symptr).name,var_decls_moduletable[(i)].name))) {
                    found = (int64)1;
                    goto L1050;
                }
L1049:;
            }
L1050:;
            if (!(!!(found))) {
                printf("%s\n",(char*)((*qc_lex_lx.symptr).name));
                qc_support_serror((byte*)"Import stmt out of position?");
            }
            qc_lex_lex();
            break;
        case 129:;
            if ((qc_lex_lx.subcode==(int64)1)) {
                if (!!(osnos_os_iswindows())) {
                    qc_lex_lex();
                }
                else {
//skiptoeol:
L1051:;
L1052:;
                    do {
                        qc_lex_lex();
L1053:;
                    } while (!((qc_lex_lx.symbol == (int64)6) || (qc_lex_lx.symbol == (int64)33)));;
L1054:;
                }
            } else if ((qc_lex_lx.subcode==(int64)2)) {
                if (!(!!(osnos_os_iswindows()))) {
                    qc_lex_lex();
                }
                else {
                    goto L1051;
                }
            }
            else {
                qc_support_serror((byte*)"condcomp");
            }
            break;
        case 6:;
            qc_lex_lex();
            break;
        case 33:;
            goto L1046;
            break;
        default:;
            qc_lex_ps1((byte*)"symbol");
            qc_support_serror((byte*)"Not allowed at module level");
        }
    }
L1046:;
    return (int64)1;
}

static void qc_parse_initparser(void) {
    byte *  tabledataname = (byte*)"";
    if (!(!!(var_decls_nullunit))) {
        var_decls_nullunit = qc_lib_createunit0((int64)2);
    }
    qc_parse_try_level = (int64)0;
    qc_parse_currproc = (struct var_decls_strec *)(0);
    qc_parse_varattribs = (int64)0;
    qc_parse_intabledata = (int64)0;
    qc_parse_inreadprint = (int64)0;
    qc_parse_inparamlist = (int64)0;
    qc_parse_inrecordbody = (int64)0;
    qc_parse_inimportmodule = (int64)0;
    qc_parse_labelseen = (int64)0;
    qc_parse_ndollar = (int64)0;
    mlib_gs_init(var_decls_docstring);
}

static void qc_parse_skipsemi(void) {
L1055:;
    while ((qc_lex_lx.symbol == (int64)6)) {
        qc_lex_lex();
L1056:;
    }
L1057:;
}

static void qc_parse_addalias(struct var_decls_strec * stold,struct var_decls_strec * stnew) {
    stnew = qc_lib_getduplnameptr((*stold).owner,stnew,(int64)18);
    qc_lib_adddef((*stold).owner,stnew);
    (*stnew).equiv = stold;
}

static struct var_decls_unitrec * qc_parse_makeblock(struct var_decls_unitrec * p) {
    return qc_lib_createunit1((int64)4,p);
}

static void qc_parse_convertstmtexpr(struct var_decls_unitrec * p) {
    if (((int64)((*p).tag)==(int64)86)) {
        (*p).tag = (int32)17;
    } else if (((int64)((*p).tag)==(int64)88)) {
        (*p).tag = (int32)14;
    } else if (((int64)((*p).tag)==(int64)89)) {
        printf("%s\n",(char*)((byte*)"MAKE CALLMPROC1"));
        (*p).tag = (int32)15;
    }
    else {
        qc_support_serror((byte*)"NOT STMT EXPR");
    }
}

static void qc_parse_checkequals(void) {
    if (!(((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)96)))) {
        qc_support_serror((byte*)"\"=\" expected");
    }
}

static int64 qc_parse_getcurrline(void) {
    return qc_lex_lx.lineno;
}

static int64 qc_parse_checkbegin(int64 fbrack) {
    int64 closesym;
    qc_parse_skipsemi();
    if (((qc_lex_lx.symbol == (int64)12) && !!(fbrack))    ) {
        closesym = (int64)13;
        qc_lex_lex();
    }
    else if ((qc_lex_lx.symbol == (int64)109)) {
        closesym = (int64)57;
        qc_lex_lex();
    }
    else if ((qc_lex_lx.symbol == (int64)16)) {
        closesym = (int64)17;
        qc_lex_lex();
    }
    else {
        closesym = (int64)57;
    }
    return closesym;
}

static void qc_parse_checkbeginend(int64 closesym,int64 kwd,int64 startline) {
    qc_parse_skipsemi();
    if (((closesym == (int64)13) || (closesym == (int64)17))) {
        qc_parse_checksymbol(closesym);
    }
    else {
        qc_parse_checkend(closesym,kwd,startline,(int64)0);
    }
    qc_lex_lex();
}

static void qc_parse_checkend(int64 endsym,int64 endkwd1,int64 endkwd2,int64 startline) {
    byte str[100];
    if (((endsym == qc_lex_lx.symbol) && (qc_lex_lx.symbol == (int64)13))) {
        return;
    }
    if ((qc_lex_lx.symbol != (int64)57)) {
        strcpy(str,(byte*)"Bad 'end' ");
//error:
L1058:;
        if (!!(startline)) {
            sprintf((str + (int64)(strlen(str))),(byte*)" (from line %d)",startline);
        }
        qc_support_serror(str);
    }
    if ((qc_lex_lx.subcode == (int64)0)) {
        return;
    }
    if (!(((!!(endkwd1) && (endkwd1 == qc_lex_lx.subcode)) || (!!(endkwd2) && (endkwd2 == qc_lex_lx.subcode))))) {
        strcpy(str,(byte*)"Mismatched 'end'");
        goto L1058;
    }
}

static void qc_parse_addgenfield(struct var_decls_strec * d) {
    if (((int64)((*d).nameid) == (int64)14)) {
        return;
    }
    if ((var_decls_ngenfieldnames >= (int64)1000)) {
        qc_support_serror((byte*)"Too many genfields");
    }
    (*d).nameid = (uint8)14u;
    var_decls_genfieldnames[(++var_decls_ngenfieldnames)-1].def = d;
    (*d).offset = (int32)(var_decls_ngenfieldnames);
}

static void qc_parse_readvardef(struct var_decls_strec * owner,int64 isglobal,int64 isstatic,int64 varid) {
    int64 nvars;
    int64 m;
    struct var_decls_strec *  stname;
    qc_lex_lex();
    m = (int64)35;
    nvars = (int64)0;
L1059:;
    while ((qc_lex_lx.symbol == (int64)45)) {
        ++nvars;
        stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,varid);
        (*stname).mode = (int16)(m);
        (*stname).attribs.ax_global = (byte)(isglobal);
        (*stname).attribs.ax_static = (byte)(isstatic);
        qc_lib_adddef(owner,stname);
        qc_lex_lex();
        if (((qc_lex_lx.symbol == (int64)9) || ((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)96)))) {
            if ((qc_lex_lx.symbol == (int64)9)) {
                if ((varid == (int64)10)) {
                    qc_support_serror((byte*)"Need = on static not :=");
                }
            }
            else {
                if ((varid == (int64)11)) {
                    (*stname).nameid = (uint8)10u;
                    (*stname).attribs.ax_frame = (uint8)0u;
                }
            }
            qc_lex_lex();
            (*stname).code = qc_parse_readexpression();
            (*stname).attribs.ax_equals = (uint8)1u;
        }
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1061;
        }
        qc_lex_lex();
L1060:;
    }
L1061:;
    if ((nvars == (int64)0)) {
        qc_support_serror((byte*)"No vars declared");
    }
}

static void qc_parse_readconstdef(struct var_decls_strec * owner,int64 isglobal) {
    int64 nconsts;
    int64 deft;
    int64 t;
    struct var_decls_strec *  stname;
    qc_lex_lex();
    deft = (int64)0;
    nconsts = (int64)0;
L1062:;
    while ((qc_lex_lx.symbol == (int64)45)) {
        stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64)9);
        qc_lex_lex();
        qc_parse_checkequals();
        qc_lex_lex();
        (*stname).code = qc_parse_readconstexpr(owner,(int64)1);
        if ((deft == (int64)0)) {
            t = (int64)((*(*stname).code).valuemode);
        }
        else {
            t = deft;
        }
        (*stname).mode = (int16)(t);
        ++nconsts;
        (*stname).attribs.ax_global = (byte)(isglobal);
        qc_lib_adddef(owner,stname);
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1064;
        }
        qc_lex_lex();
L1063:;
    }
L1064:;
    if ((nconsts == (int64)0)) {
        qc_support_serror((byte*)"No consts declared");
    }
}

static struct var_decls_unitrec * qc_parse_readexpression(void) {
    return qc_parse_readfactor((int64)8);
}

static struct var_decls_unitrec * qc_parse_readfactor(int64 level) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    int64 opc;
    int64 opprio;
    int64 lineno;
    if ((level <= (int64)1)) {
        p = qc_parse_readterm();
    }
    else {
        p = qc_parse_readfactor((level - (int64)1));
    }
L1065:;
    switch (qc_lex_lx.symbol) {
    case 31:;
    case 9:;
    case 29:;
    case 24:;
    case 10:;
        if (((qc_lex_lx.symbol == (int64)9) && !!(qc_parse_inmultexpr))) {
            goto L1066;
        }
        opc = qc_lex_lx.subcode;
        opprio = (int64)(qc_tables_jtagpriotable[(opc)]);
        lineno = qc_lex_lx.lineno;
        if ((opprio != level)) {
            goto L1066;
        }
        qc_lex_lex();
        if (((opc == (int64)86) || (opc == (int64)87))        ) {
            q = qc_parse_readexpression();
        }
        else if ((opc == (int64)143)) {
            q = qc_parse_readfactor(level);
        }
        else {
            q = qc_parse_readfactor((level - (int64)1));
        }
        p = qc_lib_createunit2(opc,(r = p),q);
        (*p).lineno = (int32)(lineno);
        if ((((int64)((*r).tag) == (int64)1) && ((int64)((*q).tag) == (int64)1))) {
            qc_parselib_evalbinop(p,r,q);
        }
        break;
    default:;
        goto L1066;
    }
    goto L1065;
L1066:;
    return p;
}

static struct var_decls_unitrec * qc_parse_readterm(void) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    byte *  pbyte;
    uint64 a;
    int64 oldipl;
    int64 opc;
    int64 oldinrp;
    int64 lineno;
    int64 shift;
    int64 av_1;
    lineno = qc_lex_lx.lineno;
    switch (qc_lex_lx.symbol) {
    case 45:;
        p = qc_lib_createname(qc_lex_lx.symptr);
        (*p).lineno = (int32)(qc_lex_lx.lineno);
        if ((qc_lex_nextlx.symbol == (int64)12)) {
            qc_parse_createproccall(var_decls_stmodule,qc_lex_lx.symptr,p);
        }
        else {
            qc_parselib_px_name(var_decls_stmodule,qc_parse_currproc,p,(int64)((qc_lex_nextlx.symbol == (int64)2)));
        }
        qc_lex_lex();
        break;
    case 37:;
    case 39:;
        p = qc_lib_createconstunit((uint64)(qc_lex_lx.value),qc_lex_lx.subcode);
        qc_lex_lex();
        break;
    case 42:;
        p = qc_lib_createstringconstunit(qc_lex_lx.svalue,qc_lex_lx.length);
        (*p).slength = (int32)(qc_lex_lx.length);
        qc_lex_lex();
        break;
    case 38:;
        (*(qc_lex_lx.svalue + qc_lex_lx.length)) = (uint8)0u;
        p = qc_lib_createunit0((int64)9);
        (*p).svalue = qc_lex_lx.svalue;
        (*p).slength = (int32)(qc_lex_lx.length);
        qc_lex_lex();
        break;
    case 40:;
        a = (uint64)((int64)0);
        shift = (int64)0;
        pbyte = qc_lex_lx.svalue;
        av_1 = qc_lex_lx.length;
        while (av_1-- > 0) {
L1067:;
            a = (a | ((uint64)((*pbyte)) << shift));
            shift += (int64)8;
            ++pbyte;
L1068:;
        }
L1069:;
        p = qc_lib_createconstunit(a,(int64)1);
        qc_lex_lex();
        break;
    case 12:;
        p = qc_parse_readlbrack();
        if (((int64)((*p).tag) == (int64)77)) {
            qc_parselib_checkconstlist(p);
        }
        break;
    case 14:;
        oldipl = qc_parse_inparamlist;
        qc_parse_inparamlist = (int64)0;
        p = qc_parse_readlsqbrack();
        qc_parse_inparamlist = oldipl;
        break;
    case 48:;
    case 94:;
        p = qc_parse_readcast();
        break;
    case 31:;
        p = qc_parse_readopc();
        break;
    case 36:;
        opc = qc_lex_lx.subcode;
        qc_lex_lex();
        p = qc_lib_createunit1(opc,qc_parse_readterm());
        break;
    case 78:;
        p = qc_parse_readsprint();
        break;
    case 80:;
    case 81:;
        p = qc_parse_readsread();
        break;
    case 18:;
    case 24:;
        opc = qc_lex_lx.subcode;
        qc_lex_lex();
        p = qc_lib_createunit1(opc,qc_parse_readterm());
        if (((int64)((*(*p).a).tag) == (int64)88)) {
            if (!!((*(*p).a).b)) {
                qc_support_serror((byte*)"Params not allowed");
            }
            (*p).a = (*(*p).a).a;
        }
        break;
    case 119:;
        p = qc_parse_readcompilervar();
        break;
    case 130:;
        p = qc_lib_createconstunit((uint64)(qc_lex_lx.subcode),(int64)1);
        qc_lex_lex();
        break;
    case 120:;
        if (!!(qc_parse_intabledata)) {
            p = qc_lib_createstringconstunit(qc_parse_tabledataname,(int64)-1);
        }
        else {
            if ((qc_parse_ndollar <= (int64)0)) {
                qc_support_serror((byte*)"[$] No array");
            }
            p = qc_lib_createunit1((int64)179,qc_parse_dollarstack[(qc_parse_ndollar)-1]);
        }
        qc_lex_lex();
        break;
    case 124:;
        p = qc_parse_readapplyop((int64)1);
        break;
    case 117:;
        p = qc_parse_readcastx();
        break;
    case 118:;
        qc_lex_lex();
        qc_parse_checksymbol((int64)12);
        qc_lex_lex();
        p = qc_lib_createunit0((int64)149);
        (*p).valuemode = (int32)(qc_parse_readtypespec((struct var_decls_strec *)(0),(int64)0));
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
        break;
    case 127:;
        qc_lex_lex();
        qc_parse_checksymbol((int64)12);
        qc_lex_lex();
        p = qc_parse_readexpression();
        qc_parse_checksymbol((int64)5);
        qc_lex_lex();
        q = qc_parse_readexpression();
        if (((qc_lex_lx.symbol == (int64)13) && ((int64)((*q).tag) == (int64)80))) {
            r = (*q).b;
            q = (*q).a;
        }
        else {
            qc_parse_checksymbol((int64)5);
            qc_lex_lex();
            r = qc_parse_readexpression();
            qc_parse_checksymbol((int64)13);
        }
        qc_lex_lex();
        p = qc_lib_createunit3((int64)126,p,q,r);
        break;
    case 82:;
        p = qc_parse_readhostparams((struct var_decls_unitrec *)(0),(int64)1);
        break;
    default:;
        printf("%s\n",(char*)(qc_tables_symbolnames[(qc_lex_lx.symbol)-1]));
        qc_support_serror((byte*)"readterm?");
    }
L1070:;
    switch (qc_lex_lx.symbol) {
    case 12:;
        qc_lex_lex();
        oldinrp = qc_parse_inreadprint;
        qc_parse_inreadprint = (int64)0;
        q = qc_parse_readslist((int64)1,(int64)1);
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
        p = qc_lib_createunit2((((int64)((*p).tag) == (int64)139)?(int64)89:(int64)88),p,q);
        p = qc_parse_testconstruct(p);
        qc_parse_inreadprint = oldinrp;
        break;
    case 18:;
        p = qc_lib_createunit1((int64)144,p);
        qc_lex_lex();
        break;
    case 14:;
        p = qc_parse_readindex(p,(int64)0);
        break;
    case 16:;
        p = qc_parse_readkeyindex(p,(int64)0);
        break;
    case 2:;
        p = qc_parse_readdotsuffix(p);
        break;
    case 7:;
        if (!!(qc_parse_inreadprint)) {
            goto L1071;
        }
        qc_lex_lex();
        q = qc_parse_readexpression();
        p = qc_lib_createunit2((!!(qc_parse_inparamlist)?(int64)84:(int64)85),p,q);
        break;
    case 36:;
        if ((qc_lex_lx.subcode==(int64)207)) {
            opc = (int64)209;
        } else if ((qc_lex_lx.subcode==(int64)208)) {
            opc = (int64)210;
        }
        qc_lex_lex();
        p = qc_lib_createunit1(opc,p);
        break;
    case 4:;
        qc_lex_lex();
        qc_parse_checksymbol((int64)14);
        qc_lex_lex();
        q = qc_parse_readexpression();
        if (((int64)((*q).tag) == (int64)80)) {
            p = qc_lib_createunit2((int64)137,p,q);
        }
        else {
            p = qc_lib_createunit2((int64)136,p,q);
        }
        qc_parse_checksymbol((int64)15);
        qc_lex_lex();
        break;
    case 31:;
        if ((qc_lex_lx.subcode==(int64)160)) {
            p = qc_lib_createunit1((int64)160,p);
            qc_lex_lex();
        }
        else {
            goto L1071;
        }
        break;
    default:;
        goto L1071;
    }
    goto L1070;
L1071:;
    (*p).lineno = (int32)(lineno);
    return p;
}

static struct var_decls_unitrec * qc_parse_readlbrack(void) {
    struct var_decls_unitrec *  plower;
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    int64 lcmode;
    int64 oldirp;
    qc_lex_lex();
    plower = (struct var_decls_unitrec *)(0);
    lcmode = (int64)29;
    ulist = (ulistx = (struct var_decls_unitrec *)(0));
    if ((qc_lex_lx.symbol == (int64)21)    ) {
        qc_lex_lex();
        oldirp = qc_parse_inreadprint;
        qc_parse_inreadprint = (int64)1;
        plower = qc_parse_readexpression();
        qc_parse_inreadprint = oldirp;
        qc_parse_checksymbol((int64)7);
        qc_lex_lex();
    }
    else if (((qc_lex_lx.symbol == (int64)37) && (qc_lex_nextlx.symbol == (int64)7))) {
        plower = qc_lib_createconstunit((uint64)(qc_lex_lx.value),qc_lex_lx.subcode);
        qc_lex_lex();
        qc_lex_lex();
    }
    else if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_nextlx.symbol == (int64)13))) {
        p = qc_lib_createunit0((int64)150);
        (*p).opcode = (int32)(qc_lex_lx.subcode);
        qc_lex_lex();
        qc_lex_lex();
        return p;
    }
    else if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_nextlx.symbol == (int64)9))) {
        p = qc_lib_createunit0((int64)150);
        (*p).opcode = (int32)(qc_lib_getoptocode(qc_lex_lx.subcode));
        qc_lex_lex();
        qc_lex_lex();
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
        return p;
    }
    else if (((qc_lex_lx.symbol == (int64)92) && (qc_lex_nextlx.symbol == (int64)13))) {
        p = qc_lib_createunit0((int64)150);
        (*p).opcode = (int32)185;
        qc_lex_lex();
        qc_lex_lex();
        return p;
    }
    if (((qc_lex_lx.symbol == (int64)48) && (qc_lex_lx.subcode == (int64)5))) {
        lcmode = (int64)5;
        qc_lex_lex();
        qc_parse_checksymbol((int64)7);
        qc_lex_lex();
    }
    if ((qc_lex_lx.symbol==(int64)13)) {
        qc_lex_lex();
        p = qc_lib_createunit0((int64)77);
        if ((plower != 0)) {
            (*p).b = plower;
        }
        return p;
    }
    else {
        p = qc_parse_readexpression();
    }
    if ((qc_lex_lx.symbol==(int64)13)) {
        qc_lex_lex();
        if (!!(plower)) {
            return qc_lib_createunit2((int64)85,plower,p);
        }
        else {
            return p;
        }
    } else if ((qc_lex_lx.symbol==(int64)6)) {
        ulist = (ulistx = p);
L1072:;
        do {
            qc_lex_lex();
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
L1073:;
        } while (!(qc_lex_lx.symbol != (int64)6));;
L1074:;
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
        p = ulist;
L1075:;
        while (!!(p)) {
            if (((int64)((*p).tag)==(int64)86)) {
                (*p).tag = (int32)17;
            } else if (((int64)((*p).tag)==(int64)87)) {
                (*p).tag = (int32)19;
            } else if (((int64)((*p).tag)==(int64)207)) {
                (*p).tag = (int32)229;
            } else if (((int64)((*p).tag)==(int64)208)) {
                (*p).tag = (int32)230;
            } else if (((int64)((*p).tag)==(int64)209)) {
                (*p).tag = (int32)231;
            } else if (((int64)((*p).tag)==(int64)210)) {
                (*p).tag = (int32)232;
            } else if (((int64)((*p).tag)==(int64)88)) {
                (*p).tag = (int32)14;
            } else if (((int64)((*p).tag)==(int64)89)) {
                (*p).tag = (int32)15;
            }
            p = (*p).nextunit;
L1076:;
        }
L1077:;
        return qc_lib_createunit1((int64)82,ulist);
    } else if ((qc_lex_lx.symbol==(int64)5)) {
        if ((qc_lex_nextlx.symbol == (int64)13)) {
            qc_lex_lex();
            qc_lex_lex();
            return qc_lib_createunit2((int64)77,p,plower);
        }
        ulist = (ulistx = p);
L1078:;
        do {
            qc_lex_lex();
            if ((qc_lex_lx.symbol == (int64)13)) {
                goto L1080;
            }
            if ((qc_lex_lx.symbol == (int64)5)) {
                qc_support_serror((byte*)",, null expr not allowed");
            }
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
            qc_parse_skipsemi();
L1079:;
        } while (!(qc_lex_lx.symbol != (int64)5));;
L1080:;
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
        return qc_lib_createunit2((int64)77,ulist,plower);
    } else if ((qc_lex_lx.symbol==(int64)19)) {
        qc_lex_lex();
        q = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)19)) {
            qc_lex_lex();
            r = qc_parse_readexpression();
            qc_parse_checksymbol((int64)13);
            qc_lex_lex();
            return qc_lib_createunit3((int64)90,p,q,r);
        }
        qc_parse_addlistunit(&ulist,&ulistx,q);
        qc_parse_checksymbol((int64)5);
        if ((qc_lex_nextlx.symbol != (int64)19)) {
L1081:;
            do {
                qc_lex_lex();
                qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
L1082:;
            } while (!(qc_lex_lx.symbol != (int64)5));;
L1083:;
            qc_parse_checksymbol((int64)19);
        }
        else {
            qc_lex_lex();
        }
        qc_lex_lex();
        r = qc_parse_readexpression();
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
        return qc_lib_createunit3((int64)91,p,ulist,r);
    } else if ((qc_lex_lx.symbol==(int64)20) || (qc_lex_lx.symbol==(int64)62) || (qc_lex_lx.symbol==(int64)63)) {
        qc_support_serror((byte*)"READLISTCOMP");
    }
    else {
        qc_support_serror((byte*)"(x ...");
    }
    return (struct var_decls_unitrec *)(0);
}

static void qc_parse_addlistunit(struct var_decls_unitrec * * ulist,struct var_decls_unitrec * * ulistx,struct var_decls_unitrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    }
    else {
        (*(*ulistx)).nextunit = p;
    }
    (*ulistx) = p;
}

static void qc_parse_addlistparam(struct var_decls_strec * * ulist,struct var_decls_strec * * ulistx,struct var_decls_strec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    }
    else {
        (*(*ulistx)).nextparam = p;
    }
    (*ulistx) = p;
}

static struct var_decls_unitrec * qc_parse_readlsqbrack(void) {
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    qc_lex_lex();
    ulist = (ulistx = (struct var_decls_unitrec *)(0));
    if ((qc_lex_lx.symbol == (int64)15)) {
        qc_lex_lex();
        p = qc_lib_createunit1((int64)79,(struct var_decls_unitrec *)(0));
        if (!(!!(qc_parselib_checkdict(p)))) {
            qc_parselib_checkconstlist(p);
        }
        return p;
    }
L1084:;
    while (1) {
        qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
        qc_parse_skipsemi();
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1085;
        }
        qc_lex_lex();
        if ((qc_lex_lx.symbol == (int64)15)) {
            goto L1085;
        }
    }
L1085:;
    qc_parse_checksymbol((int64)15);
    qc_lex_lex();
    p = qc_lib_createunit1((int64)79,ulist);
    if (!(!!(qc_parselib_checkdict(p)))) {
        qc_parselib_checkconstlist(p);
    }
    return p;
}

static struct var_decls_unitrec * qc_parse_readcast(void) {
    struct var_decls_unitrec *  p;
    int64 t;
    int64 opc;
    t = qc_parse_readtypespec((struct var_decls_strec *)(0),(int64)0);
    if ((qc_lex_lx.symbol==(int64)21) || (qc_lex_lx.symbol==(int64)12)) {
    }
    else {
        if ((t == (int64)0)) {
            p = qc_lib_createunit0((int64)8);
        }
        else {
            p = qc_lib_createunit0((int64)149);
        }
        (*p).valuemode = (int32)(t);
        return p;
    }
    qc_lib_checkunpackedtype(t);
    if ((qc_lex_lx.symbol == (int64)21)) {
        qc_lex_lex();
        opc = (int64)148;
    }
    else {
        opc = (int64)147;
    }
    qc_parse_checksymbol((int64)12);
    p = qc_parse_readlbrack();
    if (((int64)((*p).tag) == (int64)77)) {
        (*p).tag = (int32)78;
    }
    p = qc_lib_createunit1(opc,p);
    (*p).valuemode = (int32)(t);
    return p;
}

static struct var_decls_unitrec * qc_parse_readopc(void) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    int64 opc;
    int64 opc2;
    opc = qc_lex_lx.subcode;
    qc_lex_lex();
    if ((opc==(int64)103)) {
        return qc_parse_readterm();
    } else if ((opc==(int64)104)) {
        opc = (int64)154;
    } else if ((opc==(int64)120) || (opc==(int64)121) || (opc==(int64)142) || (opc==(int64)124) || (opc==(int64)125)) {
        qc_parse_checksymbol((int64)12);
        qc_lex_lex();
        p = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_lex_lex();
            q = qc_parse_readexpression();
            qc_parse_checksymbol((int64)13);
            qc_lex_lex();
            return qc_lib_createunit2(opc,p,q);
        }
        else {
            qc_parse_checksymbol((int64)13);
            qc_lex_lex();
            if ((opc==(int64)120)) {
                opc2 = (int64)205;
            } else if ((opc==(int64)121)) {
                opc2 = (int64)206;
            }
            else {
                qc_support_serror((byte*)"readopc");
            }
            return qc_lib_createunit1(opc,p);
        }
    }
    if ((qc_lex_lx.symbol == (int64)9)) {
        qc_support_serror((byte*)"op:= not allowed");
    }
    p = qc_lib_createunit1(opc,qc_parse_readterm());
    qc_parselib_evalmonop(p);
    return p;
}

static struct var_decls_unitrec * qc_parse_readsprint(void) {
    int64 oldinreadprint;
    int64 opc;
    int64 isfprint;
    struct var_decls_unitrec *  pformat;
    struct var_decls_unitrec *  pdev;
    struct var_decls_unitrec *  printlist;
    struct var_decls_unitrec *  printlistx;
    struct var_decls_unitrec *  p;
    oldinreadprint = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64)1;
    opc = qc_lex_lx.subcode;
    qc_lex_lex();
    qc_parse_checksymbol((int64)12);
    qc_lex_lex();
    if ((opc==(int64)55) || (opc==(int64)52)) {
        isfprint = (int64)1;
    }
    else {
        isfprint = (int64)0;
    }
    printlist = (printlistx = (struct var_decls_unitrec *)(0));
    pformat = (pdev = var_decls_nullunit);
    if ((qc_lex_lx.symbol == (int64)21)) {
        qc_lex_lex();
        pdev = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_lex_lex();
        }
        else {
            goto L1086;
        }
    }
    if (!!(isfprint)) {
        pformat = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_lex_lex();
        }
        else {
            goto L1086;
        }
    }
    if ((qc_lex_lx.symbol == (int64)13)) {
        goto L1086;
    }
L1087:;
    while (1) {
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_parse_addlistunit(&printlist,&printlistx,qc_lib_createunit0((int64)13));
        }
        else {
            p = qc_parse_readexpression();
            if ((qc_lex_lx.symbol == (int64)7)) {
                qc_lex_lex();
                p = qc_lib_createunit2((int64)12,p,qc_parse_readexpression());
            }
            qc_parse_addlistunit(&printlist,&printlistx,p);
        }
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1088;
        }
        qc_lex_lex();
    }
L1088:;
    qc_parse_checksymbol((int64)13);
//finish:
L1086:;
    qc_lex_lex();
    qc_parse_inreadprint = oldinreadprint;
    if ((((opc == (int64)48) || (opc == (int64)50)) && (printlist == 0))) {
        qc_support_serror((byte*)"No print items");
    }
    if (!!(isfprint)) {
        if (((int64)((*pformat).tag) == (int64)2)) {
            qc_support_serror((byte*)"No fmt str");
        }
        return qc_lib_createunit3(opc,pdev,pformat,printlist);
    }
    else {
        return qc_lib_createunit2(opc,pdev,printlist);
    }
}

static struct var_decls_unitrec * qc_parse_readsread(void) {
    int64 oldinreadprint;
    int64 opc;
    struct var_decls_unitrec *  pformat;
    struct var_decls_unitrec *  pdev;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  readlist;
    struct var_decls_unitrec *  readlistx;
    oldinreadprint = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64)1;
    opc = qc_lex_lx.subcode;
    qc_lex_lex();
    qc_parse_checksymbol((int64)12);
    qc_lex_lex();
    readlist = (readlistx = (struct var_decls_unitrec *)(0));
    pformat = (pdev = var_decls_nullunit);
    if ((qc_lex_lx.symbol == (int64)21)) {
        if ((opc == (int64)57)) {
            qc_support_serror((byte*)"@ on read");
        }
        qc_lex_lex();
        pdev = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_lex_lex();
        }
        else {
            goto L1089;
        }
    }
    if ((qc_lex_lx.symbol == (int64)13)) {
        goto L1089;
    }
L1090:;
    while (1) {
        p = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)7)) {
            qc_lex_lex();
            p = qc_lib_createunit2((int64)12,p,qc_parse_readexpression());
        }
        qc_parse_addlistunit(&readlist,&readlistx,p);
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1091;
        }
        qc_lex_lex();
    }
L1091:;
    qc_parse_checksymbol((int64)13);
//finish:
L1089:;
    qc_lex_lex();
    qc_parse_inreadprint = oldinreadprint;
    if (((opc == (int64)57) && (readlist == 0))) {
        qc_support_serror((byte*)"No read items");
    }
    return qc_lib_createunit2(opc,pdev,readlist);
}

static struct var_decls_unitrec * qc_parse_readcompilervar(void) {
    byte str[100];
    struct osnos_rsystemtime tm;
    static byte *  monthnames[12] =     {
    (byte*)"Jan",
    (byte*)"Feb",
    (byte*)"Mar",
    (byte*)"Apr",
    (byte*)"May",
    (byte*)"Jun",
    (byte*)"Jul",
    (byte*)"Aug",
    (byte*)"Sep",
    (byte*)"Oct",
    (byte*)"Nov",
    (byte*)"Dec"
};
    if ((qc_lex_lx.subcode==(int64)233)) {
        return qc_lib_createconstunit((uint64)(qc_lex_lx.lineno),(int64)1);
    } else if ((qc_lex_lx.subcode==(int64)234)) {
        sprintf(str,(byte*)"%d",qc_lex_lx.lineno);
    } else if ((qc_lex_lx.subcode==(int64)235)) {
        strcpy(str,var_decls_moduletable[(var_decls_currmoduleno)].name);
    } else if ((qc_lex_lx.subcode==(int64)236)) {
        strcpy(str,var_decls_moduletable[(var_decls_currmoduleno)].filename);
    } else if ((qc_lex_lx.subcode==(int64)237)) {
        strcpy(str,(!!(qc_parse_currproc)?(*qc_parse_currproc).name:(byte*)"<none>"));
    } else if ((qc_lex_lx.subcode==(int64)238)) {
        osnos_os_getsystime((void *)(&tm));
        sprintf(str,(byte*)"%d-%s-%4d",tm.day,monthnames[(tm.month)-1],tm.year);
    } else if ((qc_lex_lx.subcode==(int64)239)) {
        osnos_os_getsystime((void *)(&tm));
        sprintf(str,(byte*)"%2d:%02d:%02d",tm.hour,tm.minute,tm.second);
    }
    else {
        qc_support_serror((byte*)"compiler var not impl");
    }
    qc_lex_lex();
    return qc_lib_createstringconstunit(mlib_pcm_copyheapstring(str),(int64)-1);
}

static struct var_decls_unitrec * qc_parse_readcastx(void) {
    int64 opc;
    struct var_decls_unitrec *  pexpr;
    struct var_decls_unitrec *  p;
    int64 ptype;
    qc_lex_lex();
    if ((qc_lex_lx.symbol == (int64)21)) {
        qc_lex_lex();
        opc = (int64)148;
    }
    else {
        opc = (int64)147;
    }
    qc_parse_checksymbol((int64)12);
    qc_lex_lex();
    pexpr = qc_parse_readexpression();
    qc_parse_checksymbol((int64)5);
    qc_lex_lex();
    ptype = qc_parse_readtypespec((struct var_decls_strec *)(0),(int64)0);
    qc_parse_checksymbol((int64)13);
    qc_lex_lex();
    p = qc_lib_createunit1(opc,pexpr);
    (*p).valuemode = (int32)(ptype);
    return p;
}

void qc_parse_checksymbol(int64 symbol) {
    byte str[100];
    if ((qc_lex_lx.symbol != symbol)) {
        sprintf(str,(byte*)"%s expected, not %s",qc_tables_symbolnames[(symbol)-1],qc_tables_symbolnames[(qc_lex_lx.symbol)-1]);
        qc_support_serror(str);
    }
}

static int64 qc_parse_readtypespec(struct var_decls_strec * owner,int64 typedefx) {
    struct var_decls_strec *  d;
    int64 length;
    int64 lower;
    int64 upper;
    int64 t;
    int64 kwd;
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  pupper;
    struct var_decls_unitrec *  plx;
    int64 p;
    int64 lowerdims[10];
    int64 lengthdims[10];
    int64 ndims;
    int64 i;
    int64 n;
    if ((qc_lex_lx.symbol==(int64)14)) {
//arraybounds:
L1092:;
        qc_lex_lex();
        ndims = (int64)0;
        qc_parse_inreadprint = (int64)1;
L1093:;
        while (1) {
            lower = (int64)1;
            length = (int64)0;
            if (((qc_lex_lx.symbol == (int64)15) || (qc_lex_lx.symbol == (int64)5))) {
            }
            else {
                x = qc_parse_readconstexpr(owner,(int64)0);
                if (((int64)((*x).tag) == (int64)80)                ) {
                    qc_support_serror((byte*)"Array dims not constant");
                    lower = qc_lib_getrangelwb(x);
                    upper = qc_lib_getrangeupb(x);
                    length = ((upper - lower) + (int64)1);
                }
                else if ((((int64)((*x).tag) == (int64)1) && ((int64)((*x).valuemode) == (int64)4))) {
                    lower = (int64)((*x).range_lower);
                    upper = (int64)((*x).range_upper);
                    length = ((upper - lower) + (int64)1);
                }
                else {
                    if ((qc_lex_lx.symbol==(int64)15) || (qc_lex_lx.symbol==(int64)5)) {
                        if (!!(qc_parse_isconstexpr(x))) {
                            length = qc_lib_getconstvalue(x,(int64)0);
                        }
                        else {
                            qc_support_serror((byte*)"array1");
                        }
                    } else if ((qc_lex_lx.symbol==(int64)7)) {
                        lower = qc_lib_getconstvalue(x,(int64)0);
                        qc_lex_lex();
                        if (!(((qc_lex_lx.symbol == (int64)5) || (qc_lex_lx.symbol == (int64)15)))) {
                            length = qc_parse_readconstexprvalue(owner);
                        }
                    }
                }
            }
            lowerdims[(++ndims)-1] = lower;
            lengthdims[(ndims)-1] = length;
            if ((qc_lex_lx.symbol != (int64)5)) {
                goto L1094;
            }
            qc_lex_lex();
        }
L1094:;
        qc_parse_inreadprint = (int64)0;
        qc_parse_checksymbol((int64)15);
        qc_lex_lex();
        t = qc_parse_readtypespec(owner,(int64)0);
        qc_lib_checkpackedtype(t);
L1095:;
        for (i=ndims;i>=(int64)1;--i) {
L1096:;
            t = qc_lib_createarraymode(t,lowerdims[(i)-1],lengthdims[(i)-1],((i == (int64)1)?typedefx:(int64)0));
L1097:;
        }
L1098:;
        return t;
    } else if ((qc_lex_lx.symbol==(int64)48)) {
        t = qc_lex_lx.subcode;
        qc_lex_lex();
        if ((t==(int64)5) || (t==(int64)9) || (t==(int64)21)) {
            if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)105))) {
                qc_lex_lex();
                n = qc_parse_readconstexprvalue(owner);
                if ((n <= (int64)0)) {
                    qc_support_serror((byte*)"Bad *N");
                }
                p = qc_lib_createstringmode(t,n,typedefx);
            }
            else {
                p = t;
            }
        }
        else {
            p = t;
        }
    } else if ((qc_lex_lx.symbol==(int64)45)) {
        d = qc_parselib_px_typecheck(owner,qc_lex_lx.symptr,(int64)0);
        if ((d == 0)) {
            printf("%s\n",(char*)((*qc_lex_lx.symptr).name));
            qc_support_serror((byte*)"Unknown type");
        }
        if (((int64)((*d).mode) == (int64)0)) {
            p = qc_lib_createtype(d);
        }
        else {
            p = (int64)((*d).mode);
        }
        qc_lex_lex();
    } else if ((qc_lex_lx.symbol==(int64)97)) {
        p = (int64)35;
        qc_lex_lex();
    } else if ((qc_lex_lx.symbol==(int64)100)) {
        qc_lex_lex();
        p = qc_parse_readenumtype(owner,typedefx,(int64)0);
    } else if ((qc_lex_lx.symbol==(int64)12)) {
        p = qc_parse_readenumtype(owner,typedefx,(int64)0);
    } else if ((qc_lex_lx.symbol==(int64)86)) {
        qc_support_serror((byte*)"Use 'record name=', not 'type name=record'");
    } else if ((qc_lex_lx.symbol==(int64)87)) {
        kwd = qc_lex_lx.symbol;
        qc_lex_lex();
        if ((qc_lex_lx.symbol == (int64)22)) {
            if ((owner == 0)) {
                qc_support_serror((byte*)"record@@");
            }
            qc_lex_lex();
            qc_parse_checksymbol((int64)37);
            if ((qc_lex_lx.value==(int64)1) || (qc_lex_lx.value==(int64)2) || (qc_lex_lx.value==(int64)4) || (qc_lex_lx.value==(int64)8) || (qc_lex_lx.value==(int64)16)) {
            }
            else {
                qc_support_serror((byte*)"record@@ bad align");
            }
            (*owner).attribs.ax_align = (byte)(qc_lex_lx.value);
            qc_lex_lex();
        }
        p = qc_parse_readstructdef(owner,typedefx,kwd);
    } else if ((qc_lex_lx.symbol==(int64)88)) {
        qc_support_serror((byte*)"Top-level union not allowed");
    } else if ((qc_lex_lx.symbol==(int64)94)) {
        qc_lex_lex();
        if ((qc_lex_lx.symbol==(int64)83) || (qc_lex_lx.symbol==(int64)84) || (qc_lex_lx.symbol==(int64)85)) {
            qc_support_serror((byte*)"CAN'T DO REF PROC");
        }
        else {
            t = qc_parse_readtypespec(owner,(int64)0);
            qc_lib_checkpackedtype(t);
        }
        p = qc_lib_createrefpackmode(t,typedefx);
    }
    else {
        qc_support_serror((byte*)"Bad type starter");
    }
    return p;
}

static struct var_decls_unitrec * qc_parse_readhostparams(struct var_decls_unitrec * lhs,int64 isfn) {
    int64 fnindex;
    int64 oldinrp;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    fnindex = qc_lex_lx.subcode;
    qc_lex_lex();
    qc_parse_checksymbol((int64)12);
    qc_lex_lex();
    oldinrp = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64)0;
    q = qc_parse_readslist((int64)1,(int64)1);
    qc_parse_checksymbol((int64)13);
    qc_lex_lex();
    qc_parse_inreadprint = oldinrp;
    if (!!(lhs)) {
        (*lhs).nextunit = q;
        q = lhs;
    }
    p = qc_lib_createunit1((!!(isfn)?(int64)92:(int64)66),q);
    (*p).opcode = (int32)(fnindex);
    return p;
}

static struct var_decls_unitrec * qc_parse_readslist(int64 iscall,int64 donulls) {
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    int64 oldinparamlist;
    ulist = (ulistx = (struct var_decls_unitrec *)(0));
    qc_parse_skipsemi();
    if ((qc_lex_lx.symbol == (int64)13)) {
        return ulist;
    }
    oldinparamlist = qc_parse_inparamlist;
    qc_parse_inparamlist = iscall;
L1099:;
    while (1) {
        qc_parse_skipsemi();
        if ((qc_lex_lx.symbol==(int64)5)) {
            if (!!(donulls)) {
                qc_parse_addlistunit(&ulist,&ulistx,qc_lib_createunit0((int64)2));
            }
            else {
                qc_support_serror((byte*)"null comma expr not allowed");
            }
            qc_lex_lex();
        } else if ((qc_lex_lx.symbol==(int64)13)) {
            if (!!(donulls)) {
                qc_parse_addlistunit(&ulist,&ulistx,var_decls_nullunit);
            }
            goto L1100;
        }
        else {
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
            if ((qc_lex_lx.symbol == (int64)5)) {
                qc_lex_lex();
                if ((qc_lex_lx.symbol == (int64)13)) {
                    goto L1100;
                }
            }
            else {
                if (((qc_lex_lx.symbol == (int64)6) && (qc_lex_nextlx.symbol == (int64)13))) {
                    qc_lex_lex();
                }
                goto L1100;
            }
        }
    }
L1100:;
    qc_parse_inparamlist = oldinparamlist;
    return ulist;
}

static struct var_decls_unitrec * qc_parse_readindex(struct var_decls_unitrec * p,int64 dot) {
    struct var_decls_unitrec *  q;
    qc_lex_lex();
L1101:;
    while (1) {
        if ((qc_parse_ndollar >= (int64)10)) {
            qc_support_serror((byte*)"Too many nested a[$]");
        }
        qc_parse_dollarstack[(++qc_parse_ndollar)-1] = p;
        q = qc_parse_readexpression();
        --qc_parse_ndollar;
        if (((int64)((*q).tag) == (int64)80)) {
            p = qc_lib_createunit2((!!(dot)?(int64)134:(int64)129),p,q);
        }
        else {
            p = qc_lib_createunit2((!!(dot)?(int64)131:(int64)127),p,q);
        }
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1102;
        }
        qc_lex_lex();
    }
L1102:;
    qc_parse_checksymbol((int64)15);
    qc_lex_lex();
    return p;
}

static struct var_decls_unitrec * qc_parse_readkeyindex(struct var_decls_unitrec * p,int64 dot) {
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    qc_lex_lex();
    q = qc_parse_readexpression();
    r = (struct var_decls_unitrec *)(0);
    if ((qc_lex_lx.symbol == (int64)5)) {
        qc_lex_lex();
        r = qc_parse_readexpression();
    }
    qc_parse_checksymbol((int64)17);
    qc_lex_lex();
    return (p = qc_lib_createunit3((!!(dot)?(int64)135:(int64)130),p,q,r));
}

static struct var_decls_unitrec * qc_parse_readdotsuffix(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    int64 t;
L1103:;
    while ((qc_lex_lx.symbol == (int64)2)) {
        qc_lex_lex();
        switch (qc_lex_lx.symbol) {
        case 14:;
            p = qc_parse_readindex(p,(int64)1);
            break;
        case 16:;
            p = qc_parse_readkeyindex(p,(int64)1);
            break;
        case 45:;
            p = qc_lib_createunit2((int64)139,p,qc_lib_createname(qc_lex_lx.symptr));
            qc_parselib_px_dot(var_decls_stmodule,qc_parse_currproc,p);
            qc_lex_lex();
            break;
        case 31:;
            p = qc_lib_createunit1(qc_lex_lx.subcode,p);
            qc_parselib_evalmonop(p);
            qc_lex_lex();
            break;
        case 12:;
            qc_lex_lex();
            p = qc_lib_createunit2((int64)141,p,qc_parse_readexpression());
            qc_parse_checksymbol((int64)13);
            qc_lex_lex();
            break;
        case 92:;
            if (((int64)((*p).tag)==(int64)149)) {
            } else if (((int64)((*p).tag)==(int64)8)) {
                (*p).tag = (int32)149;
            }
            else {
                p = qc_lib_createunit1((int64)185,p);
            }
            qc_lex_lex();
            break;
        case 82:;
            p = qc_parse_readhostparams(p,(int64)1);
            break;
        case 48:;
            t = qc_lex_lx.subcode;
            qc_lex_lex();
            qc_parse_checksymbol((int64)14);
            qc_lex_lex();
            q = qc_parse_readexpression();
            qc_parse_checksymbol((int64)15);
            qc_lex_lex();
            if ((t==(int64)44) || (t==(int64)45) || (t==(int64)46)) {
            }
            else {
                qc_support_serror((byte*)"Bad .type[]");
            }
            p = qc_lib_createunit2((int64)138,p,q);
            (*p).valuemode = (int32)(t);
            break;
        default:;
            qc_support_serror((byte*)"Unknown dot suffix");
        }
L1104:;
    }
L1105:;
    return p;
}

int64 qc_parse_isconstexpr(struct var_decls_unitrec * p) {
    return (int64)(((int64)((*p).tag) == (int64)1));
}

static struct var_decls_unitrec * qc_parse_readconstexpr(struct var_decls_strec * owner,int64 needconst) {
    struct var_decls_unitrec *  p;
    p = qc_parse_readexpression();
    if ((needconst > (int64)0)) {
        if (((int64)((*p).tag) != (int64)1)) {
            printf("%s %s %s\n",(char*)(qc_tables_jtagnames[((int64)((*p).tag))]),(char*)(qc_tables_jtagnames[((int64)((*(*p).a).tag))]),(char*)(qc_tables_jtagnames[((int64)((*(*p).b).tag))]));
            qc_support_serror((byte*)"RCE:Not const expr");
        }
        if ((needconst == (int64)2)) {
            qc_support_serror((byte*)"RCE/NEEDCONST=2");
        }
    }
    return p;
}

static int64 qc_parse_readconstexprvalue(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    p = qc_parse_readexpression();
    if (((int64)((*p).tag) != (int64)1)) {
        qc_support_serror((byte*)"RCEV:Not const expr");
    }
    return qc_lib_getconstvalue(p,(int64)0);
}

static int64 qc_parse_readconstint(void) {
    int64 x;
    if ((qc_lex_lx.symbol == (int64)37)) {
        x = qc_lex_lx.value;
        qc_lex_lex();
        return x;
    }
    qc_support_serror((byte*)"Can't do complex expr");
    return (int64)0;
}

static void qc_parse_readprocdef(struct var_decls_strec * procowner,int64 isglobal,int64 fflang) {
    int64 kwd;
    int64 startline;
    int64 closesym;
    struct var_decls_strec *  stproc;
    struct var_decls_strec *  q;
    kwd = qc_lex_lx.symbol;
    stproc = qc_parse_readprocdecl(procowner,isglobal,fflang);
    qc_parse_checkequals();
    qc_lex_lex();
    startline = qc_parse_getcurrline();
    closesym = qc_parse_checkbegin((int64)0);
    qc_parse_currproc = stproc;
    qc_lib_nextavindex = (int64)0;
    (*stproc).code = qc_parse_readblock(stproc);
    if (!!((*var_decls_docstring).length)) {
        (*qc_parse_currproc).docstring = (*var_decls_docstring).strptr;
        mlib_gs_init(var_decls_docstring);
    }
    qc_parse_checkbeginend(closesym,kwd,startline);
    (*stproc).attribs.ax_equals = (uint8)1u;
    if (!!(qc_parse_labelseen)) {
        q = (*stproc).deflist;
L1106:;
        while (!!(q)) {
            if ((((int64)((*q).nameid) == (int64)16) && !!((*q).attribs.ax_forward))) {
                printf("%s %s %s\n",(char*)((*q).name),(char*)((byte*)"in"),(char*)((*qc_parse_currproc).name));
                qc_support_serror((byte*)"Label not defined");
            }
            q = (*q).nextdef;
L1107:;
        }
L1108:;
    }
    qc_parse_currproc = (struct var_decls_strec *)(0);
}

struct var_decls_strec * qc_parse_readprocdecl(struct var_decls_strec * procowner,int64 isglobal,int64 fflang) {
    int64 kwd;
    int64 varparams;
    int64 try_level;
    int64 prettype;
    int64 nparams;
    byte *  metadata;
    byte *  truename;
    struct var_decls_strec *  pequiv;
    struct var_decls_strec *  stproc;
    struct var_decls_strec *  owner;
    struct var_decls_strec *  paramlist;
    struct var_decls_strec *  nameptr;
    kwd = qc_lex_lx.symbol;
    pequiv = (struct var_decls_strec *)(0);
    metadata = (byte*)"";
    truename = (byte *)(0);
    varparams = (int64)0;
    try_level = (int64)0;
    qc_lex_lex();
    if ((qc_lex_lx.symbol == (int64)42)) {
        truename = mlib_pcm_copyheapstring(qc_lex_lx.svalue);
        mlib_convlcstring(qc_lex_lx.svalue);
        qc_lex_lx.symptr = qc_lex_addnamestr(qc_lex_lx.svalue);
    }
    else {
        qc_parse_checksymbol((int64)45);
    }
    nameptr = qc_lex_lx.symptr;
    stproc = qc_parse_createprocdef(procowner,nameptr,(((int64)((*procowner).nameid) == (int64)4)?(int64)7:(int64)6),truename);
    if (((qc_lib_getscope(procowner) != (int64)2) && ((int64)((*procowner).nameid) == (int64)5))) {
        qc_parse_addgenfield(nameptr);
    }
    owner = stproc;
    qc_parse_currproc = stproc;
    qc_lex_lex();
    if (((qc_lex_lx.symbol == (int64)45) && !!(mlib_eqstring((*qc_lex_lx.symptr).name,(byte*)"as")))) {
        qc_lex_lex();
        qc_parse_checksymbol((int64)45);
        qc_parse_addalias(stproc,qc_lex_lx.symptr);
        qc_lex_lex();
    }
    paramlist = (struct var_decls_strec *)(0);
    prettype = (int64)0;
    nparams = (int64)0;
    if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)98))) {
        if (((int64)((*stproc).nameid) == (int64)7)) {
            qc_support_serror((byte*)"Metadata on dllproc");
        }
        qc_lex_lex();
        qc_parse_checksymbol((int64)42);
        (*stproc).metadata = qc_lex_lx.svalue;
        qc_lex_lex();
        if (!(((qc_lex_lx.symbol == (int64)31) && ((qc_lex_lx.subcode == (int64)100) || (qc_lex_lx.subcode == (int64)101))))) {
            qc_support_serror((byte*)"\">\" expected");
        }
        if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)101))) {
            qc_lex_lx.subcode = (int64)96;
        }
        else {
            qc_lex_lex();
        }
    }
    if ((qc_lex_lx.symbol == (int64)12)    ) {
        qc_lex_lex();
        if ((qc_lex_lx.symbol != (int64)13)) {
            paramlist = qc_parse_readparams(stproc,fflang,&varparams,&nparams);
            qc_parse_checksymbol((int64)13);
        }
        qc_lex_lex();
        if (((qc_lex_lx.symbol == (int64)7) || (qc_lex_lx.symbol == (int64)11))        ) {
            qc_lex_lex();
            prettype = qc_parse_readtypespec(owner,(int64)0);
        }
        else if ((!!(var_decls_typestarterset[(qc_lex_lx.symbol)]) || (qc_lex_lx.symbol == (int64)45))) {
            prettype = qc_parse_readtypespec(owner,(int64)0);
        }
    }
    else if (((qc_lex_lx.symbol == (int64)7) || (qc_lex_lx.symbol == (int64)11))) {
        qc_lex_lex();
        prettype = qc_parse_readtypespec(owner,(int64)0);
    }
    if (!(((prettype != (int64)0) || ((kwd != (int64)84) && (kwd != (int64)85))))) {
        prettype = (int64)35;
    }
    if (((prettype != (int64)0) && ((kwd != (int64)84) && (kwd != (int64)85)))) {
        qc_support_serror((byte*)"Proc can't return value");
    }
    if ((((prettype != (int64)0) && (fflang != (int64)0)) && (fflang != (int64)3))    ) {
        qc_lib_checkdlltype(prettype);
    }
    else if (((prettype != (int64)0) && ((fflang == (int64)0) || (fflang == (int64)3)))) {
        qc_lib_checkunpackedtype(prettype);
    }
    (*stproc).paramlist = paramlist;
    (*stproc).attribs.ax_nparams = (byte)(nparams);
    (*stproc).mode = (int16)(prettype);
    if ((qc_lex_lx.symbol == (int64)21)) {
        qc_lex_lex();
        qc_parse_checksymbol((int64)45);
        qc_lex_lex();
        (*stproc).attribs.ax_at = (uint8)1u;
    }
    (*stproc).code = (struct var_decls_unitrec *)(0);
    if ((fflang==(int64)2) || (fflang==(int64)1) || (fflang==(int64)4)) {
        if (((int64)((*procowner).nameid) != (int64)4)) {
            printf("%s\n",(char*)((*stproc).name));
            qc_support_serror((byte*)"FF should be in dll import");
        }
    }
    else {
        if (((int64)((*procowner).nameid)==(int64)2) || ((int64)((*procowner).nameid)==(int64)3)) {
        } else if (((int64)((*procowner).nameid)==(int64)4)) {
            qc_support_serror((byte*)"Need FF specifier");
        }
    }
    (*stproc).attribs.ax_global = (byte)(isglobal);
    (*stproc).attribs.ax_varparams = (byte)(varparams);
    (*stproc).attribs.ax_fflang = (byte)(fflang);
    if ((((procowner == var_decls_stmodule) && (((int64)((*stproc).namelen) == (int64)5) && !!(mlib_eqstring((*stproc).name,(byte*)"start")))) || (((int64)((*stproc).namelen) == (int64)4) && !!(mlib_eqstring((*stproc).name,(byte*)"main"))))) {
        (*stproc).attribs.ax_global = (uint8)1u;
    }
    return stproc;
}

static struct var_decls_strec * qc_parse_readparams(struct var_decls_strec * owner,int64 fflang,int64 * varparams,int64 * inparams) {
    struct var_decls_strec *  stlist;
    struct var_decls_strec *  stlistx;
    struct var_decls_strec *  stname;
    struct var_decls_strec *  d;
    int64 foptional;
    int64 fbyref;
    int64 pmode;
    int64 fparam;
    int64 nparams;
    struct var_decls_unitrec *  pdefvalue;
    byte str[30];
    stlist = (stlistx = (struct var_decls_strec *)(0));
    foptional = (int64)0;
    fbyref = (int64)0;
    pdefvalue = (struct var_decls_unitrec *)(0);
    pmode = (int64)0;
    stname = (struct var_decls_strec *)(0);
    fparam = (int64)0;
    nparams = (int64)0;
    if ((fflang == (int64)0)) {
        fflang = (int64)3;
    }
L1109:;
    while (1) {
        switch (qc_lex_lx.symbol) {
        case 23:;
            if (!!(foptional)) {
                qc_support_serror((byte*)"??");
            }
            qc_lex_lex();
            foptional = (int64)1;
            break;
        case 24:;
            if (!!(fbyref)) {
                qc_support_serror((byte*)"& &");
            }
            qc_lex_lex();
            fbyref = (int64)1;
            break;
        case 48:;
        case 14:;
        case 97:;
        case 94:;
        case 100:;
        case 86:;
//dotype:
L1111:;
            pmode = qc_parse_readtypespec((struct var_decls_strec *)(0),(int64)0);
            if ((fflang != (int64)3)) {
//dotype2:
L1112:;
                qc_lib_checkdlltype(pmode);
            }
            else {
                qc_lib_checkunpackedtype(pmode);
            }
            fparam = (int64)1;
            break;
        case 45:;
            if ((fflang != (int64)3)) {
                d = qc_parselib_px_typecheck(owner,qc_lex_lx.symptr,(int64)0);
                if (!!(d)) {
                    pmode = (int64)((*d).mode);
                    qc_lex_lex();
                    goto L1112;
                }
            }
            if ((((int64)(var_decls_ttbasetype[(pmode)]) == (int64)0) && (fflang != (int64)3))) {
                qc_support_serror((byte*)"FF needs typed params");
            }
            if ((qc_lex_nextlx.symbol == (int64)45)) {
                goto L1111;
            }
            stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64)12);
            qc_lib_adddef(owner,stname);
            fparam = (int64)1;
            qc_lex_lex();
            break;
        case 5:;
        case 13:;
            if (!(!!(fparam))) {
                qc_support_serror((byte*)"No param");
            }
            ++nparams;
            if ((stname == 0)) {
                sprintf(str,(byte*)"$%d",nparams);
                stname = qc_lib_getduplnameptr(owner,qc_lex_addnamestr(str),(int64)12);
                qc_lib_adddef(owner,stname);
            }
            (*stname).mode = (((int64)(var_decls_ttbasetype[(pmode)]) == (int64)0)?(int16)35:(int16)(pmode));
            if (!!(fbyref)) {
                (*stname).attribs.ax_byrefmode = (uint8)1u;
            }
            if (!!(foptional)) {
                (*stname).attribs.ax_optional = (uint8)1u;
            }
            if ((pdefvalue != 0)) {
                (*stname).code = pdefvalue;
                (*stname).attribs.ax_equals = (uint8)1u;
            }
            qc_parse_addlistparam(&stlist,&stlistx,stname);
            if ((qc_lex_lx.symbol == (int64)13)) {
                goto L1110;
            }
            else {
                qc_lex_lex();
                fparam = (int64)0;
                stname = (struct var_decls_strec *)(0);
                pdefvalue = (struct var_decls_unitrec *)(0);
                fbyref = (foptional = (int64)0);
            }
            break;
        case 9:;
            qc_lex_lex();
            pdefvalue = qc_parse_readexpression();
            break;
        case 31:;
            if ((qc_lex_lx.subcode != (int64)96)) {
                qc_support_serror((byte*)"param op?");
            }
            qc_lex_lex();
            pdefvalue = qc_parse_readexpression();
            break;
        case 30:;
            if (!!(fparam)) {
                qc_support_serror((byte*)"... param");
            }
            (*varparams) = (int64)1;
            qc_lex_lex();
            qc_parse_checksymbol((int64)13);
            goto L1110;
            break;
        default:;
            printf("%s\n",(char*)(qc_tables_symbolnames[(qc_lex_lx.symbol)-1]));
            qc_support_serror((byte*)"param");
        }
    }
L1110:;
    (*inparams) = nparams;
    return stlist;
}

static struct var_decls_unitrec * qc_parse_readblock(struct var_decls_strec * owner) {
    int64 lineno;
    int64 globalflag;
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    struct var_decls_unitrec *  p;
    qc_parse_skipsemi();
    lineno = qc_lex_lx.lineno;
    ulist = (ulistx = (struct var_decls_unitrec *)(0));
L1113:;
    while (1) {
        switch (qc_lex_lx.symbol) {
        case 108:;
            qc_lex_lex();
            qc_parse_checksymbol((int64)97);
            qc_parse_readvardef(owner,(int64)0,(int64)1,(int64)10);
            break;
        case 83:;
        case 84:;
        case 85:;
            qc_parse_readprocdef(owner,(int64)0,(int64)0);
            globalflag = (int64)0;
            break;
        case 97:;
            qc_parse_readvardef(owner,(int64)0,(int64)0,(int64)11);
            break;
        case 92:;
            qc_parse_readtypedef(owner,(int64)0);
            break;
        case 96:;
            qc_parse_readconstdef(owner,(int64)0);
            break;
        case 102:;
        case 86:;
            qc_parse_readclassdef(owner,globalflag);
            globalflag = (int64)0;
            break;
        case 35:;
            mlib_gs_strn(var_decls_docstring,qc_lex_lx.svalue,qc_lex_lx.length);
            mlib_gs_line(var_decls_docstring);
            qc_lex_lex();
            break;
        case 100:;
            qc_lex_lex();
            qc_parse_readenumtype(owner,(int64)0,(int64)0);
            break;
        case 33:;
            printf("%s\n",(char*)((*owner).name));
            qc_support_serror((byte*)"Unexpected EOF in proc");
            break;
        case 13:;
        case 52:;
        case 53:;
        case 69:;
        case 61:;
        case 54:;
        case 55:;
        case 111:;
        case 57:;
        case 17:;
            goto L1114;
            break;
        case 6:;
            qc_lex_lex();
            break;
        default:;
            p = qc_parse_readexecstmt(owner);
            if ((((int64)(p) == (int64)1) || (p == 0))) {
                qc_support_serror((byte*)"READEXEC RETURNED 1 OR NIL");
            }
            qc_parse_addlistunit(&ulist,&ulistx,p);
        }
    }
L1114:;
    return qc_lib_createunit1((int64)4,ulist);
}

static struct var_decls_unitrec * qc_parse_readexecstmt(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_strec *  stname;
    switch (qc_lex_lx.symbol) {
    case 45:;
        if ((qc_lex_nextlx.symbol==(int64)7)) {
            stname = qc_parse_createlabel(qc_lex_lx.symptr,(int64)1);
            p = qc_lib_createunit0((int64)35);
            (*p).def = stname;
            (*p).trylevel = (int32)(qc_parse_try_level);
            (*stname).offset = (int32)(qc_parse_try_level);
            qc_lib_setnameptr(p);
            qc_lex_lex();
            qc_lex_lx.symbol = (int64)6;
        }
        else {
            p = qc_parse_readstmtexpr(owner);
        }
        break;
    case 74:;
        p = qc_parse_readgoto(owner,(int64)33);
        break;
    case 50:;
        p = qc_parse_readif(owner);
        break;
    case 58:;
        p = qc_parse_readunless(owner);
        break;
    case 59:;
    case 75:;
        p = qc_parse_readswitchcase(owner);
        break;
    case 60:;
    case 76:;
        ++var_decls_ndos;
        p = qc_parse_readswitchcase(owner);
        break;
    case 62:;
        ++var_decls_nfors;
        p = qc_parse_readfor(owner);
        break;
    case 63:;
        ++var_decls_nforalls;
        p = qc_parse_readforall(owner);
        break;
    case 64:;
        ++var_decls_ntos;
        p = qc_parse_readto(owner);
        break;
    case 66:;
        ++var_decls_ndos;
        p = qc_parse_readdo(owner);
        break;
    case 67:;
        ++var_decls_nwhiles;
        p = qc_parse_readwhile(owner);
        break;
    case 68:;
        ++var_decls_nrepeats;
        p = qc_parse_readrepeat(owner);
        break;
    case 72:;
        p = qc_parse_readloopcontrol(owner);
        break;
    case 70:;
        p = qc_parse_readreturn(owner);
        break;
    case 71:;
        p = qc_parse_readstop(owner);
        break;
    case 77:;
        p = qc_parse_readprint(owner);
        break;
    case 79:;
        p = qc_parse_readread(owner);
        break;
    case 110:;
        p = qc_parse_readtry(owner);
        break;
    case 113:;
        p = qc_parse_readraise(owner);
        break;
    case 31:;
        if (((qc_lex_lx.subcode == (int64)105) && (qc_lex_nextlx.symbol == (int64)12))) {
            qc_support_serror((byte*)"KTERM?");
        }
        else {
            p = qc_parse_readstmtexpr(owner);
        }
        break;
    case 128:;
        qc_lex_lex();
        qc_parse_checksymbol((int64)12);
        qc_lex_lex();
        p = qc_parse_readexpression();
        qc_parse_checksymbol((int64)5);
        qc_lex_lex();
        q = qc_parse_readexpression();
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
        p = qc_lib_createunit2((int64)46,p,q);
        break;
    case 12:;
    case 36:;
    case 80:;
    case 81:;
        p = qc_parse_readstmtexpr(owner);
        break;
    case 82:;
        p = qc_parse_readhostparams((struct var_decls_unitrec *)(0),(int64)0);
        break;
    case 121:;
        qc_lex_lex();
        p = qc_lib_createunit1((int64)67,qc_parse_readexpression());
        break;
    default:;
        printf("%s\n",(char*)(qc_tables_symbolnames[(qc_lex_lx.symbol)-1]));
        qc_support_serror((byte*)"Stmt error");
    }
    return p;
}

static struct var_decls_unitrec * qc_parse_readstmtexpr(struct var_decls_strec * owner) {
    int64 opc;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  ulist;
    struct var_decls_unitrec *  ulistx;
    if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_nextlx.symbol == (int64)9))) {
        opc = qc_lex_lx.subcode;
        if ((opc==(int64)104)) {
            opc = (int64)154;
        }
        qc_lex_lex();
        qc_lex_lex();
        return qc_lib_createunit1(qc_lib_getoptocode(opc),qc_parse_readterm());
    }
    p = qc_parse_readterm();
    if (((int64)((*p).tag)==(int64)207)) {
        (*p).tag = (int32)229;
    } else if (((int64)((*p).tag)==(int64)208)) {
        (*p).tag = (int32)230;
    } else if (((int64)((*p).tag)==(int64)209)) {
        (*p).tag = (int32)231;
    } else if (((int64)((*p).tag)==(int64)210)) {
        (*p).tag = (int32)232;
    }
    if ((qc_lex_lx.symbol==(int64)9)) {
        qc_lex_lex();
        q = qc_parse_readexpression();
        p = qc_lib_createunit2((int64)17,p,q);
        return qc_parse_readcondsuffix(p);
    } else if ((qc_lex_lx.symbol==(int64)10)) {
        qc_lex_lex();
        q = qc_parse_readexpression();
        p = qc_lib_createunit2((int64)19,p,q);
        return qc_parse_readcondsuffix(p);
    } else if ((qc_lex_lx.symbol==(int64)31)) {
        if ((qc_lex_nextlx.symbol == (int64)9)) {
            opc = qc_lib_getoptocode(qc_lex_lx.subcode);
            qc_lex_lex();
            qc_lex_lex();
            return qc_lib_createunit2(opc,p,qc_parse_readexpression());
        }
        else {
            qc_support_serror((byte*)"op expr not allowed as statement");
        }
    } else if ((qc_lex_lx.symbol==(int64)128)) {
        qc_lex_lex();
        return qc_lib_createunit2((int64)46,p,qc_parse_readterm());
    } else if ((qc_lex_lx.symbol==(int64)5)) {
        ulist = (ulistx = p);
        qc_parse_inmultexpr = (int64)1;
L1115:;
        do {
            qc_lex_lex();
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
L1116:;
        } while (!(qc_lex_lx.symbol != (int64)5));;
L1117:;
        qc_parse_inmultexpr = (int64)0;
        p = qc_lib_createunit1((int64)83,ulist);
        qc_parse_checksymbol((int64)9);
        qc_lex_lex();
        q = qc_parse_readexpression();
        if ((qc_lex_lx.symbol != (int64)5)) {
            qc_support_serror((byte*)"mult-expr expected after :=");
        }
        ulist = (ulistx = q);
L1118:;
        do {
            qc_lex_lex();
            qc_parse_addlistunit(&ulist,&ulistx,qc_parse_readexpression());
L1119:;
        } while (!(qc_lex_lx.symbol != (int64)5));;
L1120:;
        q = qc_lib_createunit1((int64)83,ulist);
        p = qc_lib_createunit2((int64)17,p,q);
        return p;
    }
    if (((int64)((*p).tag)==(int64)86)) {
        (*p).tag = (int32)17;
    } else if (((int64)((*p).tag)==(int64)87)) {
        (*p).tag = (int32)19;
    } else if (((int64)((*p).tag)==(int64)88)) {
        (*p).tag = (int32)14;
        p = qc_parse_readcondsuffix(p);
    } else if (((int64)((*p).tag)==(int64)89)) {
        (*p).tag = (int32)15;
        p = qc_parse_readcondsuffix(p);
    }
    else {
        if (((int64)((*p).tag)==(int64)229) || ((int64)((*p).tag)==(int64)230) || ((int64)((*p).tag)==(int64)231) || ((int64)((*p).tag)==(int64)232) || ((int64)((*p).tag)==(int64)14) || ((int64)((*p).tag)==(int64)59) || ((int64)((*p).tag)==(int64)60)) {
        }
        else {
            printf("%s\n",(char*)(qc_tables_jtagnames[((int64)((*p).tag))]));
            qc_support_serror((byte*)"Expression not allowed as statement");
        }
    }
    return p;
}

static struct var_decls_unitrec * qc_parse_readcondsuffix(struct var_decls_unitrec * p) {
    if ((qc_lex_lx.symbol==(int64)50) || (qc_lex_lx.symbol==(int64)61)) {
        qc_lex_lex();
        return qc_lib_createunit2((int64)21,qc_parse_readexpression(),qc_lib_createunit1((int64)4,p));
    } else if ((qc_lex_lx.symbol==(int64)58)) {
        qc_lex_lex();
        return qc_lib_createunit2((int64)21,qc_lib_createunit1((int64)75,qc_parse_readexpression()),qc_lib_createunit1((int64)4,p));
    }
    else {
        return p;
    }
    return (struct var_decls_unitrec *)(0);
}

static struct var_decls_unitrec * qc_parse_readif(struct var_decls_strec * owner) {
    int64 line;
    int64 kwd;
    int64 lineno;
    struct var_decls_unitrec *  pthen;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  plist;
    struct var_decls_unitrec *  plistx;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  pelsif;
    line = qc_lex_lx.lineno;
    kwd = qc_lex_lx.symbol;
    qc_lex_lex();
    pcond = qc_parse_readexpression();
    qc_parse_skipsemi();
    qc_parse_checksymbol((int64)51);
    qc_lex_lex();
    pthen = qc_parse_readblock(owner);
    if ((qc_lex_lx.symbol == (int64)52)) {
        lineno = qc_lex_lx.lineno;
        plist = (plistx = qc_lib_createunit2((int64)11,pcond,pthen));
L1121:;
        while ((qc_lex_lx.symbol == (int64)52)) {
            lineno = qc_lex_lx.lineno;
            qc_lex_lex();
            pcond = qc_parse_readexpression();
            qc_parse_checksymbol((int64)51);
            qc_lex_lex();
            pthen = qc_parse_readblock(owner);
            pelsif = qc_lib_createunit2((int64)11,pcond,pthen);
            (*pelsif).lineno = (int32)(lineno);
            qc_parse_addlistunit(&plist,&plistx,pelsif);
L1122:;
        }
L1123:;
        if ((qc_lex_lx.symbol==(int64)53)) {
            qc_lex_lex();
            pelse = qc_parse_readblock(owner);
            qc_parse_checkend((int64)57,kwd,(int64)0,(int64)0);
            qc_lex_lex();
        } else if ((qc_lex_lx.symbol==(int64)54) || (qc_lex_lx.symbol==(int64)55)) {
            qc_lex_lx.symbol = kwd;
            pelse = qc_parse_makeblock(qc_parse_readswitchcase(owner));
        }
        else {
            pelse = qc_lib_createunit0((int64)4);
            qc_parse_checkend((int64)57,kwd,(int64)0,(int64)0);
            qc_lex_lex();
        }
        p = qc_lib_createunit2((int64)22,plist,pelse);
        (*p).lineno = (int32)(line);
        return p;
    }
    if ((qc_lex_lx.symbol==(int64)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
        qc_parse_checkend((int64)57,kwd,(int64)0,(int64)0);
        qc_lex_lex();
    }
    else {
        pelse = qc_lib_createunit0((int64)4);
        qc_parse_checkend((int64)57,kwd,(int64)0,(int64)0);
        qc_lex_lex();
    }
    p = qc_lib_createunit3((int64)21,pcond,pthen,pelse);
    (*p).lineno = (int32)(line);
    return p;
}

static struct var_decls_unitrec * qc_parse_readgoto(struct var_decls_strec * owner,int64 gototag) {
    struct var_decls_strec *  d;
    struct var_decls_unitrec *  p;
    if ((qc_lex_lx.subcode == (int64)1)) {
        qc_lex_lex();
        qc_parse_checksymbol((int64)64);
    }
    qc_lex_lex();
    if (((((qc_lex_lx.symbol == (int64)45) && (qc_lex_nextlx.symbol != (int64)18)) && (qc_lex_nextlx.symbol != (int64)14)) && (qc_lex_nextlx.symbol != (int64)2))) {
        d = qc_parse_createlabel(qc_lex_lx.symptr,(int64)0);
        p = qc_lib_createname(d);
        qc_lex_lex();
    }
    else {
        qc_support_serror((byte*)"GOTO LABEL EXPR");
    }
    return qc_parse_readcondsuffix(qc_lib_createunit1(gototag,p));
}

static struct var_decls_unitrec * qc_parse_readunless(struct var_decls_strec * owner) {
    int64 line;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  pthen;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  p;
    line = qc_lex_lx.lineno;
    qc_lex_lex();
    pcond = qc_parse_readexpression();
    qc_parse_checksymbol((int64)51);
    qc_lex_lex();
    pthen = qc_parse_readblock(owner);
    if ((qc_lex_lx.symbol == (int64)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
    }
    else {
        pelse = qc_lib_createunit0((int64)4);
    }
    qc_parse_checkend((int64)57,(int64)58,(int64)0,(int64)0);
    qc_lex_lex();
    p = qc_lib_createunit3((int64)21,qc_lib_createunit1((int64)75,pcond),pthen,pelse);
    (*p).lineno = (int32)(line);
    return p;
}

static struct var_decls_unitrec * qc_parse_readswitchcase(struct var_decls_strec * owner) {
    int64 line;
    int64 kwd;
    int64 opc;
    int64 lineno;
    struct var_decls_unitrec *  pexpr;
    struct var_decls_unitrec *  pwhenlist;
    struct var_decls_unitrec *  pwhenlistx;
    struct var_decls_unitrec *  pwhen;
    struct var_decls_unitrec *  pwhenx;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  pthen;
    struct var_decls_unitrec *  pwhenthen;
    struct var_decls_unitrec *  q;
    line = qc_lex_lx.lineno;
    kwd = qc_lex_lx.symbol;
    opc = qc_lex_lx.subcode;
    qc_lex_lex();
    pexpr = qc_parse_readexpression();
    pwhenlist = (pwhenlistx = (struct var_decls_unitrec *)(0));
    qc_parse_skipsemi();
L1124:;
    while ((qc_lex_lx.symbol == (int64)61)) {
        lineno = qc_lex_lx.lineno;
        qc_lex_lex();
        pwhen = (pwhenx = (struct var_decls_unitrec *)(0));
L1127:;
        while (1) {
            p = qc_parse_readexpression();
            (*p).lineno = (int32)(lineno);
            qc_parse_addlistunit(&pwhen,&pwhenx,p);
            if ((qc_lex_lx.symbol != (int64)5)) {
                goto L1128;
            }
            qc_lex_lex();
        }
L1128:;
        qc_parse_checksymbol((int64)51);
        qc_lex_lex();
        pthen = qc_parse_readblock(owner);
        pwhenthen = qc_lib_createunit2((int64)10,pwhen,pthen);
        (*pwhenthen).lineno = (int32)(lineno);
        qc_parse_addlistunit(&pwhenlist,&pwhenlistx,pwhenthen);
L1125:;
    }
L1126:;
    if ((qc_lex_lx.symbol==(int64)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
        qc_parse_checkend((int64)57,kwd,(int64)0,(int64)0);
        qc_lex_lex();
    } else if ((qc_lex_lx.symbol==(int64)52)) {
        qc_lex_lx.symbol = kwd;
        pelse = qc_parse_makeblock(qc_parse_readif(owner));
    } else if ((qc_lex_lx.symbol==(int64)54) || (qc_lex_lx.symbol==(int64)55)) {
        qc_lex_lx.symbol = kwd;
        pelse = qc_parse_makeblock(qc_parse_readswitchcase(owner));
    }
    else {
        pelse = qc_parse_makeblock((struct var_decls_unitrec *)(0));
        qc_parse_checkend((int64)57,kwd,(int64)0,(int64)0);
        qc_lex_lex();
    }
    p = qc_lib_createunit3(opc,pexpr,pwhenlist,pelse);
    (*p).lineno = (int32)(line);
    return p;
}

static struct var_decls_unitrec * qc_parse_readstop(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    int64 i;
    qc_lex_lex();
    if (!!(var_decls_exprstarterset[(qc_lex_lx.symbol)])) {
        p = qc_lib_createunit1((int64)61,qc_parse_readexpression());
    }
    else {
        p = qc_lib_createunit0((int64)61);
    }
    return qc_parse_readcondsuffix(p);
}

static struct var_decls_unitrec * qc_parse_readreturn(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    qc_lex_lex();
    if (!!(var_decls_exprstarterset[(qc_lex_lx.symbol)])) {
        p = qc_lib_createunit1((int64)16,qc_parse_readexpression());
    }
    else {
        p = qc_lib_createunit0((int64)16);
    }
    return qc_parse_readcondsuffix(p);
}

static struct var_decls_unitrec * qc_parse_readdo(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    int64 line;
    line = qc_lex_lx.lineno;
    qc_lex_lex();
    p = qc_parse_readblock(owner);
    qc_parse_checkend((int64)57,(int64)66,(int64)0,(int64)0);
    qc_lex_lex();
    p = qc_lib_createunit1((int64)41,p);
    (*p).lineno = (int32)(line);
    return p;
}

static struct var_decls_unitrec * qc_parse_readto(struct var_decls_strec * owner) {
    int64 line;
    int64 id;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  pcount;
    struct var_decls_unitrec *  pbody;
    line = qc_lex_lx.lineno;
    qc_lex_lex();
    pcount = qc_parse_readexpression();
    qc_parse_checksymbol((int64)66);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    qc_parse_checkend((int64)57,(int64)64,(int64)66,(int64)0);
    qc_lex_lex();
    id = (int64)11;
    if (((int64)((*owner).nameid) != (int64)6)) {
        id = (int64)10;
    }
    p = qc_lib_createunit3((int64)20,pcount,pbody,qc_lib_createname(qc_lib_getavname(owner,id)));
    (*p).lineno = (int32)(line);
    return p;
}

static struct var_decls_unitrec * qc_parse_readwhile(struct var_decls_strec * owner) {
    int64 line;
    int64 id;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  pa;
    struct var_decls_unitrec *  pb;
    struct var_decls_unitrec *  pc;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  p;
    line = qc_lex_lx.lineno;
    qc_lex_lex();
    pcond = qc_parse_readexpression();
    if ((qc_lex_lx.symbol == (int64)5)) {
        qc_parse_convertstmtexpr(pcond);
        pa = pcond;
        qc_lex_lex();
        pb = qc_parse_readexpression();
        qc_parse_checksymbol((int64)5);
        qc_lex_lex();
        pc = qc_parse_readstmtexpr(owner);
        qc_parse_checksymbol((int64)66);
        qc_lex_lex();
        pbody = qc_parse_readblock(owner);
        qc_parse_checkend((int64)57,(int64)67,(int64)66,(int64)0);
        qc_lex_lex();
        (*pa).nextunit = pb;
        (*pb).nextunit = pc;
        p = qc_lib_createunit2((int64)30,pa,pbody);
        (*p).lineno = (int32)(line);
        return p;
    }
    qc_parse_checksymbol((int64)66);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    qc_parse_checkend((int64)57,(int64)67,(int64)66,(int64)0);
    qc_lex_lex();
    p = qc_lib_createunit2((int64)31,pcond,pbody);
    (*p).lineno = (int32)(line);
    return p;
}

static struct var_decls_unitrec * qc_parse_readrepeat(struct var_decls_strec * owner) {
    int64 line;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  p;
    line = qc_lex_lx.lineno;
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    qc_parse_checksymbol((int64)69);
    qc_lex_lex();
    pcond = qc_parse_readexpression();
    p = qc_lib_createunit2((int64)32,pbody,pcond);
    (*p).lineno = (int32)(line);
    return p;
}

static struct var_decls_unitrec * qc_parse_readloopcontrol(struct var_decls_strec * owner) {
    int64 opc;
    struct var_decls_unitrec *  p;
    opc = qc_lex_lx.subcode;
    qc_lex_lex();
    if (((qc_lex_lx.symbol == (int64)45) && !!(mlib_eqstring((*qc_lex_lx.symptr).name,(byte*)"all")))    ) {
        qc_lex_lex();
        p = qc_lib_createunit1(opc,qc_lib_createconstunit((uint64)((int64)0),(int64)1));
    }
    else if (!!(var_decls_exprstarterset[(qc_lex_lx.symbol)])) {
        p = qc_lib_createunit1(opc,qc_parse_readconstexpr(owner,(int64)1));
    }
    else {
        p = qc_lib_createunit0(opc);
    }
    return qc_parse_readcondsuffix(p);
}

static struct var_decls_unitrec * qc_parse_readprint(struct var_decls_strec * owner) {
    int64 oldinreadprint;
    int64 opc;
    int64 isfprint;
    int64 fshowname;
    int64 length;
    struct var_decls_unitrec *  pformat;
    struct var_decls_unitrec *  pdev;
    struct var_decls_unitrec *  printlist;
    struct var_decls_unitrec *  printlistx;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  q;
    struct mlib_strbuffer *  expr;
    byte *  s;
    oldinreadprint = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64)1;
    opc = qc_lex_lx.subcode;
    if ((opc==(int64)50) || (opc==(int64)51) || (opc==(int64)52) || (opc==(int64)53)) {
        isfprint = (int64)1;
    }
    else {
        isfprint = (int64)0;
    }
    qc_lex_lex();
    printlist = (printlistx = (struct var_decls_unitrec *)(0));
    pformat = (pdev = (struct var_decls_unitrec *)(0));
    if ((qc_lex_lx.symbol == (int64)21)) {
        qc_lex_lex();
        pdev = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_lex_lex();
        }
        else {
            goto L1129;
        }
    }
    if (!!(isfprint)) {
        if ((!(!!(var_decls_exprstarterset[(qc_lex_lx.symbol)])) && (opc == (int64)53))) {
            goto L1129;
        }
        pformat = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_lex_lex();
        }
        else {
            goto L1129;
        }
    }
    if (!(!!(var_decls_exprstarterset[(qc_lex_lx.symbol)]))) {
        goto L1129;
    }
L1130:;
    while (1) {
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_parse_addlistunit(&printlist,&printlistx,qc_lib_createunit0((int64)13));
        }
        else {
            fshowname = (int64)0;
            if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)96))) {
                fshowname = (int64)1;
                qc_lex_lex();
            }
            p = qc_parse_readexpression();
            if ((qc_lex_lx.symbol == (int64)7)) {
                qc_lex_lex();
                p = qc_lib_createunit2((int64)12,p,qc_parse_readexpression());
            }
            if (!!(fshowname)) {
                expr = qc_lib_strexpr(p);
                length = (int64)((*expr).length);
                mlib_strbuffer_add(expr,(byte*)"=?",(int64)-1);
                s = (*expr).strptr;
                mlib_iconvucn(s,length);
                (*((s + length) + (int64)1)) = (uint8)0u;
                qc_parse_addlistunit(&printlist,&printlistx,(q = qc_lib_createstringconstunit(s,(int64)-1)));
            }
            qc_parse_addlistunit(&printlist,&printlistx,p);
        }
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1131;
        }
        qc_lex_lex();
    }
L1131:;
//finish:
L1129:;
    qc_parse_inreadprint = oldinreadprint;
    if (((opc == (int64)48) && (printlist == 0))) {
        qc_support_serror((byte*)"No print items");
    }
    if ((((opc == (int64)50) && (printlist == 0)) && (pformat == 0))) {
        qc_support_serror((byte*)"No print items");
    }
    if ((((opc == (int64)52) && (printlist == 0)) && (pformat == 0))) {
        qc_support_serror((byte*)"No cprint items");
    }
    if (!!(isfprint)) {
        if (((pformat == 0) && (opc != (int64)53))) {
            qc_support_serror((byte*)"No fmt str");
        }
        return qc_lib_createunit3(opc,pdev,pformat,printlist);
    }
    else {
        return qc_lib_createunit2(opc,pdev,printlist);
    }
}

static struct var_decls_unitrec * qc_parse_readread(struct var_decls_strec * owner) {
    int64 oldinreadprint;
    int64 opc;
    struct var_decls_unitrec *  pformat;
    struct var_decls_unitrec *  pdev;
    struct var_decls_unitrec *  readlist;
    struct var_decls_unitrec *  readlistx;
    struct var_decls_unitrec *  p;
    oldinreadprint = qc_parse_inreadprint;
    qc_parse_inreadprint = (int64)1;
    opc = qc_lex_lx.subcode;
    qc_lex_lex();
    readlist = (readlistx = (struct var_decls_unitrec *)(0));
    pformat = (pdev = (struct var_decls_unitrec *)(0));
    if ((qc_lex_lx.symbol == (int64)21)) {
        if ((opc == (int64)57)) {
            qc_support_serror((byte*)"@ on read");
        }
        qc_lex_lex();
        pdev = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_lex_lex();
        }
        else {
            goto L1132;
        }
    }
    if (!(!!(var_decls_exprstarterset[(qc_lex_lx.symbol)]))) {
        goto L1132;
    }
L1133:;
    while (1) {
        p = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)7)) {
            qc_lex_lex();
            p = qc_lib_createunit2((int64)12,p,qc_parse_readexpression());
        }
        qc_parse_addlistunit(&readlist,&readlistx,p);
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1134;
        }
        qc_lex_lex();
    }
L1134:;
//finish:
L1132:;
    qc_parse_inreadprint = oldinreadprint;
    if (((opc == (int64)57) && (readlist == 0))) {
        qc_support_serror((byte*)"No read items");
    }
    return qc_lib_createunit2(opc,pdev,readlist);
}

static struct var_decls_unitrec * qc_parse_readtry(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  ptry;
    struct var_decls_unitrec *  pexceptlist;
    struct var_decls_unitrec *  pexceptlistx;
    struct var_decls_unitrec *  px;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  exlist;
    struct var_decls_unitrec *  exlistx;
    ++qc_parse_try_level;
    qc_lex_lex();
    ptry = qc_parse_readblock(owner);
    pexceptlist = (pexceptlistx = (struct var_decls_unitrec *)(0));
L1135:;
    while ((qc_lex_lx.symbol == (int64)111)) {
        qc_lex_lex();
        exlist = (exlistx = (struct var_decls_unitrec *)(0));
L1138:;
        while (1) {
            qc_parse_addlistunit(&exlist,&exlistx,qc_parse_readconstexpr(owner,(int64)1));
            if ((qc_lex_lx.symbol != (int64)5)) {
                goto L1139;
            }
            qc_lex_lex();
        }
L1139:;
        qc_parse_checksymbol((int64)51);
        qc_lex_lex();
        px = qc_parse_readblock(owner);
        qc_parse_addlistunit(&pexceptlist,&pexceptlistx,qc_lib_createunit2((int64)63,exlist,px));
L1136:;
    }
L1137:;
    qc_parse_checkend((int64)57,(int64)110,(int64)0,(int64)0);
    qc_lex_lex();
    --qc_parse_try_level;
    return qc_lib_createunit2((int64)62,ptry,pexceptlist);
}

static struct var_decls_unitrec * qc_parse_readraise(struct var_decls_strec * owner) {
    struct var_decls_unitrec *  p;
    qc_lex_lex();
    p = qc_parse_readexpression();
    return qc_lib_createunit1((int64)65,p);
}

static struct var_decls_unitrec * qc_parse_readfor(struct var_decls_strec * owner) {
    int64 line;
    int64 opc;
    int64 down;
    struct var_decls_unitrec *  pstep;
    struct var_decls_unitrec *  pvar;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  pfrom;
    struct var_decls_unitrec *  pto;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  prange;
    struct var_decls_unitrec *  prangex;
    struct var_decls_unitrec *  pautovar;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  p;
    struct mlib_strbuffer *  s;
    line = qc_lex_lx.lineno;
    qc_lex_lex();
    pvar = qc_parse_readterm();
    if (((int64)((*pvar).tag) != (int64)3)) {
        qc_support_serror((byte*)"For: name expected");
    }
    opc = (int64)23;
    pstep = (struct var_decls_unitrec *)(0);
    pcond = (struct var_decls_unitrec *)(0);
    if ((qc_lex_lx.symbol == (int64)31)) {
        if ((qc_lex_lx.subcode == (int64)119)        ) {
            down = (int64)24;
        }
        else if ((qc_lex_lx.subcode != (int64)117)) {
            qc_support_serror((byte*)"in/inrev expected");
        }
        qc_lex_lex();
        prange = qc_parse_readexpression();
        pfrom = qc_lib_getrangelwbunit(prange);
        pto = qc_lib_getrangeupbunit(prange);
    }
    else {
        if ((qc_lex_lx.symbol == (int64)9)) {
            qc_lex_lex();
            pfrom = qc_parse_readexpression();
        }
        else {
            pfrom = qc_lib_createconstunit((uint64)((int64)1),(int64)1);
        }
        qc_parse_checksymbol((int64)64);
        opc = ((qc_lex_lx.subcode == (int64)1)?(int64)24:(int64)23);
        qc_lex_lex();
        pto = qc_parse_readexpression();
        if ((qc_lex_lx.symbol == (int64)65)) {
            if ((opc == (int64)24)) {
                qc_support_serror((byte*)"downto/by");
            }
            opc = (int64)25;
            qc_lex_lex();
            pstep = qc_parse_readconstexpr(owner,(int64)0);
            if ((((int64)((*pstep).tag) == (int64)1) && ((*pstep).value == (int64)1))            ) {
                opc = (int64)23;
                pstep = (struct var_decls_unitrec *)(0);
            }
            else if ((((int64)((*pstep).tag) == (int64)1) && ((*pstep).value == (int64)-1))) {
                opc = (int64)24;
                pstep = (struct var_decls_unitrec *)(0);
            }
        }
        else {
            pstep = (struct var_decls_unitrec *)(0);
        }
    }
    if ((qc_lex_lx.symbol == (int64)61)) {
        qc_lex_lex();
        pcond = qc_parse_readexpression();
    }
    qc_parse_checksymbol((int64)66);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    if ((qc_lex_lx.symbol == (int64)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
    }
    else {
        pelse = (struct var_decls_unitrec *)(0);
    }
    qc_parse_checkend((int64)57,(int64)62,(int64)66,(int64)0);
    qc_lex_lex();
    if ((pcond != 0)) {
        pbody = qc_parse_makeblock(qc_lib_createunit2((int64)21,pcond,pbody));
    }
    pautovar = (struct var_decls_unitrec *)(0);
    if (!((((int64)((*pto).tag) == (int64)1) || (((int64)((*pto).tag) == (int64)3) && !!((*(*pto).def).attribs.ax_frame))))) {
        if ((opc == (int64)25)) {
            qc_support_serror((byte*)"for: 'by' uses complex limit");
        }
        pautovar = qc_lib_createname(qc_lib_getavname(owner,(int64)11));
    }
    (*pvar).nextunit = pfrom;
    (*pfrom).nextunit = pto;
    (*pto).nextunit = pstep;
    (*pbody).nextunit = pelse;
    p = qc_lib_createunit3(opc,pvar,pbody,pautovar);
    (*p).lineno = (int32)(line);
    return p;
}

static struct var_decls_unitrec * qc_parse_readforall(struct var_decls_strec * owner) {
    int64 opc;
    int64 line;
    int64 isforall;
    struct var_decls_unitrec *  pindex;
    struct var_decls_unitrec *  pvar;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  plist;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  pfor;
    struct var_decls_unitrec *  pautovar;
    line = qc_lex_lx.lineno;
    opc = qc_lex_lx.subcode;
    isforall = (int64)((opc == (int64)26));
    qc_lex_lex();
    pvar = qc_parse_readterm();
    pindex = (struct var_decls_unitrec *)(0);
    if ((qc_lex_lx.symbol == (int64)5)) {
        qc_lex_lex();
        pindex = pvar;
        pvar = qc_parse_readterm();
        if ((((int64)((*pindex).tag) != (int64)3) || !(!!((*(*pindex).def).attribs.ax_frame)))) {
            qc_support_serror((byte*)"forall var not simple local name");
        }
    }
    if (((int64)((*pvar).tag) != (int64)3)) {
        qc_support_serror((byte*)"forall var not name");
    }
    pcond = (struct var_decls_unitrec *)(0);
    if (((qc_lex_lx.symbol == (int64)31) && ((qc_lex_lx.subcode == (int64)117) || (qc_lex_lx.subcode == (int64)119)))) {
        if ((qc_lex_lx.subcode == (int64)119)) {
            opc = ((opc == (int64)26)?(int64)27:(int64)29);
        }
        qc_lex_lex();
        plist = qc_parse_readexpression();
    }
    else {
        qc_support_serror((byte*)"in/inrev expected");
    }
    if ((qc_lex_lx.symbol == (int64)61)) {
        qc_lex_lex();
        pcond = qc_parse_readexpression();
    }
    qc_parse_checksymbol((int64)66);
    qc_lex_lex();
    pbody = qc_parse_readblock(owner);
    if ((qc_lex_lx.symbol == (int64)53)) {
        qc_lex_lex();
        pelse = qc_parse_readblock(owner);
    }
    else {
        pelse = (struct var_decls_unitrec *)(0);
    }
    qc_parse_checkend((int64)57,(int64)63,(int64)66,(int64)0);
    qc_lex_lex();
    if ((pindex == 0)) {
        pindex = qc_lib_createname(qc_lib_getavname(owner,(int64)11));
    }
    if ((pcond != 0)) {
        pbody = qc_lib_createunit2((int64)21,pcond,pbody);
        (*pbody).lineno = (int32)(line);
    }
    pautovar = qc_lib_createname(qc_lib_getavname(qc_parse_currproc,(int64)11));
    (*pindex).nextunit = pvar;
    (*pvar).nextunit = plist;
    (*pbody).nextunit = pelse;
    pfor = qc_lib_createunit3(opc,pindex,pbody,pautovar);
    (*pfor).lineno = (int32)(line);
    return pfor;
}

void qc_parse_readtypedef(struct var_decls_strec * owner,int64 isglobal) {
    struct var_decls_strec *  sttype;
    struct var_decls_strec *  stname;
    int64 t;
    int64 m;
    qc_lex_lex();
    qc_parse_checksymbol((int64)45);
    stname = qc_lex_lx.symptr;
    qc_lex_lex();
    qc_parse_checkequals();
    qc_lex_lex();
    sttype = qc_parselib_px_typecheck(owner,stname,(int64)0);
    if ((sttype == 0)) {
        sttype = qc_lib_getduplnameptr(owner,stname,(int64)5);
        qc_lib_adddef(owner,sttype);
        m = qc_lib_createusertype(sttype);
    }
    else {
        m = (int64)((*sttype).mode);
    }
    t = qc_parse_readtypespec(sttype,m);
    (*sttype).attribs.ax_global = (byte)(isglobal);
    (*sttype).mode = (int16)(t);
}

static int64 qc_parse_readstructdef(struct var_decls_strec * owner,int64 typedefx,int64 kwd) {
    int64 m;
    int64 startline;
    int64 closesym;
    int64 t;
    struct var_decls_strec *  recordowner;
    struct var_decls_strec *  d;
    recordowner = owner;
    if (!(!!(typedefx))) {
        if ((qc_lex_lx.symbol == (int64)45)) {
            owner = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64)5);
            qc_lex_lex();
            qc_parse_checkequals();
            qc_lex_lex();
        }
        else {
            owner = qc_lib_getduplnameptr(var_decls_stmodule,qc_lex_addnamestr(qc_lib_nextautotype()),(int64)5);
        }
        qc_lib_adddef(recordowner,owner);
        qc_parse_checksymbol((int64)12);
        qc_lex_lex();
    }
    else {
        owner = var_decls_ttnamedef[(typedefx)];
        startline = qc_parse_getcurrline();
        closesym = qc_parse_checkbegin((int64)1);
    }
    m = qc_lib_createrecordmode(owner,(int64)33,typedefx);
    (*owner).mode = (int16)(m);
    qc_lib_unionstr_clear(&qc_parse_unionstring);
    qc_lib_unionstr_clear(&qc_parse_unionpend);
L1140:;
    while (1) {
        if ((qc_lex_lx.symbol == (int64)45)) {
            d = qc_parselib_px_typecheck(owner,qc_lex_lx.symptr,(int64)0);
            if (!!(d)) {
                qc_lex_lex();
                qc_parse_readstructfields(owner,(int64)((*d).mode));
                goto L1140;
            }
        }
        if ((qc_lex_lx.symbol==(int64)87) || (qc_lex_lx.symbol==(int64)88)) {
            qc_lib_unionstr_append(&qc_parse_unionpend,((qc_lex_lx.symbol == (int64)87)?(int64)83:(int64)85));
            qc_parse_unionlastvar = (struct var_decls_strec *)(0);
            qc_lex_lex();
        } else if ((qc_lex_lx.symbol==(int64)57)) {
            if (!!(qc_parse_unionstring.ulength)) {
                qc_parse_checkend((int64)57,((qc_lib_unionstr_last(&qc_parse_unionstring) == (int64)83)?(int64)87:(int64)88),(int64)0,(int64)0);
                qc_lex_lex();
                if (((qc_parse_unionlastvar == 0) || !!(qc_parse_unionpend.ulength))) {
                    qc_support_serror((byte*)"Empty union group");
                }
                if ((qc_lib_unionstr_last(&(*qc_parse_unionlastvar).uflags)==(int64)69) || (qc_lib_unionstr_last(&(*qc_parse_unionlastvar).uflags)==(int64)42)) {
                }
                else {
                    qc_lib_unionstr_append(&(*qc_parse_unionlastvar).uflags,(int64)42);
                }
                qc_lib_unionstr_append(&(*qc_parse_unionlastvar).uflags,(int64)69);
                --qc_parse_unionstring.ulength;
            }
            else {
                goto L1141;
            }
        } else if ((qc_lex_lx.symbol==(int64)6)) {
            qc_lex_lex();
        }
        else {
            if (!!(var_decls_typestarterset[(qc_lex_lx.symbol)])) {
                t = qc_parse_readtypespec(owner,(int64)0);
                qc_lib_checkpackedtype(t);
                qc_parse_readstructfields(owner,t);
            }
            else {
                goto L1141;
            }
        }
    }
L1141:;
    if (!(!!(typedefx))) {
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
    }
    else {
        qc_parse_checkbeginend(closesym,kwd,startline);
    }
    return m;
}

void qc_parse_readstructfields(struct var_decls_strec * owner,int64 m) {
    int64 nvars;
    struct var_decls_strec *  stname;
    nvars = (int64)0;
L1142:;
    while ((qc_lex_lx.symbol == (int64)45)) {
        stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64)13);
        (*stname).mode = (int16)(m);
        ++nvars;
        if (!!(qc_parse_unionpend.ulength)) {
            qc_lib_unionstr_copy(&(*stname).uflags,&qc_parse_unionpend);
            qc_lib_unionstr_concat(&qc_parse_unionstring,&qc_parse_unionpend);
            qc_lib_unionstr_clear(&qc_parse_unionpend);
        }
        else {
            qc_lib_unionstr_clear(&(*stname).uflags);
        }
        qc_parse_unionlastvar = stname;
        if ((qc_lib_getscope(owner) != (int64)2)) {
            qc_parse_addgenfield(qc_lex_lx.symptr);
        }
        qc_lib_adddef(owner,stname);
        qc_lex_lex();
        if ((qc_lex_lx.symbol == (int64)21)        ) {
            qc_lex_lex();
            (*stname).attribs.ax_at = (uint8)1u;
            (*stname).equiv = qc_parse_readequivfield(owner);
        }
        else if ((qc_lex_lx.symbol == (int64)22)) {
            qc_lex_lex();
            qc_parse_checksymbol((int64)37);
            if ((qc_lex_lx.value==(int64)1) || (qc_lex_lx.value==(int64)2) || (qc_lex_lx.value==(int64)4) || (qc_lex_lx.value==(int64)8)) {
                (*stname).attribs.ax_align = (byte)(qc_lex_lx.value);
            } else if ((qc_lex_lx.value==(int64)0)) {
                (*stname).attribs.ax_align = (uint8)255u;
            }
            else {
                qc_support_serror((byte*)"@@ bad align");
            }
            qc_lex_lex();
        }
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1144;
        }
        qc_lex_lex();
L1143:;
    }
L1144:;
    if ((nvars == (int64)0)) {
        qc_support_serror((byte*)"No fields declared");
    }
}

void qc_parse_readtabledef(struct var_decls_strec * owner,int64 isglobal) {
    int64 i;
    int64 ncols;
    int64 nrows;
    int64 enums;
    int64 nextenumvalue;
    int64 firstval;
    int64 lastval;
    int64 startline;
    int64 closesym;
    int64 vartype;
    struct var_decls_unitrec *  plower;
    byte *  enumtypename;
    struct var_decls_strec *  stvar;
    struct var_decls_strec *  stenum;
    struct var_decls_strec *  stgen;
    struct var_decls_strec *  varnameptrs[20];
    struct var_decls_unitrec *  plist[20];
    struct var_decls_unitrec *  plistx[20];
    int64 enumvalues[500];
    qc_lex_lex();
    enums = (int64)0;
    enumtypename = (byte *)(0);
    if ((qc_lex_lx.symbol == (int64)12)) {
        enums = (int64)1;
        qc_lex_lex();
        if ((qc_lex_lx.symbol == (int64)45)) {
            enumtypename = (*qc_lex_lx.symptr).name;
            qc_lex_lex();
        }
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
    }
    nextenumvalue = (int64)1;
    nrows = (int64)0;
    ncols = (int64)0;
L1145:;
    while ((qc_lex_lx.symbol == (int64)45)) {
        if ((++ncols > (int64)20)) {
            qc_support_serror((byte*)"tabledata/too many columns");
        }
        varnameptrs[(ncols)-1] = qc_lex_lx.symptr;
        qc_lex_lex();
        if ((qc_lex_lx.symbol == (int64)5)) {
            qc_lex_lex();
        }
        else {
            goto L1147;
        }
L1146:;
    }
L1147:;
    qc_parse_checkequals();
    qc_lex_lex();
    qc_parse_skipsemi();
    startline = qc_parse_getcurrline();
    closesym = qc_parse_checkbegin((int64)0);
    qc_parse_skipsemi();
    firstval = (lastval = (int64)0);
L1148:;
    for (i=(int64)1;i<=ncols;++i) {
L1149:;
        plist[(i)-1] = (plistx[(i)-1] = (struct var_decls_unitrec *)(0));
L1150:;
    }
L1151:;
    qc_parse_intabledata = (int64)1;
L1152:;
    while (1) {
        qc_parse_skipsemi();
        qc_parse_checksymbol((int64)12);
        qc_lex_lex();
        if ((++nrows > (int64)500)) {
            qc_support_serror((byte*)"tabledata:too many rows");
        }
        if (!!(enums)) {
            qc_parse_checksymbol((int64)45);
            stgen = qc_lex_lx.symptr;
            qc_parse_tabledataname = (*stgen).name;
            qc_lex_lex();
            if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)96))) {
                qc_lex_lex();
                nextenumvalue = qc_parse_readconstint();
            }
            enumvalues[(nrows)-1] = nextenumvalue;
            stenum = qc_lib_getduplnameptr(owner,stgen,(int64)9);
            (*stenum).mode = (int16)1;
            (*stenum).code = qc_lib_createconstunit((uint64)(nextenumvalue),(int64)1);
            (*stenum).attribs.ax_global = (byte)(isglobal);
            qc_lib_adddef(owner,stenum);
            if ((nrows == (int64)1)) {
                firstval = nextenumvalue;
            }
            lastval = nextenumvalue;
            ++nextenumvalue;
            if (!!(ncols)) {
                qc_parse_checksymbol((int64)5);
            }
            qc_lex_lex();
        }
L1154:;
        for (i=(int64)1;i<=ncols;++i) {
L1155:;
            qc_parse_addlistunit(&plist[(i)-1],&plistx[(i)-1],qc_parse_readexpression());
            if ((i == ncols)) {
                qc_parse_checksymbol((int64)13);
            }
            else {
                qc_parse_checksymbol((int64)5);
            }
            qc_lex_lex();
L1156:;
        }
L1157:;
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1153;
        }
        qc_lex_lex();
        if ((qc_lex_lx.symbol == closesym)) {
            goto L1153;
        }
    }
L1153:;
    qc_parse_intabledata = (int64)0;
    qc_parse_skipsemi();
    qc_parse_checkbeginend(closesym,(int64)122,startline);
    if ((nrows == (int64)0)) {
        qc_support_serror((byte*)"No table data");
    }
    vartype = (int64)35;
L1158:;
    for (i=(int64)1;i<=ncols;++i) {
L1159:;
        stvar = qc_lib_getduplnameptr(owner,varnameptrs[(i)-1],(int64)10);
        if (!!(enums)) {
            plower = qc_lib_createconstunit((uint64)(enumvalues[((int64)1)-1]),(int64)1);
        }
        else {
            plower = (struct var_decls_unitrec *)(0);
        }
        (*stvar).code = qc_lib_createunit2((int64)77,plist[(i)-1],plower);
        (*stvar).attribs.ax_global = (byte)(isglobal);
        qc_lib_adddef(owner,stvar);
L1160:;
    }
L1161:;
}

void qc_parse_readclassdef(struct var_decls_strec * owner,int64 isglobal) {
    int64 kwd;
    int64 baseclass;
    int64 m;
    int64 startline;
    int64 closesym;
    int64 mrec;
    int64 normalexit;
    struct var_decls_strec *  nameptr;
    struct var_decls_strec *  sttype;
    struct var_decls_strec *  newd;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    kwd = qc_lex_lx.symbol;
    qc_lex_lex();
    qc_parse_checksymbol((int64)45);
    nameptr = qc_lex_lx.symptr;
    qc_lex_lex();
    baseclass = (int64)0;
    if ((qc_lex_lx.symbol == (int64)12)) {
        qc_lex_lex();
        baseclass = qc_parse_readtypespec(owner,(int64)0);
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
    }
    qc_parse_checkequals();
    qc_lex_lex();
    sttype = qc_lib_getduplnameptr(owner,nameptr,(int64)5);
    qc_lib_adddef(owner,sttype);
    m = qc_lib_createusertype(sttype);
    mrec = qc_lib_createrecordmode(owner,(int64)32,m);
    (*sttype).mode = (int16)(mrec);
    (*sttype).attribs.ax_baseclass = ((baseclass < (int64)255)?(byte)(baseclass):(uint8)255u);
    closesym = qc_parse_checkbegin((int64)1);
    startline = qc_parse_getcurrline();
    qc_parse_readclassbody(sttype,kwd);
    qc_parse_checkbeginend(closesym,kwd,startline);
    if (!!(baseclass)) {
        d = (*var_decls_ttnamedef[(baseclass)]).deflist;
L1162:;
        while (!!(d)) {
            e = (*sttype).deflist;
            normalexit = (int64)1;
L1165:;
            while (!!(e)) {
                if (!!(mlib_eqstring((*d).name,(*e).name))) {
                    normalexit = (int64)0;
                    goto L1167;
                }
                e = (*e).nextdef;
L1166:;
            }
L1167:;
            if (!!(normalexit)) {
                if (((int64)((*d).nameid)==(int64)6) || ((int64)((*d).nameid)==(int64)19)) {
                    newd = qc_lib_getduplnameptr(sttype,d,(int64)19);
                    (*newd).equiv = d;
                }
                else {
                    newd = qc_lib_getduplnameptr(sttype,d,(int64)((*d).nameid));
                    qc_parse_duplfield(d,newd);
                }
                qc_lib_adddef(sttype,newd);
            }
            d = (*d).nextdef;
L1163:;
        }
L1164:;
    }
    (*sttype).attribs.ax_global = (byte)(isglobal);
}

static void qc_parse_readclassbody(struct var_decls_strec * owner,int64 classkwd) {
    int64 kwd;
L1168:;
    switch (qc_lex_lx.symbol) {
    case 96:;
        qc_parse_readconstdef(owner,(int64)0);
        break;
    case 97:;
        qc_parse_readrecordfields(owner);
        break;
    case 85:;
    case 84:;
    case 83:;
        kwd = qc_lex_lx.symbol;
        if ((qc_lib_getscope(owner) == (int64)2)) {
            qc_parse_readprocdecl(owner,(int64)0,(int64)0);
        }
        else {
            qc_parse_readprocdef(owner,(int64)0,(int64)0);
        }
        break;
    case 102:;
        qc_lex_lex();
        qc_support_serror((byte*)"CLASS CLASS");
        break;
    case 86:;
        qc_lex_lex();
        qc_support_serror((byte*)"CLASS RECORD");
        break;
    case 92:;
        qc_lex_lex();
        qc_support_serror((byte*)"CLASS TYPE");
        break;
    case 57:;
    case 13:;
    case 17:;
        goto L1169;
        break;
    case 33:;
        qc_support_serror((byte*)"Class eof?");
        goto L1169;
        break;
    case 6:;
        qc_lex_lex();
        break;
    default:;
        qc_lex_ps((byte*)"symbol");
        if (!!(var_decls_typestarterset[(qc_lex_lx.symbol)])) {
            qc_support_serror((byte*)"Packed types not allowed in class");
        }
        else {
            qc_support_serror((byte*)"Unknown class decl");
        }
    }
    goto L1168;
L1169:;
}

static int64 qc_parse_readenumtype(struct var_decls_strec * owner,int64 typedefx,int64 isglobal) {
    struct var_decls_strec *  enumowner;
    struct var_decls_strec *  stname;
    struct var_decls_strec *  nameptr;
    int64 isanon;
    int64 index;
    int64 startline;
    int64 closesym;
    enumowner = owner;
    isanon = (int64)0;
    if (!(!!(typedefx))) {
        if ((qc_lex_lx.symbol == (int64)45)) {
            stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64)5);
            owner = stname;
            qc_lex_lex();
            qc_parse_checkequals();
            qc_lex_lex();
            qc_lib_adddef(enumowner,owner);
        }
        else {
            isanon = (int64)1;
        }
        qc_parse_checksymbol((int64)12);
        qc_lex_lex();
    }
    else {
        owner = var_decls_ttnamedef[(typedefx)];
        startline = qc_parse_getcurrline();
        closesym = qc_parse_checkbegin((int64)1);
    }
    index = (int64)1;
L1170:;
    while ((qc_lex_lx.symbol == (int64)45)) {
        nameptr = qc_lex_lx.symptr;
        qc_lex_lex();
        if (((qc_lex_lx.symbol == (int64)31) && (qc_lex_lx.subcode == (int64)96))) {
            qc_lex_lex();
            index = qc_parse_readconstint();
        }
        if (!(!!(isanon))) {
            stname = qc_lib_getduplnameptr(owner,nameptr,(int64)15);
            (*stname).index = (int32)(index);
            (*stname).mode = (int16)1;
            qc_lib_adddef(owner,stname);
        }
        else {
            stname = qc_lib_getduplnameptr(enumowner,nameptr,(int64)9);
            (*stname).code = qc_lib_createconstunit((uint64)(index),(int64)1);
            (*stname).mode = (int16)1;
            qc_lib_adddef(enumowner,stname);
        }
        ++index;
        (*stname).attribs.ax_global = (byte)(isglobal);
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1172;
        }
        qc_lex_lex();
L1171:;
    }
L1172:;
    if (!(!!(typedefx))) {
        qc_parse_checksymbol((int64)13);
        qc_lex_lex();
    }
    else {
        qc_parse_checkbeginend(closesym,(int64)100,startline);
    }
    if (!(!!(isanon))) {
        return qc_lib_createenummode(owner,typedefx);
    }
    else {
        return (int64)0;
    }
}

static void qc_parse_duplfield(struct var_decls_strec * p,struct var_decls_strec * q) {
    if (!!((*p).code)) {
        qc_support_serror((byte*)"DUPLFIELD");
    }
    (*q).attribs = (*p).attribs;
    (*q).address = (*p).address;
    (*q).uflags = (*p).uflags;
    (*q).mode = (*p).mode;
}

void qc_parse_readrecordfields(struct var_decls_strec * owner) {
    int64 m;
    int64 nvars;
    struct var_decls_strec *  stname;
    qc_lex_lex();
    m = (int64)35;
    nvars = (int64)0;
L1173:;
    while ((qc_lex_lx.symbol == (int64)45)) {
        stname = qc_lib_getduplnameptr(owner,qc_lex_lx.symptr,(int64)13);
        (*stname).mode = (int16)(m);
        ++nvars;
        if ((qc_lib_getscope(owner) != (int64)2)) {
            qc_parse_addgenfield(qc_lex_lx.symptr);
        }
        qc_lib_adddef(owner,stname);
        qc_lex_lex();
        if ((qc_lex_lx.symbol == (int64)21)) {
            qc_lex_lex();
            (*stname).attribs.ax_at = (uint8)1u;
            (*stname).equiv = qc_parse_readequivfield(owner);
        }
        if ((qc_lex_lx.symbol != (int64)5)) {
            goto L1175;
        }
        qc_lex_lex();
L1174:;
    }
L1175:;
    if ((nvars == (int64)0)) {
        qc_support_serror((byte*)"No fields declared");
    }
}

static void qc_parse_readimportmodule(struct var_decls_strec * owner) {
    int64 isnew;
    int64 startline;
    int64 closesym;
    struct var_decls_strec *  d;
    struct var_decls_strec *  stname;
    struct var_decls_strec *  stname0;
    qc_lex_lex();
    if ((qc_lex_lx.symbol == (int64)42)) {
        stname = qc_lex_addnamestr(qc_lex_lx.svalue);
    }
    else {
        qc_parse_checksymbol((int64)45);
        stname = qc_lex_lx.symptr;
    }
    qc_lex_lex();
    qc_parse_checkequals();
    qc_lex_lex();
    isnew = (int64)1;
    d = (*stname).nextdupl;
L1176:;
    while (!!(d)) {
        if (((int64)((*d).nameid) == (int64)4)) {
            stname = d;
            isnew = (int64)0;
            goto L1178;
        }
        d = (*d).nextdupl;
L1177:;
    }
L1178:;
    if (!!(isnew)) {
        stname = qc_lib_getduplnameptr(var_decls_stprogram,stname,(int64)4);
        if (!!(mlib_eqstring((*stname).name,(byte*)"sys"))) {
            var_decls_stsysmodule = stname;
        }
        qc_lib_adddef(var_decls_stprogram,stname);
        if ((var_decls_ndlltable >= (int64)50)) {
            qc_support_serror((byte*)"Too many DLL libs");
        }
        var_decls_dlltable[(++var_decls_ndlltable)-1] = (*stname).name;
        (*stname).attribs.ax_dllindex = (byte)(var_decls_ndlltable);
    }
    else {
    }
    startline = qc_parse_getcurrline();
    closesym = qc_parse_checkbegin((int64)0);
    qc_parse_readimportbody(stname);
    qc_parse_checkbeginend(closesym,(int64)90,startline);
}

static void qc_parse_readimportbody(struct var_decls_strec * owner) {
    int64 lineno;
    int64 fflang;
    lineno = qc_lex_lx.lineno;
L1179:;
    while (1) {
        qc_parse_skipsemi();
        switch (qc_lex_lx.symbol) {
        case 106:;
            fflang = qc_lex_lx.subcode;
            qc_lex_lex();
            if ((qc_lex_lx.symbol==(int64)83) || (qc_lex_lx.symbol==(int64)84) || (qc_lex_lx.symbol==(int64)85)) {
                qc_parse_readprocdecl(owner,(int64)0,fflang);
            }
            break;
        case 83:;
        case 84:;
        case 85:;
            qc_parse_readprocdecl(owner,(int64)0,(int64)0);
            break;
        case 97:;
            qc_parse_readvardef(owner,(int64)0,(int64)0,(int64)10);
            break;
        case 92:;
            qc_parse_readtypedef(owner,(int64)0);
            break;
        case 96:;
            qc_parse_readconstdef(owner,(int64)0);
            break;
        case 102:;
        case 86:;
            qc_parse_readclassdef(owner,(int64)0);
            break;
        case 33:;
            goto L1180;
            break;
        case 57:;
            goto L1180;
            break;
        default:;
            qc_lex_ps1((byte*)"symbol");
            qc_support_serror((byte*)"Not allowed in importmodule");
        }
    }
L1180:;
}

static struct var_decls_strec * qc_parse_createlabel(struct var_decls_strec * stname,int64 islabeldef) {
    struct var_decls_strec *  d;
    qc_parse_labelseen = (int64)1;
    d = qc_parselib_finddupl(qc_parse_currproc,(*stname).nextdupl);
    if (!!(d)) {
        if (((int64)((*d).nameid) != (int64)16)) {
            qc_support_serror((byte*)"Not a label");
        }
        if (!!(islabeldef)) {
            if (!(!!((*d).attribs.ax_forward))) {
                printf("%s\n",(char*)((*d).name));
                qc_support_serror((byte*)"Dupl label");
            }
            (*d).attribs.ax_forward = (uint8)0u;
        }
    }
    else {
        d = qc_lib_getduplnameptr(qc_parse_currproc,stname,(int64)16);
        qc_lib_adddef_nodupl(qc_parse_currproc,d);
        if (!(!!(islabeldef))) {
            (*d).attribs.ax_forward = (uint8)1u;
        }
    }
    return d;
}

static struct var_decls_strec * qc_parse_createprocdef(struct var_decls_strec * owner,struct var_decls_strec * stname,int64 id,byte * truename) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    struct var_decls_procrec *  pp;
    struct var_decls_unitrec *  u;
    d = qc_parselib_finddupl(owner,(*stname).nextdupl);
    if (!!(d)) {
        if ((((int64)((*d).nameid) != (int64)6) && ((int64)((*d).nameid) != (int64)7))) {
            printf("%s %s\n",(char*)((*d).name),(char*)(pq_common_namenames[((int64)((*d).nameid))]));
            qc_support_serror((byte*)"def:Not a proc");
        }
        if (!(!!((*d).attribs.ax_forward))) {
            printf("%s\n",(char*)((*d).name));
            qc_support_serror((byte*)"Dupl proc");
        }
        qc_lib_addtoproclist(d);
        (*d).attribs.ax_forward = (uint8)0u;
    }
    else {
        d = qc_lib_getduplnameptr(owner,stname,id);
        qc_lib_adddef_nodupl(owner,d);
        qc_lib_addtoproclist(d);
        (*d).index = (int32)0;
        if ((id == (int64)7)) {
            if ((var_decls_ndllproctable >= (int64)500)) {
                qc_support_serror((byte*)"Too many DLL procs");
            }
            ++var_decls_ndllproctable;
            if (!(!!(truename))) {
                truename = (*d).name;
            }
            (*d).truename = truename;
            var_decls_dllproctable[(var_decls_ndllproctable)-1].name = truename;
            var_decls_dllproctable[(var_decls_ndllproctable)-1].dllindex = (int32)((*owner).attribs.ax_dllindex);
            (*d).index = (int32)(var_decls_ndllproctable);
        }
        else {
            e = (*stname).nextdupl;
L1181:;
            while (!!(e)) {
                if ((((int64)((*e).nameid) == (int64)6) && !!((*e).callchain))) {
                    u = (*e).callchain;
L1184:;
                    do {
                        if (((int64)((*u).tag) != (int64)3)) {
                            qc_support_serror((byte*)"CPD1");
                        }
                        (*u).def = d;
                        u = (*u).c;
L1185:;
                    } while (!(u == 0));;
L1186:;
                }
                e = (*e).nextdupl;
L1182:;
            }
L1183:;
        }
    }
    return d;
}

static void qc_parse_createproccall(struct var_decls_strec * owner,struct var_decls_strec * stname,struct var_decls_unitrec * p) {
    struct var_decls_strec *  d;
    d = qc_parselib_resolvetopname(owner,stname,(int64)0);
    if (!!(d)) {
//retry:
L1187:;
        if (((int64)((*d).nameid)==(int64)6)) {
            if (((int64)((*(*d).owner).nameid) == (int64)3)) {
                if (!!((*d).callchain)) {
                    if (((int64)((*d).attribs.ax_extmodno) != var_decls_currmoduleno)) {
                        (*d).callchain = (struct var_decls_unitrec *)(0);
                    }
                }
                (*p).c = (*d).callchain;
                (*d).callchain = p;
                (*d).attribs.ax_extmodno = (byte)(var_decls_currmoduleno);
            }
        } else if (((int64)((*d).nameid)==(int64)7)) {
        } else if (((int64)((*d).nameid)==(int64)5)) {
        } else if (((int64)((*d).nameid)==(int64)18)) {
            d = (*d).equiv;
            goto L1187;
        }
        else {
            printf("%s\n",(char*)(pq_common_namenames[((int64)((*d).nameid))]));
            qc_support_serror((byte*)"call:Not a proc");
        }
    }
    else {
        d = qc_lib_getduplnameptr(owner,stname,(int64)6);
        qc_lib_adddef_nodupl(owner,d);
        (*d).attribs.ax_forward = (uint8)1u;
    }
    (*p).def = d;
}

static struct var_decls_strec * qc_parse_readequivfield(struct var_decls_strec * owner) {
    struct var_decls_strec *  p;
    struct var_decls_strec *  d;
    qc_parse_checksymbol((int64)45);
    d = qc_lex_lx.symptr;
    qc_lex_lex();
    p = (*owner).deflist;
L1188:;
    while (!!(p)) {
        if (!!(mlib_eqstring((*p).name,(*d).name))) {
            return p;
        }
        p = (*p).nextdef;
L1189:;
    }
L1190:;
    printf("%s\n",(char*)((*d).name));
    qc_support_serror((byte*)"Can't find @ field");
    return (struct var_decls_strec *)(0);
}

static struct var_decls_unitrec * qc_parse_testconstruct(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  paramlist;
    struct var_decls_unitrec *  r;
    struct var_decls_strec *  d;
    int64 mode;
    q = (*p).a;
    d = (*q).def;
    if (!((((int64)((*q).tag) == (int64)3) && ((int64)((*d).nameid) == (int64)5)))) {
        return p;
    }
    paramlist = (*p).b;
    mode = (int64)((*d).mode);
    (*p).tag = (int32)78;
    (*p).a = paramlist;
    (*p).b = (struct var_decls_unitrec *)(0);
    r = qc_lib_createunit1((int64)147,p);
    (*r).valuemode = (int32)(mode);
    return r;
}

static struct var_decls_unitrec * qc_parse_readapplyop(int64 inexpr) {
    struct var_decls_unitrec *  p;
    struct var_decls_unitrec *  a;
    struct var_decls_unitrec *  b;
    qc_lex_lex();
    qc_parse_checksymbol((int64)12);
    qc_lex_lex();
    p = qc_parse_readexpression();
    qc_parse_checksymbol((int64)5);
    qc_lex_lex();
    a = qc_parse_readexpression();
    b = (struct var_decls_unitrec *)(0);
    if ((qc_lex_lx.symbol == (int64)5)) {
        qc_lex_lex();
        b = qc_parse_readexpression();
    }
    qc_parse_checksymbol((int64)13);
    qc_lex_lex();
    return qc_lib_createunit3((!!(inexpr)?(int64)94:(int64)93),p,a,b);
}

static struct var_decls_strec * qc_lib_newstrec(void) {
    struct var_decls_strec *  p;
    p = (struct var_decls_strec *)(mlib_pcm_alloc((int64)128));
    memset((void *)(p),(int32)0,(uint64)((int64)128));
    (*p).lineno = (int32)(qc_lex_lx.lineno);
    (*p).attribs.ax_moduleno = (byte)(var_decls_currmoduleno);
    return p;
}

void qc_lib_initqclib(void) {
    int64 i;
    int64 av_1;
    int64 av_2;
    int64 av_3;
L1191:;
    for (i=(int64)1;i<=(int64)36;++i) {
L1192:;
        qc_tables_jtagpriotable[(qc_tables_oplist[(i)-1])] = (byte)(qc_tables_oppriolist[(i)-1]);
L1193:;
    }
L1194:;
L1195:;
    for (i=(int64)1;i<=(int64)23;++i) {
L1196:;
        var_decls_exprstarterset[(qc_tables_d_exprstarterset[(i)-1])] = (uint8)1u;
L1197:;
    }
L1198:;
L1199:;
    for (i=(int64)1;i<=(int64)6;++i) {
L1200:;
        var_decls_typestarterset[(qc_tables_d_typestarterset[(i)-1])] = (uint8)1u;
L1201:;
    }
L1202:;
    qc_tables_hostlvset[((int64)22)] = (uint8)1u;
    qc_tables_hostlvset[((int64)23)] = (uint8)1u;
    qc_tables_condopset[((int64)96)] = (uint8)1u;
    qc_tables_condopset[((int64)97)] = (uint8)1u;
    qc_tables_condopset[((int64)98)] = (uint8)1u;
    qc_tables_condopset[((int64)99)] = (uint8)1u;
    qc_tables_condopset[((int64)101)] = (uint8)1u;
    qc_tables_condopset[((int64)100)] = (uint8)1u;
}

struct var_decls_strec * qc_lib_getduplnameptr(struct var_decls_strec * owner,struct var_decls_strec * symptr,int64 id) {
    struct var_decls_strec *  p;
    struct var_decls_strec *  q;
    p = qc_lib_newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (*symptr).namelen;
    (*p).symbol = (uint8)45u;
    (*p).owner = owner;
    (*p).nameid = (byte)(id);
    if (((id == (int64)11) || (id == (int64)12))) {
        (*p).attribs.ax_frame = (uint8)1u;
    }
    if (!!((q = (*symptr).nextdupl))) {
        (*q).prevdupl = p;
    }
    (*p).nextdupl = q;
    (*p).prevdupl = symptr;
    (*symptr).nextdupl = p;
    return p;
}

void qc_lib_adddef(struct var_decls_strec * owner,struct var_decls_strec * p) {
    struct var_decls_strec *  q;
    q = p;
L1203:;
    while (!!((q = (*q).nextdupl))) {
        if (((*q).owner == owner)) {
            printf("%s %s %s\n",(char*)((*q).name),(char*)((byte*)"in"),(char*)((*owner).name));
            qc_support_serror((byte*)"Duplicate name");
        }
L1204:;
    }
L1205:;
    (*p).nextdef = (*owner).deflist;
    (*owner).deflist = p;
}

void qc_lib_adddef_nodupl(struct var_decls_strec * owner,struct var_decls_strec * p) {
    (*p).nextdef = (*owner).deflist;
    (*owner).deflist = p;
}

void qc_lib_printst(void * f,struct var_decls_strec * p,int64 level) {
    struct var_decls_strec *  q;
    if (((int64)((*p).symbol) != (int64)45)) {
        printf("%s\n",(char*)((byte*)"PRINTST not name\n\n\n"));
        exit(0);
    }
    qc_lib_printstrec(f,p,level);
    q = (*p).deflist;
L1206:;
    while ((q != 0)) {
        qc_lib_printst(f,q,(level + (int64)1));
        q = (*q).nextdef;
L1207:;
    }
L1208:;
}

static void qc_lib_printstrec(void * f,struct var_decls_strec * p,int64 level) {
    struct var_decls_attribrec attrs;
    byte *  q;
    struct mlib_strbuffer v;
    struct mlib_strbuffer *  d = &v;
    int64 col;
    int64 offset;
    int64 t;
    byte str[256];
    int64 av_1;
    mlib_gs_init(d);
    offset = (int64)0;
    av_1 = level;
    while (av_1-- > 0) {
L1209:;
        mlib_gs_str(d,(byte*)"    ");
        offset += (int64)4;
L1210:;
    }
L1211:;
    mlib_gs_str(d,(byte*)":");
    mlib_gs_leftstr(d,(*p).name,((int64)28 - offset),(int64)45);
    mlib_gs_leftstr(d,pq_common_namenames[((int64)((*p).nameid))],(int64)12,(int64)46);
    col = mlib_gs_getcol(d);
    attrs = (*p).attribs;
    mlib_gs_str(d,(byte*)"[");
    if ((qc_lib_getscope(p)==(int64)1)) {
        mlib_gs_str(d,(byte*)"Loc ");
    } else if ((qc_lib_getscope(p)==(int64)3)) {
        mlib_gs_str(d,(byte*)"Glob ");
    } else if ((qc_lib_getscope(p)==(int64)2)) {
        mlib_gs_str(d,(byte*)"Ext ");
    }
    if (!!(attrs.ax_static)) {
        mlib_gs_str(d,(byte*)"Stat");
    }
    if (!!(attrs.ax_fflang)) {
        mlib_gs_strsp(d,qc_tables_fflangnames[((int64)(attrs.ax_fflang))]);
    }
    if (!!(attrs.ax_byrefmode)) {
        mlib_gs_str(d,(byte*)"byref ");
    }
    if (!!(attrs.ax_align)) {
        mlib_gs_str(d,(byte*)"@@");
        mlib_gs_strint(d,(int64)(attrs.ax_align));
        mlib_gs_str(d,(byte*)" ");
    }
    if (!!(attrs.ax_optional)) {
        mlib_gs_str(d,(byte*)"Opt ");
    }
    if (!!(attrs.ax_varparams)) {
        mlib_gs_str(d,(byte*)"Var ");
    }
    if (!!(attrs.ax_used)) {
        mlib_gs_str(d,(byte*)"Used ");
    }
    if (!!(attrs.ax_forward)) {
        mlib_gs_str(d,(byte*)"Fwd ");
    }
    if (!!(attrs.ax_frame)) {
        mlib_gs_str(d,(byte*)"Frm ");
    }
    if (!!(attrs.ax_autovar)) {
        mlib_gs_str(d,(byte*)"AV ");
    }
    if (!!(attrs.ax_nparams)) {
        sprintf(str,(byte*)"Pm:%d ",attrs.ax_nparams);
        mlib_gs_str(d,str);
    }
    if (!!(attrs.ax_moduleno)) {
        sprintf(str,(byte*)"Modno#%d ",attrs.ax_moduleno);
        mlib_gs_str(d,str);
    }
    mlib_gs_str(d,(byte*)"]");
    mlib_gs_padto(d,(col + (int64)10),(int64)61);
    if (!!((*p).owner)) {
        sprintf(str,(byte*)"(%s)",(*(*p).owner).name);
        mlib_gs_leftstr(d,str,(int64)18,(int64)43);
    }
    else {
        mlib_gs_leftstr(d,(byte*)"()",(int64)18,(int64)43);
    }
    if (((int64)((*p).mode)==(int64)0)) {
        mlib_gs_str(d,(byte*)"Void ");
    } else if (((int64)((*p).mode)==(int64)35)) {
        mlib_gs_str(d,(byte*)"Var ");
    }
    else {
        mlib_gs_strsp(d,qc_lib_strmode((int64)((*p).mode),(int64)1));
    }
    if (((int64)((*p).nameid)==(int64)13) || ((int64)((*p).nameid)==(int64)12)) {
        mlib_gs_str(d,(byte*)"Offset:");
        mlib_gs_strint(d,(int64)((*p).offset));
        sprintf(str,(byte*)"%.*s",(*p).uflags.ulength,&(*p).uflags.codes);
        mlib_gs_str(d,(byte*)" UFLAGS:");
        mlib_gs_str(d,str);
        mlib_gs_strint(d,(int64)((*p).uflags.ulength));
    } else if (((int64)((*p).nameid)==(int64)14)) {
        mlib_gs_str(d,(byte*)"Index:");
        mlib_gs_strint(d,(int64)((*p).offset));
    } else if (((int64)((*p).nameid)==(int64)6)) {
        mlib_gs_str(d,(byte*)"Index:");
        mlib_gs_strint(d,(int64)((*p).index));
        mlib_gs_str(d,(byte*)" Address:");
        sprintf(str,(byte*)"%p",(*p).address);
        mlib_gs_str(d,str);
        if (!!((*p).docstring)) {
            mlib_gs_str(d,(byte*)"{");
            mlib_gs_str(d,(*p).docstring);
            mlib_gs_str(d,(byte*)"}");
        }
    } else if (((int64)((*p).nameid)==(int64)7)) {
        mlib_gs_str(d,(byte*)"Index/PCaddr:");
        mlib_gs_strint(d,(int64)((*p).index));
        if (!!((*p).truename)) {
            mlib_gs_str(d,(byte*)" Truename:");
            mlib_gs_str(d,(*p).truename);
        }
    } else if (((int64)((*p).nameid)==(int64)9)) {
        mlib_gs_str(d,(byte*)"Const:");
        mlib_gs_strvar(d,qc_lib_strexpr((*p).code));
    } else if (((int64)((*p).nameid)==(int64)5)) {
        if (!!((t = (int64)((*p).attribs.ax_baseclass)))) {
            mlib_gs_str(d,(byte*)"Baseclass:");
            if ((t < (int64)255)) {
                mlib_gs_str(d,var_decls_ttname[(t)]);
            }
            else {
                mlib_gs_str(d,(byte*)"(Unavailable,>=255)");
            }
        }
    } else if (((int64)((*p).nameid)==(int64)15)) {
        mlib_gs_str(d,(byte*)"Enum:");
        mlib_gs_strint(d,(int64)((*p).index));
    } else if (((int64)((*p).nameid)==(int64)4)) {
        mlib_gs_str(d,(byte*)"DLL#:");
        mlib_gs_strint(d,(int64)((*p).attribs.ax_dllindex));
    }
    mlib_gs_str(d,(byte*)" ");
    if (!!((*p).equiv)) {
        if (((int64)((*p).nameid)==(int64)18)) {
            mlib_gs_str(d,(byte*)"Alias for:");
            mlib_gs_str(d,(*(*p).equiv).name);
        } else if (((int64)((*p).nameid)==(int64)19)) {
            mlib_gs_str(d,(byte*)"Link to:");
            mlib_gs_str(d,qc_lib_getdottedname((*p).equiv));
        }
        else {
            if (!!((*p).attribs.ax_at)) {
                mlib_gs_str(d,(byte*)"@");
                mlib_gs_str(d,(*(*p).equiv).name);
            }
        }
        mlib_gs_str(d,(byte*)" ");
    }
    mlib_gs_str(d,(byte*)"Lineno:");
    mlib_gs_strint(d,(int64)((*p).lineno));
    mlib_gs_println(d,f);
}

void qc_lib_printstflat(void * f) {
    int64 i;
    struct var_decls_strec *  p;
    struct qc_lex_lexrec *  lx;
    int64 av_1;
    fprintf(f,"%s\n",(char*)((byte*)"GLOBAL SYMBOL TABLE:"));
L1212:;
    for (i=(int64)0;i<=(int64)131070;++i) {
L1213:;
        p = &qc_lex_hashtable[(i)];
        if (!!((*p).name)) {
            if (((int64)((*p).symbol)==(int64)34) || ((int64)((*p).symbol)==(int64)47)) {
                fprintf(f,"%lld %p %s %s %s %s\n",(int64)i,(void*)(p),(char*)((byte*)":"),(char*)((*p).name),(char*)(qc_tables_symbolnames[((int64)((*p).symbol))-1]),(char*)(pq_common_namenames[((int64)((*p).nameid))]));
                if (((int64)((*p).symbol) == (int64)47)) {
                    fprintf(f,"%s %s\n",(char*)((byte*)"\t\t\t"),(char*)((*p).macrovalue));
                }
                p = (*p).nextdupl;
L1216:;
                while (!!(p)) {
                    fprintf(f,"%s %p %s %s %s %p %s %s%s\n",(char*)((byte*)"\t"),(void*)(p),(char*)((*p).name),(char*)(qc_tables_symbolnames[((int64)((*p).symbol))-1]),(char*)(pq_common_namenames[((int64)((*p).nameid))]),(void*)((*p).prevdupl),(char*)((byte*)"(From"),(char*)((!!((*p).owner)?(*(*p).owner).name:(byte*)"-")),(char*)((byte*)")"));
                    p = (*p).nextdupl;
L1217:;
                }
L1218:;
            }
        }
L1214:;
    }
L1215:;
}

static struct var_decls_unitrec * qc_lib_newunitrec(void) {
    struct var_decls_unitrec *  p;
    p = (struct var_decls_unitrec *)(mlib_pcm_alloc((int64)56));
    memset((void *)(p),(int32)0,(uint64)((int64)56));
    (*p).lineno = (int32)(qc_lex_lx.lineno);
    return p;
}

struct var_decls_unitrec * qc_lib_createname(struct var_decls_strec * p) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int32)3;
    (*u).def = p;
    return u;
}

struct var_decls_unitrec * qc_lib_createunit0(int64 tag) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int32)(tag);
    return u;
}

struct var_decls_unitrec * qc_lib_createunit1(int64 tag,struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int32)(tag);
    (*u).a = p;
    return u;
}

struct var_decls_unitrec * qc_lib_createunit2(int64 tag,struct var_decls_unitrec * p,struct var_decls_unitrec * q) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int32)(tag);
    (*u).a = p;
    (*u).b = q;
    return u;
}

struct var_decls_unitrec * qc_lib_createunit3(int64 tag,struct var_decls_unitrec * p,struct var_decls_unitrec * q,struct var_decls_unitrec * r) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int32)(tag);
    (*u).a = p;
    (*u).b = q;
    (*u).c = r;
    return u;
}

struct var_decls_unitrec * qc_lib_createconstunit(uint64 a,int64 t) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int32)1;
    (*u).value = (int64)(a);
    (*u).valuemode = (int32)(t);
    return u;
}

struct var_decls_unitrec * qc_lib_createstringconstunit(byte * s,int64 length) {
    struct var_decls_unitrec *  u;
    u = qc_lib_newunitrec();
    (*u).tag = (int32)1;
    (*u).svalue = s;
    (*u).valuemode = (int32)5;
    if ((length == (int64)-1)) {
        (*u).slength = (int32)(strlen(s));
    }
    else {
        (*u).slength = (int32)(length);
    }
    return u;
}

int64 qc_lib_getoptocode(int64 opc) {
    static int16 opctotable[248];
    int64 n;
    int64 opcto;
    int64 i;
    byte str[20];
    int64 av_1;
    opcto = (int64)(opctotable[(opc)]);
    if (!!(opcto)) {
        return opcto;
    }
    strcpy(str,qc_tables_jtagnames[(opc)]);
    strcat(str,(byte*)"to");
L1219:;
    for (i=(int64)0;i<=(int64)247;++i) {
L1220:;
        if (!!(mlib_eqstring(qc_tables_jtagnames[(i)],str))) {
            opctotable[(opc)] = (int16)(i);
            return i;
        }
L1221:;
    }
L1222:;
    printf("%s\n",(char*)(qc_tables_jtagnames[(opc)]));
    qc_support_serror((byte*)"Can't find -to version");
    return (int64)0;
}

int64 qc_lib_checkpackedtype(int64 m) {
    switch ((int64)(var_decls_ttbasetype[(m)])) {
    case 37:;
    case 38:;
    case 39:;
    case 40:;
    case 44:;
    case 45:;
    case 46:;
    case 47:;
    case 48:;
    case 49:;
    case 23:;
    case 5:;
    case 33:;
    case 21:;
    case 30:;
    case 52:;
    case 50:;
    case 51:;
        return (int64)1;
        break;
    default:;
    }
    qc_support_serror((byte*)"Invalid Packed type");
    return (int64)0;
}

void qc_lib_checkunpackedtype(int64 t) {
    if (((int64)(var_decls_ttbasetype[(t)]) > (int64)35)) {
        qc_support_serror((byte*)"Pack type not allowed");
    }
}

int64 qc_lib_checkdlltype(int64 m) {
    switch ((int64)(var_decls_ttbasetype[(m)])) {
    case 37:;
    case 38:;
    case 39:;
    case 40:;
    case 44:;
    case 45:;
    case 46:;
    case 47:;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 23:;
    case 5:;
    case 33:;
    case 21:;
        return (int64)1;
        break;
    default:;
    }
    printf("%s\n",(char*)(var_decls_ttname[(m)]));
    qc_support_serror((byte*)"Invalid DLL param/ret type");
    return (int64)0;
}

int64 qc_lib_createtype(struct var_decls_strec * d) {
    if (((int64)((*d).nameid) == (int64)5)) {
        return (int64)((*d).mode);
    }
    return qc_lib_createusertype(d);
}

int64 qc_lib_createusertype(struct var_decls_strec * stname) {
    ++var_decls_ntypes;
    var_decls_ttname[(var_decls_ntypes)] = (*stname).name;
    var_decls_ttnamedef[(var_decls_ntypes)] = stname;
    var_decls_ttbasetype[(var_decls_ntypes)] = (int32)0;
    var_decls_ttusercat[(var_decls_ntypes)] = (uint8)2u;
    return var_decls_ntypes;
}

int64 qc_lib_createusertypefromstr(byte * name) {
    struct var_decls_strec *  stname;
    stname = qc_lib_getduplnameptr(var_decls_stmodule,qc_lex_addnamestr(name),(int64)5);
    qc_lib_adddef(var_decls_stmodule,stname);
    return qc_lib_createusertype(stname);
}

int64 qc_lib_getconstvalue(struct var_decls_unitrec * p,int64 id) {
    if ((!!(p) && ((int64)((*p).tag) == (int64)1))) {
        return (*p).value;
    }
    printf("%s %lld\n",(char*)((byte*)"ID="),(int64)id);
    printf("%s %lld\n",(char*)((byte*)"ID="),(int64)id);
    printf("%s %lld\n",(char*)((byte*)"ID="),(int64)id);
    printf("%s %lld\n",(char*)((byte*)"ID="),(int64)id);
    qc_support_serror((byte*)"GCV Not constant");
    return (int64)0;
}

int64 qc_lib_getrangelwb(struct var_decls_unitrec * p) {
    if (((int64)((*p).tag) == (int64)80)) {
        return (int64)((*p).range_lower);
    }
    else {
        qc_support_serror((byte*)"getrangelwb");
    }
    return (int64)0;
}

int64 qc_lib_getrangeupb(struct var_decls_unitrec * p) {
    if (((int64)((*p).tag) == (int64)80)) {
        return (int64)((*p).range_upper);
    }
    else {
        qc_support_serror((byte*)"getrangeupb");
    }
    return (int64)0;
}

struct var_decls_unitrec * qc_lib_getrangelwbunit(struct var_decls_unitrec * p) {
    if (((int64)((*p).tag) == (int64)80)) {
        return (*p).a;
    }
    else {
        return qc_lib_createunit1((int64)178,p);
    }
}

struct var_decls_unitrec * qc_lib_getrangeupbunit(struct var_decls_unitrec * p) {
    if (((int64)((*p).tag) == (int64)80)) {
        return (*p).b;
    }
    else {
        return qc_lib_createunit1((int64)179,p);
    }
}

int64 qc_lib_createarraymode(int64 target,int64 lower,int64 length,int64 typedefx) {
    int64 atype;
    int64 k;
    int64 m;
    if ((target==(int64)41) || (target==(int64)42) || (target==(int64)43)) {
        atype = (int64)31;
    }
    else {
        atype = (int64)30;
    }
    if ((typedefx == (int64)0)) {
L1223:;
        for (k=(int64)53;k<=var_decls_ntypes;++k) {
L1224:;
            if (((((((int64)(var_decls_ttusercat[(k)]) == (int64)1) && ((int64)(var_decls_ttbasetype[(k)]) == atype)) && ((int64)(var_decls_tttarget[(k)]) == target)) && ((int64)(var_decls_ttlower[(k)]) == lower)) && ((int64)(var_decls_ttlength[(k)]) == length))) {
                return k;
            }
L1225:;
        }
L1226:;
        m = qc_lib_createusertypefromstr(qc_lib_nextautotype());
    }
    else {
        m = typedefx;
    }
    var_decls_ttbasetype[(m)] = (int32)(atype);
    var_decls_ttlower[(m)] = (int32)(lower);
    var_decls_ttlength[(m)] = (int32)(length);
    var_decls_tttarget[(m)] = (int32)(target);
    return m;
}

byte * qc_lib_nextautotype(void) {
    static byte str[32];
    sprintf(str,(byte*)"$T%d",++qc_lib_autotypeno);
    return str;
}

int64 qc_lib_createstringmode(int64 t,int64 length,int64 typedefx) {
    int64 k;
    int64 m;
    if ((typedefx == (int64)0)) {
L1227:;
        for (k=(int64)53;k<=var_decls_ntypes;++k) {
L1228:;
            if (((((int64)(var_decls_ttusercat[(k)]) == (int64)1) && ((int64)(var_decls_ttbasetype[(k)]) == t)) && ((int64)(var_decls_ttlength[(k)]) == length))) {
                return k;
            }
L1229:;
        }
L1230:;
        m = qc_lib_createusertypefromstr(qc_lib_nextautotype());
    }
    else {
        m = typedefx;
    }
    var_decls_ttbasetype[(m)] = (int32)(t);
    var_decls_ttlower[(m)] = ((t == (int64)5)?(int32)1:(int32)0);
    var_decls_ttsize[(m)] = (int32)(length);
    var_decls_ttlength[(m)] = (int32)(length);
    return m;
}

int64 qc_lib_createrefpackmode(int64 target,int64 typedefx) {
    int64 k;
    int64 m;
    if ((target==(int64)35)) {
        return (int64)22;
    } else if ((target==(int64)41) || (target==(int64)42) || (target==(int64)43)) {
        qc_support_serror((byte*)"CREATEREFBIT");
    }
    if ((typedefx == (int64)0)) {
L1231:;
        for (k=(int64)53;k<=var_decls_ntypes;++k) {
L1232:;
            if (((((int64)(var_decls_ttusercat[(k)]) == (int64)1) && ((int64)(var_decls_ttbasetype[(k)]) == (int64)23)) && ((int64)(var_decls_tttarget[(k)]) == target))) {
                return k;
            }
L1233:;
        }
L1234:;
        m = qc_lib_createusertypefromstr(qc_lib_nextautotype());
    }
    else {
        m = typedefx;
    }
    var_decls_tttarget[(m)] = (int32)(target);
    var_decls_ttbasetype[(m)] = (int32)23;
    return m;
}

int64 qc_lib_getscope(struct var_decls_strec * p) {
    struct var_decls_strec *  owner;
    if ((p == 0)) {
        return (int64)1;
    }
    if (((int64)((*p).nameid)==(int64)2) || ((int64)((*p).nameid)==(int64)1)) {
        return (int64)3;
    } else if (((int64)((*p).nameid)==(int64)3) || ((int64)((*p).nameid)==(int64)4)) {
        return (int64)2;
    }
L1235:;
    while (1) {
        owner = (*p).owner;
        if (((int64)((*owner).nameid)==(int64)2) || ((int64)((*owner).nameid)==(int64)3) || ((int64)((*owner).nameid)==(int64)4)) {
            goto L1236;
        }
        p = owner;
    }
L1236:;
    if (((int64)((*owner).nameid)==(int64)2)) {
        return (!!((*p).attribs.ax_global)?(int64)3:(int64)1);
    }
    else {
        return (int64)2;
    }
    return (int64)0;
}

void qc_lib_setnameptr(struct var_decls_unitrec * p) {
    (*(*p).def).code = p;
}

void qc_lib_printcode_all(void * f,byte * caption) {
    int64 i;
    struct var_decls_strec *  p;
    printf("%s\n",(char*)((byte*)"PRINTCODE"));
L1237:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L1238:;
        qc_lib_printcode(f,caption,i);
L1239:;
    }
L1240:;
}

void qc_lib_printcode(void * f,byte * caption,int64 n) {
    int64 i;
    struct var_decls_strec *  p;
    p = (*var_decls_moduletable[(n)].stmodule).deflist;
    fprintf(f,"%s %s %s\n",(char*)(caption),(char*)((byte*)"MODULE:"),(char*)(var_decls_moduletable[(n)].name));
L1241:;
    while (!!(p)) {
        if (((int64)((*p).nameid)==(int64)6)) {
            fprintf(f,"%s%s %s\n",(char*)((*p).name),(char*)((byte*)"="),(char*)((!!((*p).attribs.ax_global)?(byte*)"Global":(byte*)"Local")));
            qc_lib_printunit(f,(*p).code,(int64)0,(byte*)"1");
            fprintf(f,"\n");
        }
        p = (*p).nextdef;
L1242:;
    }
L1243:;
}

void qc_lib_printunit(void * dev,struct var_decls_unitrec * p,int64 level,byte * prefix) {
    struct var_decls_unitrec *  q;
    struct var_decls_strec *  d;
    int64 t;
    byte *  idname;
    if ((p == 0)) {
        return;
    }
    if (!!((*p).lineno)) {
        qc_lib_currlineno = (int64)((*p).lineno);
    }
    fprintf(dev,"%p %s",(void*)(p),(char*)((byte*)": "));
    fprintf(dev,"%s",(char*)(qc_lib_getprefix(level,prefix,p)));
    idname = qc_tables_jtagnames[((int64)((*p).tag))];
    fprintf(dev,"%s%s",(char*)(idname),(char*)((byte*)": "));
    if (!!(mlib_fdebug)) {
        printf("%s %s\n",(char*)((byte*)"IDNAME="),(char*)(idname));
    }
    if (((int64)((*p).tag)==(int64)3)) {
        d = (*p).def;
        fprintf(dev,"%s %s",(char*)((*d).name),(char*)(pq_common_namenames[((int64)((*d).nameid))]));
        if (!!((*d).code)) {
            fprintf(dev,"%s%s%s",(char*)((byte*)" {"),(char*)(qc_tables_jtagnames[((int64)((*(*d).code).tag))]),(char*)((byte*)"}"));
        }
        fprintf(dev,"%s%s",(char*)((byte*)" "),(char*)(qc_lib_getdottedname(d)));
        fprintf(dev,"%s",(char*)((!!((*p).dottedname)?(byte*)" {Dotted}":(byte*)"")));
        if (!!((*p).c)) {
            fprintf(dev,"%s %p",(char*)((byte*)" Lastcall:"),(void*)((*p).c));
        }
    } else if (((int64)((*p).tag)==(int64)35)) {
        fprintf(dev,"%s\n",(char*)((*(*p).def).name));
    } else if (((int64)((*p).tag)==(int64)1)) {
        t = (int64)((*p).valuemode);
        if ((t==(int64)5)) {
            if (((int64)((*p).slength) > (int64)256)) {
                fprintf(dev,"%s%s %s%d",(char*)((byte*)"\""),(char*)((byte*)"(LONGSTR)"),(char*)((byte*)"\" *"),(*p).slength);
            }
            else {
                fprintf(dev,"%s%s%s%d",(char*)((byte*)"\""),(char*)((*p).svalue),(char*)((byte*)"\" *"),(*p).slength);
            }
        } else if ((t==(int64)1)) {
            fprintf(dev,"%lld",(int64)(*p).value);
        } else if ((t==(int64)2)) {
            fprintf(dev,"%llu",(uint64)(*p).uvalue);
        } else if ((t==(int64)3)) {
            fprintf(dev,"%f",(*p).xvalue);
        } else if ((t==(int64)4)) {
            fprintf(dev,"%d%s%d",(*p).range_lower,(char*)((byte*)".."),(*p).range_upper);
        }
        else {
            printf("%s\n",(char*)(var_decls_ttname[(t)]));
            qc_support_serror((byte*)"PRINTUNIT BAD CONST");
        }
        fprintf(dev,"%s%s",(char*)((byte*)" "),(char*)(var_types_stdtypenames[(t)]));
    } else if (((int64)((*p).tag)==(int64)9)) {
        fprintf(dev,"%s %s %d",(char*)((*p).svalue),(char*)((byte*)"Len:"),(*p).slength);
    } else if (((int64)((*p).tag)==(int64)92) || ((int64)((*p).tag)==(int64)66)) {
        fprintf(dev,"%s",(char*)(pq_common_hostfnnames[((int64)((*p).opcode))]));
    } else if (((int64)((*p).tag)==(int64)149)) {
        fprintf(dev,"%s",(char*)(var_decls_ttname[((int64)((*p).valuemode))]));
    } else if (((int64)((*p).tag)==(int64)150)) {
        fprintf(dev,"%s",(char*)((qc_tables_jtagnames[((int64)((*p).opcode))] + (int64)2)));
    } else if (((int64)((*p).tag)==(int64)147)) {
        fprintf(dev,"%s",(char*)(var_decls_ttname[((int64)((*p).valuemode))]));
    }
    fprintf(dev,"\n");
    qc_lib_printunitlist(dev,(*p).a,(level + (int64)1),(byte*)"1");
    qc_lib_printunitlist(dev,(*p).b,(level + (int64)1),(byte*)"2");
    qc_lib_printunitlist(dev,(*p).c,(level + (int64)1),(byte*)"3");
}

static void qc_lib_printunitlist(void * dev,struct var_decls_unitrec * p,int64 level,byte * prefix) {
    if ((p == 0)) {
        return;
    }
L1244:;
    while (!!(p)) {
        qc_lib_printunit(dev,p,level,prefix);
        p = (*p).nextunit;
L1245:;
    }
L1246:;
}

static byte * qc_lib_getprefix(int64 level,byte * prefix,struct var_decls_unitrec * p) {
    static byte str[512];
    byte indentstr[512];
    int64 av_1;
    indentstr[((int64)1)-1] = (uint8)0u;
    if ((level > (int64)10)) {
        level = (int64)10;
    }
    av_1 = level;
    while (av_1-- > 0) {
L1247:;
        strcat(indentstr,(byte*)"- - ");
L1248:;
    }
L1249:;
    strcpy(str,qc_lib_getlineinfok());
    strcat(str,indentstr);
    strcat(str,prefix);
    if (!!((*prefix))) {
        strcat(str,(byte*)" ");
    }
    return str;
}

byte * qc_lib_getdottedname(struct var_decls_strec * p) {
    static byte str[256];
    byte str2[256];
    struct var_decls_strec *  owner;
    strcpy(str,(*p).name);
    owner = (*p).owner;
L1250:;
    while ((!!(owner) && ((int64)((*owner).nameid) != (int64)1))) {
        strcpy(str2,str);
        strcpy(str,(*owner).name);
        strcat(str,(byte*)".");
        strcat(str,str2);
        owner = (*owner).owner;
L1251:;
    }
L1252:;
    return str;
}

static byte * qc_lib_getlineinfok(void) {
    static byte str[40];
    sprintf(str,(byte*)"%04d ",qc_lib_currlineno);
    return str;
}

struct var_decls_strec * qc_lib_getavname(struct var_decls_strec * owner,int64 id) {
    struct var_decls_strec *  p;
    byte str[32];
    byte *  name;
    if (((id == (int64)11) && ((int64)((*owner).nameid) != (int64)6))) {
        qc_support_serror((byte*)"Auto frame var not in proc");
    }
    if ((id == (int64)11)) {
        sprintf(str,(byte*)"av$%d",++qc_lib_nextavindex);
    }
    else {
        sprintf(str,(byte*)"sv$%d",++qc_lib_nextsvindex);
    }
    name = mlib_pcm_copyheapstring(str);
    qc_lex_addnamestr(name);
    p = qc_lib_getduplnameptr(owner,qc_lex_addnamestr(name),id);
    (*p).mode = (int16)1;
    (*p).attribs.ax_autovar = (uint8)1u;
    qc_lib_adddef(owner,p);
    return p;
}

void qc_lib_unionstr_clear(struct var_decls_uflagsrec * u) {
    (*u).ulength = (uint8)0u;
}

void qc_lib_unionstr_append(struct var_decls_uflagsrec * u,int64 c) {
    if (((int64)((*u).ulength) == (int64)7)) {
        qc_support_serror((byte*)"Uflags overflow/a");
    }
    ++(*u).ulength;
    (*u).codes[((int64)((*u).ulength))-1] = (byte)(c);
}

void qc_lib_unionstr_concat(struct var_decls_uflagsrec * u,struct var_decls_uflagsrec * v) {
    int64 ulen;
    int64 vlen;
    int64 i;
    ulen = (int64)((*u).ulength);
    vlen = (int64)((*v).ulength);
    if (((ulen + vlen) > (int64)7)) {
        qc_support_serror((byte*)"Uflags overflow/c");
    }
L1253:;
    for (i=(int64)1;i<=vlen;++i) {
L1254:;
        (*u).codes[((i + ulen))-1] = (*v).codes[(i)-1];
L1255:;
    }
L1256:;
    (*u).ulength = (byte)((ulen + vlen));
}

int64 qc_lib_unionstr_last(struct var_decls_uflagsrec * u) {
    if (!!((*u).ulength)) {
        return (int64)((*u).codes[((int64)((*u).ulength))-1]);
    }
    return (int64)0;
}

void qc_lib_unionstr_copy(struct var_decls_uflagsrec * u,struct var_decls_uflagsrec * v) {
    memcpy((void *)(u),(void *)(v),(uint64)((int64)8));
}

void qc_lib_unionstr_print(struct var_decls_uflagsrec * u) {
    qc_lex_printstrn((byte *)(&(*u).codes),(int64)((*u).ulength));
}

int64 qc_lib_createrecordmode(struct var_decls_strec * owner,int64 t,int64 typedefx) {
    int64 m;
    if ((typedefx == (int64)0)) {
        m = qc_lib_createusertype(owner);
    }
    else {
        m = typedefx;
    }
    var_decls_ttbasetype[(m)] = (int32)(t);
    return m;
}

int64 qc_lib_createenummode(struct var_decls_strec * owner,int64 typedefx) {
    int64 m;
    if ((typedefx == (int64)0)) {
        m = qc_lib_createusertype(owner);
    }
    else {
        m = typedefx;
    }
    var_decls_ttbasetype[(m)] = (int32)12;
    return m;
}

void qc_lib_convertstring(byte * s,byte * t) {
    int64 c;
L1257:;
    while (!!((c = (int64)((*s++))))) {
        switch (c) {
        case 34:;
            (*t++) = (uint8)92u;
            (*t++) = (uint8)34u;
            break;
        case 10:;
            (*t++) = (uint8)92u;
            (*t++) = (uint8)110u;
            break;
        case 13:;
            (*t++) = (uint8)92u;
            (*t++) = (uint8)99u;
            break;
        case 9:;
            (*t++) = (uint8)92u;
            (*t++) = (uint8)116u;
            break;
        case 92:;
            (*t++) = (uint8)92u;
            (*t++) = (uint8)92u;
            break;
        case 7:;
        case 8:;
        case 26:;
        case 27:;
            (*t++) = (uint8)60u;
            (*t++) = (byte)(((c / (int64)10) + (int64)48));
            (*t++) = (byte)(((c % (int64)10) + (int64)48));
            (*t++) = (uint8)62u;
            break;
        default:;
            (*t++) = (byte)(c);
        }
L1258:;
    }
L1259:;
    (*t) = (uint8)0u;
}

struct mlib_strbuffer * qc_lib_strexpr(struct var_decls_unitrec * p) {
    mlib_gs_init(qc_lib_exprstr);
    qc_lib_jeval(qc_lib_exprstr,p);
    return qc_lib_exprstr;
}

static void qc_lib_jeval(struct mlib_strbuffer * dest,struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    byte str[500];
    if (((int64)((*p).tag)==(int64)1)) {
        if (((int64)((*p).valuemode)==(int64)5)) {
            if (((int64)((*p).slength) > (int64)250)) {
                strcpy(str,(byte*)"LONGSTR)");
            }
            else {
                qc_lib_convertstring((*p).svalue,str);
            }
            qc_support_gs_additem(dest,(byte*)"\"");
            qc_support_gs_additem(dest,str);
            qc_support_gs_additem(dest,(byte*)"\"");
            return;
        } else if (((int64)((*p).valuemode)==(int64)1)) {
            sprintf(str,(byte*)"%lld",(*p).value);
        } else if (((int64)((*p).valuemode)==(int64)2)) {
            sprintf(str,(byte*)"%llu",(*p).uvalue);
        } else if (((int64)((*p).valuemode)==(int64)3)) {
            sprintf(str,(byte*)"%f",(*p).xvalue);
        } else if (((int64)((*p).valuemode)==(int64)4)) {
            sprintf(str,(byte*)"%d..%d",(*p).range_lower,(*p).range_upper);
        }
        else {
            printf("%s\n",(char*)(var_decls_ttname[((int64)((*p).valuemode))]));
            qc_support_nxerror((byte*)"EVAL/CONST",p);
        }
        qc_support_gs_additem(dest,str);
    } else if (((int64)((*p).tag)==(int64)3)) {
        qc_support_gs_additem(dest,(*(*p).def).name);
    } else if (((int64)((*p).tag)==(int64)72) || ((int64)((*p).tag)==(int64)73) || ((int64)((*p).tag)==(int64)95) || ((int64)((*p).tag)==(int64)96) || ((int64)((*p).tag)==(int64)97) || ((int64)((*p).tag)==(int64)98) || ((int64)((*p).tag)==(int64)99) || ((int64)((*p).tag)==(int64)100) || ((int64)((*p).tag)==(int64)101) || ((int64)((*p).tag)==(int64)103) || ((int64)((*p).tag)==(int64)104) || ((int64)((*p).tag)==(int64)105) || ((int64)((*p).tag)==(int64)106) || ((int64)((*p).tag)==(int64)107) || ((int64)((*p).tag)==(int64)108) || ((int64)((*p).tag)==(int64)109) || ((int64)((*p).tag)==(int64)110) || ((int64)((*p).tag)==(int64)112) || ((int64)((*p).tag)==(int64)113) || ((int64)((*p).tag)==(int64)114) || ((int64)((*p).tag)==(int64)115) || ((int64)((*p).tag)==(int64)116) || ((int64)((*p).tag)==(int64)117) || ((int64)((*p).tag)==(int64)118) || ((int64)((*p).tag)==(int64)119) || ((int64)((*p).tag)==(int64)120) || ((int64)((*p).tag)==(int64)121) || ((int64)((*p).tag)==(int64)122) || ((int64)((*p).tag)==(int64)123) || ((int64)((*p).tag)==(int64)124) || ((int64)((*p).tag)==(int64)142) || ((int64)((*p).tag)==(int64)143) || ((int64)((*p).tag)==(int64)74) || ((int64)((*p).tag)==(int64)102) || ((int64)((*p).tag)==(int64)111) || ((int64)((*p).tag)==(int64)125)) {
        strcpy(str,qc_lib_getopcjname((int64)((*p).tag)));
        qc_support_gs_additem(dest,(byte*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,str);
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(byte*)")");
    } else if (((int64)((*p).tag)==(int64)154) || ((int64)((*p).tag)==(int64)155) || ((int64)((*p).tag)==(int64)156) || ((int64)((*p).tag)==(int64)157) || ((int64)((*p).tag)==(int64)158) || ((int64)((*p).tag)==(int64)159) || ((int64)((*p).tag)==(int64)160) || ((int64)((*p).tag)==(int64)161) || ((int64)((*p).tag)==(int64)162) || ((int64)((*p).tag)==(int64)163) || ((int64)((*p).tag)==(int64)164) || ((int64)((*p).tag)==(int64)165) || ((int64)((*p).tag)==(int64)166) || ((int64)((*p).tag)==(int64)167) || ((int64)((*p).tag)==(int64)168) || ((int64)((*p).tag)==(int64)169) || ((int64)((*p).tag)==(int64)170) || ((int64)((*p).tag)==(int64)171) || ((int64)((*p).tag)==(int64)172) || ((int64)((*p).tag)==(int64)173) || ((int64)((*p).tag)==(int64)174) || ((int64)((*p).tag)==(int64)175) || ((int64)((*p).tag)==(int64)176) || ((int64)((*p).tag)==(int64)177) || ((int64)((*p).tag)==(int64)178) || ((int64)((*p).tag)==(int64)179) || ((int64)((*p).tag)==(int64)180) || ((int64)((*p).tag)==(int64)181) || ((int64)((*p).tag)==(int64)182) || ((int64)((*p).tag)==(int64)183) || ((int64)((*p).tag)==(int64)185) || ((int64)((*p).tag)==(int64)186) || ((int64)((*p).tag)==(int64)187) || ((int64)((*p).tag)==(int64)188) || ((int64)((*p).tag)==(int64)190) || ((int64)((*p).tag)==(int64)191) || ((int64)((*p).tag)==(int64)192) || ((int64)((*p).tag)==(int64)193) || ((int64)((*p).tag)==(int64)194) || ((int64)((*p).tag)==(int64)195) || ((int64)((*p).tag)==(int64)196) || ((int64)((*p).tag)==(int64)198) || ((int64)((*p).tag)==(int64)199) || ((int64)((*p).tag)==(int64)201) || ((int64)((*p).tag)==(int64)203) || ((int64)((*p).tag)==(int64)204) || ((int64)((*p).tag)==(int64)205) || ((int64)((*p).tag)==(int64)206) || ((int64)((*p).tag)==(int64)75) || ((int64)((*p).tag)==(int64)76) || ((int64)((*p).tag)==(int64)189) || ((int64)((*p).tag)==(int64)202)) {
        strcpy(str,qc_lib_getopcjname((int64)((*p).tag)));
        qc_support_gs_additem(dest,str);
        qc_support_gs_additem(dest,(byte*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)")");
    } else if (((int64)((*p).tag)==(int64)88) || ((int64)((*p).tag)==(int64)14)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)"(");
        q = (*p).b;
L1260:;
        while (!!(q)) {
            qc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                qc_support_gs_additem(dest,(byte*)",");
            }
L1261:;
        }
L1262:;
        qc_support_gs_additem(dest,(byte*)")");
    } else if (((int64)((*p).tag)==(int64)92)) {
        qc_support_gs_additem(dest,(byte*)"Host<");
        qc_support_gs_additem(dest,(pq_common_hostfnnames[((int64)((*p).opcode))] + (int64)5));
        qc_support_gs_additem(dest,(byte*)">(");
        q = (*p).b;
L1263:;
        while (!!(q)) {
            qc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                qc_support_gs_additem(dest,(byte*)",");
            }
L1264:;
        }
L1265:;
        qc_support_gs_additem(dest,(byte*)")");
    } else if (((int64)((*p).tag)==(int64)127) || ((int64)((*p).tag)==(int64)131) || ((int64)((*p).tag)==(int64)129) || ((int64)((*p).tag)==(int64)134)) {
        qc_lib_jeval(dest,(*p).a);
        if ((((int64)((*p).tag) == (int64)131) || ((int64)((*p).tag) == (int64)134))) {
            qc_support_gs_additem(dest,(byte*)".");
        }
        qc_support_gs_additem(dest,(byte*)"[");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(byte*)"]");
    } else if (((int64)((*p).tag)==(int64)130) || ((int64)((*p).tag)==(int64)135)) {
        qc_lib_jeval(dest,(*p).a);
        if (((int64)((*p).tag) == (int64)135)) {
            qc_support_gs_additem(dest,(byte*)".");
        }
        qc_support_gs_additem(dest,(byte*)"{");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(byte*)"}");
    } else if (((int64)((*p).tag)==(int64)139)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)".");
        qc_lib_jeval(dest,(*p).b);
    } else if (((int64)((*p).tag)==(int64)77) || ((int64)((*p).tag)==(int64)79) || ((int64)((*p).tag)==(int64)78) || ((int64)((*p).tag)==(int64)81)) {
        qc_support_gs_additem(dest,((((int64)((*p).tag) == (int64)77) || ((int64)((*p).tag) == (int64)78))?(byte*)"(":(byte*)"["));
        q = (*p).a;
L1266:;
        while (!!(q)) {
            qc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                qc_support_gs_additem(dest,(byte*)",");
            }
L1267:;
        }
L1268:;
        qc_support_gs_additem(dest,(((int64)((*p).tag) == (int64)77)?(byte*)")":(byte*)"]"));
    } else if (((int64)((*p).tag)==(int64)80)) {
        qc_support_gs_additem(dest,(byte*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)"..");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(byte*)")");
    } else if (((int64)((*p).tag)==(int64)86)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)":=");
        qc_lib_jeval(dest,(*p).b);
    } else if (((int64)((*p).tag)==(int64)90)) {
        qc_support_gs_additem(dest,(byte*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)"|");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(byte*)"|");
        qc_lib_jeval(dest,(*p).c);
        qc_support_gs_additem(dest,(byte*)")");
    } else if (((int64)((*p).tag)==(int64)149)) {
        qc_support_gs_additem(dest,qc_lib_strmode((int64)((*p).valuemode),(int64)1));
    } else if (((int64)((*p).tag)==(int64)152)) {
        qc_support_gs_additem(dest,(*(*p).def).name);
        qc_support_gs_additem(dest,(byte*)">");
    } else if (((int64)((*p).tag)==(int64)147)) {
        qc_support_gs_additem(dest,(byte*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)")");
    } else if (((int64)((*p).tag)==(int64)85)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)":");
        qc_lib_jeval(dest,(*p).b);
    } else if (((int64)((*p).tag)==(int64)9)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)"L");
    } else if (((int64)((*p).tag)==(int64)144)) {
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)"^");
    } else if (((int64)((*p).tag)==(int64)146)) {
        qc_support_gs_additem(dest,(byte*)"&");
        qc_lib_jeval(dest,(*p).a);
    } else if (((int64)((*p).tag)==(int64)145)) {
        qc_lib_jeval(dest,(*p).a);
    } else if (((int64)((*p).tag)==(int64)126)) {
        qc_support_gs_additem(dest,(byte*)"(");
        qc_lib_jeval(dest,(*p).a);
        qc_support_gs_additem(dest,(byte*)",");
        qc_lib_jeval(dest,(*p).b);
        qc_support_gs_additem(dest,(byte*)",");
        qc_lib_jeval(dest,(*p).c);
        qc_support_gs_additem(dest,(byte*)")");
    } else if (((int64)((*p).tag)==(int64)4)) {
        qc_support_gs_additem(dest,(byte*)"<JBLOCK>");
    } else if (((int64)((*p).tag)==(int64)83)) {
        qc_support_gs_additem(dest,(byte*)"MULTEXPR(");
        q = (*p).a;
L1269:;
        while (!!(q)) {
            qc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                qc_support_gs_additem(dest,(byte*)",");
            }
L1270:;
        }
L1271:;
        qc_support_gs_additem(dest,(byte*)")");
    }
    else {
        printf("%s\n",(char*)(qc_tables_jtagnames[((int64)((*p).tag))]));
        qc_support_gerror((byte*)"CAN'T DO JEVAL",p);
    }
}

byte * qc_lib_getopcjname(int64 opc) {
    int64 i;
    byte str[20];
    int64 av_1;
L1272:;
    for (i=(int64)1;i<=(int64)35;++i) {
L1273:;
        if ((opc == qc_lib_opc_codes[(i)-1])) {
            return qc_lib_opc_names[(i)-1];
        }
L1274:;
    }
L1275:;
    return (qc_tables_jtagnames[(opc)] + (int64)2);
}

byte * qc_lib_strmode(int64 m,int64 expand) {
    static byte str[4096];
    qc_lib_istrmode(m,expand,str);
    return str;
}

void qc_lib_istrmode(int64 m,int64 expand,byte * dest) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  q;
    int64 value;
    int64 needcomma;
    int64 x;
    int64 i;
    if ((m < (int64)53)) {
        strcpy(dest,var_decls_ttname[(m)]);
        return;
    }
    if (((int64)(var_decls_ttbasetype[(m)])==(int64)22) || ((int64)(var_decls_ttbasetype[(m)])==(int64)23)) {
        strcpy(dest,(byte*)"ref ");
        if (((int64)(var_decls_ttbasetype[((int64)(var_decls_tttarget[(m)]))]) == (int64)33)) {
            strcat(dest,var_decls_ttname[((int64)(var_decls_tttarget[(m)]))]);
        }
        else {
            qc_lib_istrmode((int64)(var_decls_tttarget[(m)]),(int64)0,(dest + (int64)(strlen(dest))));
        }
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)5)) {
        strcpy(dest,(byte*)"string*");
        sprintf((dest + (int64)(strlen(dest))),(byte*)"%d",var_decls_ttlength[(m)]);
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)21)) {
        strcpy(dest,(byte*)"stringz*");
        sprintf((dest + (int64)(strlen(dest))),(byte*)"%d",var_decls_ttlength[(m)]);
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)9)) {
        strcpy(dest,(byte*)"set*");
        sprintf((dest + (int64)(strlen(dest))),(byte*)"%d",var_decls_ttlength[(m)]);
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)30)) {
        if (!!(var_decls_ttlength[(m)])) {
            sprintf(dest,(byte*)"[%d..%d]",var_decls_ttlower[(m)],((int64)((var_decls_ttlength[(m)] - var_decls_ttlower[(m)])) - (int64)1));
        }
        else {
            sprintf(dest,(byte*)"[%d:]",var_decls_ttlower[(m)]);
        }
        qc_lib_istrmode((int64)(var_decls_tttarget[(m)]),(int64)0,(dest + (int64)(strlen(dest))));
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)12)) {
        strcpy(dest,(byte*)"enum(");
        d = var_decls_ttnamedef[(m)];
        value = (int64)1;
        needcomma = (int64)0;
        q = (*d).deflist;
L1276:;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat(dest,(byte*)",");
            }
            needcomma = (int64)1;
            strcat(dest,(*q).name);
            x = (int64)((*q).index);
            if ((x != value)) {
                value = x;
                sprintf((dest + (int64)(strlen(dest))),(byte*)"%d",value);
            }
            ++value;
            q = (*q).nextdef;
L1277:;
        }
L1278:;
        strcat(dest,(byte*)")");
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)32) || ((int64)(var_decls_ttbasetype[(m)])==(int64)33)) {
        if (!(!!(expand))) {
            strcpy(dest,var_decls_ttname[(m)]);
            return;
        }
        strcat(dest,var_decls_ttname[((int64)(var_decls_ttbasetype[(m)]))]);
        strcat(dest,(byte*)"(");
        d = var_decls_ttnamedef[(m)];
        needcomma = (int64)0;
        q = (*d).deflist;
L1279:;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat(dest,(byte*)",");
            }
            needcomma = (int64)1;
            qc_lib_istrmode((int64)((*q).mode),(int64)0,(dest + (int64)(strlen(dest))));
            strcat(dest,(byte*)" ");
            strcat(dest,(*q).name);
            q = (*q).nextdef;
L1280:;
        }
L1281:;
        strcat(dest,(byte*)")");
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)0)) {
        strcpy(dest,var_decls_ttname[(m)]);
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)34)) {
        strcpy(dest,var_decls_ttname[(m)]);
    }
    else {
        qc_support_serror((byte*)"NEWSTRMODE");
    }
}

int64 qc_lib_countunits(struct var_decls_unitrec * p) {
    int64 n;
    n = (int64)0;
L1282:;
    while (!!(p)) {
        ++n;
        p = (*p).nextunit;
L1283:;
    }
L1284:;
    return n;
}

struct var_decls_strec * qc_lib_finddefstr(struct var_decls_strec * owner,byte * name) {
    struct var_decls_strec *  d;
    d = (*owner).deflist;
L1285:;
    while (!!(d)) {
        if (!!(mlib_eqstring((*d).name,name))) {
            return d;
        }
        d = (*d).nextdef;
L1286:;
    }
L1287:;
    return (struct var_decls_strec *)(0);
}

static void qc_lib_purgesymbol(struct var_decls_strec * p,struct var_decls_strec * prev,int64 del) {
    struct var_decls_strec *  q;
    if (((int64)((*p).nameid)==(int64)13)) {
        return;
    }
    qc_lib_purgesymbollist((*p).deflist,(int64)0,del);
    if (!!(prev)) {
        (*prev).nextdef = (*p).nextdef;
    }
    else {
        (*(*p).owner).deflist = (*p).nextdef;
    }
    q = (*p).prevdupl;
    (*q).nextdupl = (*p).nextdupl;
    if (!!(del)) {
        mlib_pcm_free((void *)(p),(int64)128);
    }
}

void qc_lib_purgesymbollist(struct var_decls_strec * p,int64 ismodule,int64 del) {
    struct var_decls_strec *  q;
    struct var_decls_strec *  prev;
    prev = (struct var_decls_strec *)(0);
L1288:;
    while (!!(p)) {
        q = (*p).nextdef;
        if (((ismodule == (int64)0) || !(!!((*p).attribs.ax_global)))) {
            qc_lib_purgesymbol(p,prev,del);
        }
        else {
            prev = p;
        }
        p = q;
L1289:;
    }
L1290:;
}

void qc_lib_purgeprocs(struct var_decls_strec * p,int64 del) {
L1291:;
    while (!!(p)) {
        if (((int64)((*p).nameid) == (int64)6)) {
            qc_lib_purgeproc(p,del);
        }
        p = (*p).nextdef;
L1292:;
    }
L1293:;
}

void qc_lib_purgeproc(struct var_decls_strec * p,int64 del) {
    struct var_decls_strec *  q;
    struct var_decls_strec *  prev;
    struct var_decls_strec *  r;
    q = (*p).deflist;
    prev = (struct var_decls_strec *)(0);
L1294:;
    while (!!(q)) {
        r = (*q).nextdef;
        if (((int64)((*q).nameid) == (int64)11)) {
            qc_lib_purgesymbol(q,prev,del);
        }
        else {
            prev = q;
        }
        q = r;
L1295:;
    }
L1296:;
}

void qc_lib_printmodelist(void * f) {
    byte str[256];
    byte *  mstr;
    struct mlib_strbuffer destv;
    struct mlib_strbuffer *  dest = &destv;
    int64 m;
    mlib_gs_init(dest);
    mlib_gs_leftstr(dest,(byte*)"#",(int64)4,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Name",(int64)13,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Base",(int64)13,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Bit",(int64)3,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Target",(int64)12,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Def",(int64)4,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Lwb",(int64)3,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Upb",(int64)3,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Len",(int64)4,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Size",(int64)5,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Cat",(int64)4,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Used",(int64)4,(int64)32);
    mlib_gs_leftstr(dest,(byte*)"Mode",(int64)32,(int64)32);
    mlib_gs_println(dest,f);
L1297:;
    for (m=(int64)0;m<=var_decls_ntypes;++m) {
L1298:;
        mlib_gs_init(dest);
        mlib_gs_leftint(dest,m,(int64)4,(int64)32);
        mlib_gs_leftstr(dest,var_decls_ttname[(m)],(int64)13,(int64)32);
        mlib_gs_leftstr(dest,var_decls_ttname[((int64)(var_decls_ttbasetype[(m)]))],(int64)13,(int64)32);
        mlib_gs_leftint(dest,(int64)(var_decls_ttbitwidth[(m)]),(int64)3,(int64)32);
        if (!!(var_decls_tttarget[(m)])) {
            mlib_gs_leftstr(dest,var_decls_ttname[((int64)(var_decls_tttarget[(m)]))],(int64)12,(int64)32);
        }
        else {
            mlib_gs_leftstr(dest,(byte*)"-",(int64)12,(int64)32);
        }
        if (!!(var_decls_ttnamedef[(m)])) {
            mlib_gs_leftstr(dest,(byte*)"+",(int64)4,(int64)32);
        }
        else {
            mlib_gs_leftstr(dest,(byte*)"-",(int64)4,(int64)32);
        }
        if (((int64)(var_decls_ttbasetype[(m)])==(int64)5) || ((int64)(var_decls_ttbasetype[(m)])==(int64)9) || ((int64)(var_decls_ttbasetype[(m)])==(int64)30) || ((int64)(var_decls_ttbasetype[(m)])==(int64)32) || ((int64)(var_decls_ttbasetype[(m)])==(int64)33) || ((int64)(var_decls_ttbasetype[(m)])==(int64)12)) {
            mlib_gs_leftint(dest,(int64)(var_decls_ttlower[(m)]),(int64)3,(int64)32);
            mlib_gs_leftint(dest,((int64)((var_decls_ttlower[(m)] + var_decls_ttlength[(m)])) - (int64)1),(int64)3,(int64)32);
            mlib_gs_leftint(dest,(int64)(var_decls_ttlength[(m)]),(int64)4,(int64)32);
        }
        else {
            mlib_gs_leftstr(dest,(byte*)"",(int64)3,(int64)32);
            mlib_gs_leftstr(dest,(byte*)"",(int64)3,(int64)32);
            mlib_gs_leftstr(dest,(byte*)"",(int64)4,(int64)32);
        }
        mlib_gs_leftint(dest,(int64)(var_decls_ttsize[(m)]),(int64)5,(int64)32);
        mlib_gs_leftint(dest,(int64)(var_decls_ttusercat[(m)]),(int64)4,(int64)32);
        mstr = qc_lib_strmode(m,(int64)1);
        if (((int64)(strlen(mstr)) < (int64)16)) {
            mlib_gs_str(dest,mstr);
        }
        else {
            mlib_gs_println(dest,f);
            mlib_gs_init(dest);
            mlib_gs_str(dest,mstr);
        }
        mlib_gs_println(dest,f);
L1299:;
    }
L1300:;
    fprintf(f,"\n");
}

void qc_lib_printgenfieldtable(void * f,byte * caption) {
    int64 i;
    fprintf(f,"%s %lld\n",(char*)(caption),(int64)var_decls_ngenfieldnames);
L1301:;
    for (i=(int64)1;i<=var_decls_ngenfieldnames;++i) {
L1302:;
        fprintf(f,"%lld %s %d %d\n",(int64)i,(char*)((*var_decls_genfieldnames[(i)-1].def).name),var_decls_genfieldnames[(i)-1].dataindex,var_decls_genfieldnames[(i)-1].datalength);
L1303:;
    }
L1304:;
    fprintf(f,"\n");
    fprintf(f,"%s %lld\n",(char*)((byte*)"Genfielddata:"),(int64)var_decls_ngenfielddata);
L1305:;
    for (i=(int64)1;i<=var_decls_ngenfielddata;++i) {
L1306:;
        fprintf(f,"%d %s %s %d\n",var_decls_genfielddata[(i)-1].fieldindex,(char*)(var_decls_ttname[((int64)(var_decls_genfielddata[(i)-1].recordtype))]),(char*)(var_decls_ttname[((int64)(var_decls_genfielddata[(i)-1].fieldtype))]),var_decls_genfielddata[(i)-1].offset);
L1307:;
    }
L1308:;
    fprintf(f,"\n");
}

void qc_lib_addtoproclist(struct var_decls_strec * d) {
    struct var_decls_procrec *  pp;
    ++var_decls_nproclist;
    pp = (struct var_decls_procrec *)(mlib_pcm_alloc((int64)16));
    (*pp).nextproc = var_decls_proclist;
    var_decls_proclist = pp;
    (*pp).def = d;
}

struct var_decls_strec * qc_parselib_px_typecheck(struct var_decls_strec * owner,struct var_decls_strec * stname,int64 add) {
    struct var_decls_strec *  d;
    int64 m;
    d = qc_parselib_resolvetopname(owner,stname,(int64)0);
    if (!!(d)) {
        return d;
    }
    if (!(!!(add))) {
        return (struct var_decls_strec *)(0);
    }
    d = qc_lib_getduplnameptr(var_decls_stmodule,stname,(int64)5);
    qc_lib_adddef(var_decls_stmodule,d);
    m = qc_lib_createusertype(d);
    var_decls_ttbasetype[(m)] = (int32)0;
    (*d).mode = (int16)(m);
    return d;
}

struct var_decls_strec * qc_parselib_resolvetopname(struct var_decls_strec * owner,struct var_decls_strec * stnewname,int64 fmodule) {
    struct var_decls_strec *  powner;
    struct var_decls_strec *  def;
    struct var_decls_strec *  p;
    int64 score;
    int64 s;
    score = (int64)0;
    def = (struct var_decls_strec *)(0);
    p = (*stnewname).nextdupl;
L1309:;
    while (!!(p)) {
        powner = (*p).owner;
        switch ((int64)((*powner).nameid)) {
        case 6:;
            if ((powner == owner)) {
                return p;
            }
            break;
        case 2:;
            if ((score < (int64)3)) {
                def = p;
                score = (int64)1;
            }
            break;
        case 3:;
            if (!!((*var_decls_currmodule).importmap[((int64)((*powner).attribs.ax_moduleno))-1])) {
                s = ((powner == var_decls_stsysmodule)?(int64)2:(int64)1);
                if (((s > score) && !!((*p).attribs.ax_global))) {
                    def = p;
                    score = s;
                }
            }
            break;
        case 4:;
            if ((score < (int64)2)) {
                def = p;
                score = s;
            }
            break;
        case 5:;
            if ((!!(qc_parselib_typeallowed) && (score < (int64)2))) {
                def = p;
                score = (int64)2;
            }
            break;
        default:;
            if (!!(fmodule)) {
                if (((int64)((*p).nameid)==(int64)3) || ((int64)((*p).nameid)==(int64)4) || ((int64)((*p).nameid)==(int64)2)) {
                    if ((score <= (int64)3)) {
                        def = p;
                        score = (int64)4;
                    }
                }
            }
        }
        p = (*p).nextdupl;
L1310:;
    }
L1311:;
    return def;
}

void qc_parselib_px_name(struct var_decls_strec * stmod,struct var_decls_strec * stproc,struct var_decls_unitrec * p,int64 fmodule) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  owner;
    struct var_decls_strec *  pdef;
    struct var_decls_unitrec *  q;
    byte *  name;
    ++var_decls_allnames;
    owner = ((stproc == 0)?stmod:stproc);
    pdef = (*p).def;
    d = qc_parselib_resolvetopname(owner,pdef,fmodule);
    if (!!(d)) {
        (*p).def = d;
        ++var_decls_allfoundnames;
        if (((int64)((*d).nameid)==(int64)9)) {
            q = (*d).code;
            (*p).tag = (int32)1;
            (*p).value = (*q).value;
            (*p).valuemode = (int32)((*d).mode);
            (*p).slength = (*q).slength;
        } else if (((int64)((*d).nameid)==(int64)15)) {
            qc_support_nxerror((byte*)"FOUND ENUMID",p);
        } else if (((int64)((*d).nameid)==(int64)10)) {
            if ((((*d).owner == var_decls_stmodule) && !!(stproc))) {
                name = (*d).name;
            }
        } else if (((int64)((*d).nameid)==(int64)5)) {
            (*p).tag = (int32)149;
            (*p).valuemode = (int32)((*(*p).def).mode);
        } else if (((int64)((*d).nameid)==(int64)18)) {
            qc_support_nxerror((byte*)"FOUND ALIAS",p);
        }
    }
    else {
        ++var_decls_allnotfoundnames;
        if (((int64)((*owner).nameid) == (int64)6)) {
            (*p).def = qc_lib_getduplnameptr(owner,(*p).def,(int64)11);
            qc_lib_adddef(owner,(*p).def);
            (*(*p).def).mode = (int16)35;
        }
        else {
            printf("%s %d %s\n",(char*)((*pdef).name),(*p).lineno,(char*)(qc_tables_jtagnames[((int64)((*p).tag))]));
            qc_support_nxerror((byte*)"Undefined",p);
        }
    }
}

void qc_parselib_evalbinop(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64 x;
    int64 y;
    int64 z;
    int64 xt;
    int64 yt;
    xt = (int64)((*a).valuemode);
    yt = (int64)((*b).valuemode);
    if (((xt == yt) && (yt == (int64)3))) {
        qc_parselib_evalbinop_real(p,a,b);
        return;
    }
    if (!(((xt == yt) && (yt == (int64)1)))) {
        return;
    }
    x = (*a).value;
    y = (*b).value;
    switch ((int64)((*p).tag)) {
    case 103:;
        z = (x + y);
        break;
    case 104:;
        z = (x - y);
        break;
    case 105:;
        z = (x * y);
        break;
    case 107:;
        z = (x / y);
        break;
    case 80:;
        z = ((y << (int64)32) | (x & (int64)4294967295));
        qc_parselib_makenewconst(p,z,(int64)4);
        return;
        break;
    default:;
        return;
    }
    qc_parselib_makenewconst(p,z,(int64)1);
}

static void qc_parselib_evalbinop_real(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    double x;
    double y;
    double z;
    x = (*a).xvalue;
    y = (*b).xvalue;
    switch ((int64)((*p).tag)) {
    case 103:;
        z = (x + y);
        break;
    case 104:;
        z = (x - y);
        break;
    case 105:;
        z = (x * y);
        break;
    case 106:;
        z = (x / y);
        break;
    default:;
        return;
    }
    qc_parselib_makenewconst(p,*(int64*)&z,(int64)3);
}

static void qc_parselib_makenewconst(struct var_decls_unitrec * p,int64 value,int64 t) {
    int64 a;
    int64 b;
    (*p).tag = (int32)1;
    (*p).value = value;
    (*p).valuemode = (int32)(t);
    (*p).a = (struct var_decls_unitrec *)(0);
    (*p).b = (struct var_decls_unitrec *)(0);
}

struct var_decls_strec * qc_parselib_finddupl(struct var_decls_strec * owner,struct var_decls_strec * lst) {
    struct var_decls_strec *  d;
    d = lst;
L1312:;
    while (!!(d)) {
        if ((((*d).owner == owner) || (owner == 0))) {
            if ((((int64)((*d).nameid) == (int64)18) || ((int64)((*d).nameid) == (int64)19))) {
                return (*d).equiv;
            }
            return d;
        }
        d = (*d).nextdupl;
L1313:;
    }
L1314:;
    return (struct var_decls_strec *)(0);
}

void qc_parselib_px_dot(struct var_decls_strec * stmod,struct var_decls_strec * stproc,struct var_decls_unitrec * p) {
    struct var_decls_strec *  qdef;
    struct var_decls_strec *  rdef;
    struct var_decls_strec *  d;
    struct var_decls_strec *  newd;
    struct var_decls_strec *  e;
    struct var_decls_strec *  fielddef;
    struct var_decls_strec *  owner;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    int64 nfields;
    owner = ((stproc == 0)?stmod:stproc);
    q = (*p).a;
    r = (*p).b;
    rdef = (*r).def;
    if (((int64)((*q).tag)==(int64)3)) {
        d = (*q).def;
    } else if (((int64)((*q).tag)==(int64)149)) {
        d = (*q).def;
        goto L1315;
    }
    else {
        rdef = (*r).def;
        goto L1316;
    }
    switch ((int64)((*d).nameid)) {
    case 4:;
    case 2:;
    case 3:;
    case 5:;
    case 6:;
    case 7:;
//dotype:
L1315:;
        newd = qc_parselib_finddupl(d,(*rdef).nextdupl);
        if (!!(newd)) {
            switch ((int64)((*newd).nameid)) {
            case 15:;
                (*p).tag = (int32)1;
                (*p).value = (int64)((*newd).index);
                (*p).valuemode = (int32)1;
                break;
            case 9:;
                q = (*newd).code;
                if (((int64)((*q).tag)==(int64)1)) {
                    (*p).tag = (int32)1;
                    (*p).value = (*q).value;
                    (*p).valuemode = (int32)((*newd).mode);
                    (*p).a = ((*p).b = (struct var_decls_unitrec *)(0));
                }
                else {
                    qc_support_nxerror((byte*)"Rxdot:const?",p);
                }
                break;
            case 5:;
                (*p).tag = (int32)149;
                (*p).valuemode = (int32)((*newd).mode);
                (*p).def = newd;
                break;
            case 10:;
                (*p).tag = (int32)3;
                (*p).def = newd;
                break;
            case 6:;
            case 7:;
                (*p).tag = (int32)3;
                (*p).def = newd;
                (*p).a = ((*p).b = (struct var_decls_unitrec *)(0));
                (*p).dottedname = (uint8)1u;
                break;
            case 19:;
L1317:;
                do {
                    newd = (*newd).equiv;
L1318:;
                } while (!((int64)((*newd).nameid) != (int64)19));;
L1319:;
                (*p).tag = (int32)3;
                (*p).def = newd;
                break;
            default:;
                printf("%s %s %s\n",(char*)(pq_common_namenames[((int64)((*newd).nameid))]),(char*)((byte*)"."),(char*)((*newd).name));
                qc_support_nxerror((byte*)"Rxdot:.name not allowed here",p);
            }
        }
        else {
            printf("%s%s%s\n",(char*)((*d).name),(char*)((byte*)"."),(char*)((*rdef).name));
            qc_support_nxerror((byte*)"Can't resolve",p);
        }
        break;
    case 11:;
    case 10:;
    case 12:;
    case 13:;
    case 14:;
//doexprdot:
L1316:;
        nfields = (int64)0;
        fielddef = (struct var_decls_strec *)(0);
        e = (*rdef).nextdupl;
L1320:;
        while (!!(e)) {
            if (((int64)((*e).nameid)==(int64)13) || ((int64)((*e).nameid)==(int64)9) || ((int64)((*e).nameid)==(int64)6) || ((int64)((*e).nameid)==(int64)5) || ((int64)((*e).nameid)==(int64)10) || ((int64)((*e).nameid)==(int64)7) || ((int64)((*e).nameid)==(int64)19)) {
                ++nfields;
                fielddef = e;
            }
            e = (*e).nextdupl;
L1321:;
        }
L1322:;
        if ((nfields==(int64)0)) {
            printf("%s\n",(char*)((*rdef).name));
            qc_support_nxerror((byte*)"Can't find field",p);
        }
        else {
            if (((int64)((*rdef).nameid) != (int64)14)) {
                (*rdef).nameid = (uint8)14u;
                var_decls_genfieldnames[(++var_decls_ngenfieldnames)-1].def = rdef;
                (*rdef).offset = (int32)(var_decls_ngenfieldnames);
            }
        }
        break;
    default:;
        printf("%s\n",(char*)(pq_common_namenames[((int64)((*d).nameid))]));
        qc_support_nxerror((byte*)"RXDOT:Unknown nameid",p);
    }
}

void qc_parselib_evalmonop(struct var_decls_unitrec * p) {
    int64 xt;
    int64 x;
    int64 z;
    if (((int64)((*(*p).a).tag)==(int64)1)) {
    } else if (((int64)((*(*p).a).tag)==(int64)149)) {
        if (((int64)((*p).tag)==(int64)183)) {
            return;
        } else if (((int64)((*p).tag)==(int64)180)) {
            return;
        }
    }
    else {
        return;
    }
    x = (*(*p).a).value;
    xt = (int64)((*(*p).a).valuemode);
    if ((xt==(int64)1)) {
        switch ((int64)((*p).tag)) {
        case 154:;
            z = -(x);
            break;
        default:;
            return;
        }
    } else if ((xt==(int64)5)) {
        switch ((int64)((*p).tag)) {
        case 180:;
            z = (int64)((*(*p).a).slength);
            break;
        default:;
            return;
        }
    }
    else {
        return;
    }
    qc_parselib_makenewconst(p,z,(int64)1);
}

int64 qc_parselib_checkdict(struct var_decls_unitrec * p) {
    int64 nkeywords;
    int64 isconst;
    struct var_decls_unitrec *  q;
    int64 n;
    if (((int64)((*p).tag) != (int64)79)) {
        return (int64)0;
    }
    n = (nkeywords = (int64)0);
    isconst = (int64)1;
    q = (*p).a;
L1323:;
    while (!!(q)) {
        ++n;
        if (((int64)((*q).tag)==(int64)85)) {
            ++nkeywords;
        }
        q = (*q).nextunit;
L1324:;
    }
L1325:;
    if ((nkeywords == (int64)0)) {
        return (int64)0;
    }
    if ((nkeywords != n)) {
        qc_support_nxerror((byte*)"Dict: not all key:values",(struct var_decls_unitrec *)(0));
    }
    (*p).tag = (int32)81;
    return (int64)1;
}

void qc_parselib_checkconstlist(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    struct var_decls_strec *  stname;
    int64 n;
    q = (*p).a;
    n = (int64)0;
L1326:;
    while (!!(q)) {
        ++n;
        if (((int64)((*q).tag)==(int64)1)) {
        } else if (((int64)((*q).tag)==(int64)3)) {
            if (!(!!((*(*q).def).attribs.ax_autovar))) {
                return;
            }
        }
        else {
            return;
        }
        q = (*q).nextunit;
L1327:;
    }
L1328:;
    if ((n == (int64)0)) {
        return;
    }
    stname = qc_lib_getavname(var_decls_stmodule,(int64)10);
    (*stname).mode = (int16)35;
    (*stname).code = qc_lib_createunit2((int64)((*p).tag),(*p).a,(*p).b);
    (*stname).attribs.ax_equals = (uint8)1u;
    (*p).tag = (int32)3;
    (*p).def = stname;
}

static void qc_pclgen_do_tag(struct var_decls_unitrec * p) {
    int64 oldmlineno;
    int64 opc;
    int64 n;
    int64 m;
    int64 t;
    int64 lowerx;
    int64 lab1;
    int64 lab2;
    struct var_decls_unitrec *  a;
    struct var_decls_unitrec *  b;
    struct var_decls_unitrec *  c;
    struct var_decls_strec *  d;
    struct var_decls_strec *  owner;
    int64 x;
    int64 aa;
    byte *  s;
    double fsize;
    struct var_decls_unitrec *  mlist[50];
    int64 i;
    int64 nmult;
    a = (*p).a;
    b = (*p).b;
    c = (*p).c;
    oldmlineno = var_decls_mlineno;
    var_decls_mlineno = (int64)((*p).lineno);
    switch ((int64)((*p).tag)) {
    case 48:;
    case 49:;
        qc_pclgen_do_print(p,a,b);
        break;
    case 50:;
    case 51:;
        qc_pclgen_do_fprint(p,a,b,c);
        break;
    case 57:;
    case 58:;
        qc_pclgen_do_read(p,a,b);
        break;
    case 17:;
    case 19:;
        qc_pclgen_do_assign(p,a,b);
        break;
    case 20:;
        qc_pclgen_do_to(p,a,b,c);
        break;
    case 31:;
        qc_pclgen_do_while(p,qc_pclgen_checkeqeq(a),b,c);
        break;
    case 32:;
        qc_pclgen_do_repeat(p,a,qc_pclgen_checkeqeq(b));
        break;
    case 25:;
    case 23:;
    case 24:;
        qc_pclgen_do_forstep(p,a,b,c);
        break;
    case 26:;
    case 28:;
    case 27:;
    case 29:;
        qc_pclgen_do_forall(p,a,b,c);
        break;
    case 41:;
        qc_pclgen_do_do(p,a);
        break;
    case 30:;
        qc_pclgen_do_cfor(p,a,b);
        break;
    case 21:;
        qc_pclgen_do_if(p,qc_pclgen_checkeqeq(a),b,c);
        break;
    case 22:;
        qc_pclgen_do_longif(p,a,b);
        break;
    case 14:;
        qc_pclgen_do_callproc(p,a,b);
        break;
    case 66:;
    case 92:;
        qc_pclgen_do_callhostproc(p,a);
        break;
    case 16:;
        qc_pclgen_do_return(p,a);
        break;
    case 229:;
    case 230:;
    case 231:;
    case 232:;
        qc_pclgen_do_preincr(p,a);
        break;
    case 46:;
        qc_pclgen_evalref(a);
        qc_pclgen_evalref(b);
        qc_pcllib_genpc((int64)37);
        break;
    case 39:;
    case 36:;
    case 37:;
    case 38:;
        qc_pclgen_do_exit(p,a);
        break;
    case 35:;
        qc_pcllib_lastopc = &qc_pclgen_dummyop;
        d = (*p).def;
        if (((int64)((*d).index) == (int64)0)) {
            (*d).index = (int32)((qc_pcllib_pcindex + (int64)1));
        }
        else {
            lab1 = (int64)((*d).index);
            qc_pclgen_definefwdlabel(&lab1);
        }
        break;
    case 33:;
        qc_pclgen_do_goto(p,a);
        break;
    case 61:;
        if (!!(a)) {
            qc_pclgen_do_tag(a);
        }
        else {
            qc_pcllib_genpc((int64)19);
        }
        qc_pcllib_genpc((int64)73);
        break;
    case 44:;
    case 45:;
        qc_pclgen_do_switch(p,a,b,c);
        break;
    case 42:;
    case 43:;
        qc_pclgen_do_case(p,a,b,c);
        break;
    case 62:;
        qc_pclgen_do_try(p,a,b);
        break;
    case 65:;
        qc_pclgen_do_tag(a);
        qc_pcllib_genpc((int64)208);
        break;
    case 93:;
        qc_pclgen_do_applyop(p,a,b,c);
        break;
    case 15:;
        qc_pclgen_do_callmproc(p,a,b,(int64)0);
        break;
    case 67:;
        qc_pclgen_do_tag(a);
        qc_pcllib_genpc_int((int64)71,(int64)1);
        break;
    case 1:;
        x = (*p).value;
        switch ((int64)((*p).valuemode)) {
        case 5:;
            s = (*p).svalue;
            if (((int64)((*p).slength) == (int64)0)) {
                qc_pcllib_genpc((int64)20);
            }
            else {
                qc_pcllib_genpc_str((int64)15,s,(int64)((*p).slength));
            }
            break;
        case 1:;
        case 40:;
            qc_pcllib_genpc_int((int64)11,(*p).value);
            break;
        case 3:;
        case 49:;
            if (((*p).xvalue == (float)0.000000)) {
                qc_pcllib_genpc_int((int64)18,(int64)3);
            }
            else {
                qc_pcllib_genpc_int((int64)13,(*p).value);
            }
            break;
        case 2:;
        case 47:;
            qc_pcllib_genpc_int((int64)12,(*p).value);
            break;
        case 4:;
            qc_pcllib_genpc_int((int64)14,(*p).value);
            break;
        default:;
            printf("%s\n",(char*)(var_decls_ttname[((int64)((*p).valuemode))]));
            qc_support_gerror((byte*)"CONST: Can't push this type",p);
        }
        break;
    case 3:;
        d = (*p).def;
        switch ((int64)((*d).nameid)) {
        case 6:;
            qc_pcllib_genpc_s((int64)9,d);
            break;
        case 10:;
            qc_pcllib_genpc_s((int64)5,d);
            break;
        case 11:;
            qc_pcllib_genpc_s((int64)6,d);
            break;
        case 12:;
            qc_pcllib_genpc_s((int64)6,d);
            if (!!((*d).attribs.ax_byrefmode)) {
                qc_pcllib_genpc((int64)29);
            }
            break;
        case 16:;
            if (((int64)((*d).index) == (int64)0)) {
                (*d).index = (int32)(qc_pclgen_createfwdlabel());
            }
            qc_pcllib_genpc_lab((int64)10,(int64)((*d).index));
            break;
        case 7:;
            qc_pcllib_genpc_s((int64)206,d);
            break;
        default:;
            printf("%s %s\n",(char*)(pq_common_namenames[((int64)((*d).nameid))]),(char*)((*d).name));
            qc_support_gerror((byte*)"Name?",p);
        }
        break;
    case 95:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 108:;
    case 109:;
    case 110:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    case 125:;
    case 142:;
    case 143:;
    case 102:;
    case 111:;
//dobinop:
L1329:;
        if ((b == 0)) {
            qc_support_gerror((byte*)"Binop: opnd missing",p);
        }
        opc = qc_pclgen_getpclop((int64)((*p).tag));
        qc_pclgen_do_tag(a);
        qc_pclgen_do_tag(b);
        qc_pcllib_genpc(opc);
        break;
    case 96:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
        if ((b == 0)) {
            qc_support_gerror((byte*)"Binop: opnd missing",p);
        }
        p = qc_pclgen_checkeqeq(p);
        opc = qc_pclgen_getpclop((int64)((*p).tag));
        qc_pclgen_do_tag((*p).a);
        qc_pclgen_do_tag((*p).b);
        qc_pcllib_genpc(opc);
        break;
    case 211:;
    case 212:;
    case 213:;
    case 214:;
    case 215:;
    case 216:;
    case 217:;
    case 218:;
    case 219:;
    case 220:;
    case 221:;
    case 222:;
    case 223:;
    case 225:;
    case 224:;
        opc = qc_pclgen_getpclop((int64)((*p).tag));
        qc_pclgen_evalref(a);
        qc_pclgen_do_tag(b);
        qc_pcllib_genpc(opc);
        break;
    case 107:;
        qc_pclgen_do_idiv(a,b);
        break;
    case 72:;
        qc_pclgen_do_and(a,b);
        break;
    case 73:;
        qc_pclgen_do_or(a,b);
        break;
    case 74:;
        qc_pclgen_do_tag(a);
        if (!(!!(qc_pclgen_islogical(a)))) {
            qc_pcllib_genpc((int64)103);
        }
        qc_pclgen_do_tag(b);
        if (!(!!(qc_pclgen_islogical(a)))) {
            qc_pcllib_genpc((int64)103);
        }
        qc_pcllib_genpc((int64)162);
        break;
    case 144:;
        if (((int64)((*a).tag) == (int64)1)) {
            qc_support_gerror((byte*)"pushptr/const",(struct var_decls_unitrec *)(0));
        }
        qc_pclgen_do_tag(a);
        qc_pcllib_genpc((int64)29);
        break;
    case 75:;
        qc_pclgen_do_tag(a);
        if (!(!!(qc_pclgen_islogical(a)))) {
            qc_pcllib_genpc((int64)103);
        }
        qc_pcllib_genpc((int64)101);
        break;
    case 183:;
        if (((int64)((*a).tag) == (int64)149)) {
            m = (int64)((*a).valuemode);
            if ((((int64)(var_decls_ttbasetype[(m)]) >= (int64)41) && ((int64)(var_decls_ttbasetype[(m)]) <= (int64)43))) {
                fsize = ((double)(var_decls_ttbitwidth[(m)]) / (float)8.000000);
                qc_pcllib_genpc_int((int64)13,*(int64*)&fsize);
            }
            else {
                qc_pclgen_genpushint((uint64)(var_decls_ttsize[(m)]));
            }
        }
        else {
            qc_pclgen_do_tag(a);
            qc_pcllib_genpc(qc_pclgen_getpclop((int64)183));
        }
        break;
    case 182:;
        if (((int64)((*a).tag) == (int64)149)) {
            m = (int64)((*a).valuemode);
            qc_pclgen_genpushint((uint64)(var_decls_ttbitwidth[(m)]));
        }
        else {
            qc_pclgen_do_tag(a);
            qc_pcllib_genpc(qc_pclgen_getpclop((int64)182));
        }
        break;
    case 203:;
        if (((int64)((*a).tag) == (int64)149)) {
            if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)2) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)41) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)43) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)44) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)45) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)46) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)47)) {
                aa = (int64)0;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)37)) {
                aa = (int64)-128;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)38)) {
                aa = (int64)-32768;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)39)) {
                aa = (int64)-2147483648;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)40) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)1)) {
                aa = (int64)((uint64)9223372036854775808u);
            }
            else {
                goto L1330;
            }
            qc_pclgen_genpushint((uint64)(aa));
        }
        else {
//dominval:
L1330:;
            qc_pclgen_do_tag(a);
            qc_pcllib_genpc(qc_pclgen_getpclop((int64)203));
        }
        break;
    case 204:;
        if (((int64)((*a).tag) == (int64)149)) {
            opc = (int64)11;
            if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)41)) {
                aa = (int64)1;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)42)) {
                aa = (int64)3;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)43)) {
                aa = (int64)15;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)44)) {
                aa = (int64)255;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)45)) {
                aa = (int64)65535;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)46)) {
                aa = (int64)4294967295;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)47) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)2)) {
                aa = (int64)((uint64)18446744073709551615u);
                opc = (int64)12;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)37)) {
                aa = (int64)127;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)38)) {
                aa = (int64)32767;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)39)) {
                aa = (int64)2147483647;
            } else if (((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)40) || ((int64)(var_decls_ttbasetype[((int64)((*a).valuemode))])==(int64)1)) {
                aa = (int64)((uint64)9223372036854775807u);
            }
            else {
                goto L1331;
            }
            if ((opc == (int64)11)) {
                qc_pclgen_genpushint((uint64)(aa));
            }
            else {
                qc_pcllib_genpc_int(opc,aa);
            }
        }
        else {
//domaxval:
L1331:;
            qc_pclgen_do_tag(a);
            qc_pcllib_genpc(qc_pclgen_getpclop((int64)204));
        }
        break;
    case 154:;
    case 155:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    case 160:;
    case 161:;
    case 162:;
    case 163:;
    case 164:;
    case 165:;
    case 166:;
    case 167:;
    case 168:;
    case 169:;
    case 170:;
    case 171:;
    case 172:;
    case 173:;
    case 174:;
    case 175:;
    case 176:;
    case 177:;
    case 178:;
    case 179:;
    case 180:;
    case 181:;
    case 185:;
    case 186:;
    case 187:;
    case 188:;
    case 190:;
    case 191:;
    case 192:;
    case 193:;
    case 194:;
    case 195:;
    case 196:;
    case 198:;
    case 199:;
    case 201:;
    case 205:;
    case 206:;
    case 76:;
    case 189:;
    case 202:;
        opc = qc_pclgen_getpclop((int64)((*p).tag));
        qc_pclgen_do_tag(a);
        qc_pcllib_genpc(opc);
        break;
    case 184:;
        qc_pcllib_genpc((int64)19);
        qc_pclgen_do_tag(a);
        qc_pclgen_callhostfn((int64)40,(int64)1);
        break;
    case 88:;
        if (((int64)((*a).tag) == (int64)3)) {
            d = (*a).def;
            if (((int64)((*d).mode) == (int64)0)) {
                printf("%s\n",(char*)((*d).name));
                qc_support_gerror((byte*)"Proc return value",(struct var_decls_unitrec *)(0));
            }
        }
        qc_pclgen_do_callproc(p,a,b);
        break;
    case 89:;
        qc_pclgen_do_callmproc(p,a,b,(int64)1);
        break;
    case 207:;
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64)91);
        break;
    case 209:;
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64)90);
        break;
    case 208:;
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64)96);
        break;
    case 210:;
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64)95);
        break;
    case 127:;
    case 129:;
        qc_pclgen_do_tag(a);
        qc_pclgen_do_tag(b);
        qc_pcllib_genpc((int64)194);
        break;
    case 131:;
    case 134:;
        qc_pclgen_do_tag(a);
        qc_pclgen_do_tag(b);
        qc_pcllib_genpc((int64)195);
        break;
    case 138:;
        qc_pclgen_do_tag(a);
        qc_pclgen_do_tag(b);
        qc_pcllib_genpc_int((int64)201,(int64)((*p).valuemode));
        break;
    case 130:;
    case 135:;
        qc_pclgen_do_tag(b);
        qc_pclgen_do_tag(a);
        if (!!(c)) {
            qc_pclgen_do_tag(c);
            qc_pcllib_genpc((int64)197);
        }
        else {
            qc_pcllib_genpc((int64)196);
        }
        break;
    case 139:;
        qc_pclgen_do_tag(a);
        d = (*b).def;
        if (((int64)((*d).nameid)==(int64)6) || ((int64)((*d).nameid)==(int64)7)) {
            owner = (*d).owner;
            if (((int64)((*owner).nameid)==(int64)2) || ((int64)((*owner).nameid)==(int64)4)) {
                t = (int64)0;
            }
            else {
                t = (int64)((*owner).mode);
            }
            qc_pcllib_genpc_int((int64)204,t);
            qc_pcllib_genopnd_s(d);
        } else if (((int64)((*d).nameid)==(int64)5)) {
            qc_pcllib_genpc_int2((int64)205,(int64)((*(*d).owner).mode),(int64)((*d).mode));
        }
        else {
            qc_pcllib_genpc_int((int64)82,(int64)((*d).offset));
        }
        break;
    case 77:;
    case 78:;
        if (!!(b)) {
            lowerx = qc_lib_getconstvalue(b,(int64)100);
        }
        else {
            lowerx = (int64)1;
        }
        if ((a == 0)) {
            if ((lowerx == (int64)1)) {
                qc_pcllib_genpc((int64)21);
            }
            else {
                qc_pcllib_genpc_int((int64)22,lowerx);
            }
        }
        else {
            n = (int64)0;
L1332:;
            while (!!(a)) {
                ++n;
                qc_pclgen_do_tag(a);
                a = (*a).nextunit;
L1333:;
            }
L1334:;
            qc_pcllib_genpc_int2((int64)75,n,lowerx);
        }
        break;
    case 79:;
        if ((a == 0)) {
            qc_pcllib_genpc((int64)23);
        }
        else {
            n = (int64)0;
L1335:;
            while (!!(a)) {
                ++n;
                qc_pclgen_do_tag(a);
                a = (*a).nextunit;
L1336:;
            }
L1337:;
            qc_pcllib_genpc_int((int64)79,n);
        }
        break;
    case 81:;
        n = (int64)0;
L1338:;
        while (!!(a)) {
            ++n;
            qc_pclgen_do_tag(a);
            a = (*a).nextunit;
L1339:;
        }
L1340:;
        qc_pcllib_genpc_int((int64)81,n);
        break;
    case 80:;
        qc_pclgen_do_tag(a);
        qc_pclgen_do_tag(b);
        qc_pcllib_genpc((int64)80);
        break;
    case 86:;
    case 87:;
        qc_pclgen_do_assign(p,a,b);
        break;
    case 90:;
        lab1 = qc_pclgen_createfwdlabel();
        lab2 = qc_pclgen_createfwdlabel();
        qc_pclgen_genjumpcond((int64)0,a,lab1);
        qc_pclgen_do_tag(b);
        qc_pclgen_genjumpl(lab2);
        qc_pclgen_definefwdlabel(&lab1);
        qc_pclgen_do_tag(c);
        qc_pcllib_genpc((int64)1);
        qc_pclgen_definefwdlabel(&lab2);
        break;
    case 147:;
        qc_pclgen_do_convert((int64)((*p).valuemode),a);
        break;
    case 148:;
        qc_pclgen_do_tag(a);
        qc_pcllib_genpc_int((int64)84,(int64)((*p).valuemode));
        break;
    case 145:;
        if (((int64)((*a).tag) == (int64)144)) {
            qc_pclgen_do_tag((*a).a);
        }
        else {
            qc_pclgen_evalref(a);
        }
        break;
    case 146:;
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((int64)38);
        break;
    case 149:;
        qc_pcllib_genpc_int((int64)16,(int64)((*p).valuemode));
        break;
    case 91:;
        qc_pclgen_do_selectx(a,b,c);
        break;
    case 82:;
L1341:;
        while ((!!(a) && !!((*a).nextunit))) {
            qc_pclgen_do_tag(a);
            a = (*a).nextunit;
L1342:;
        }
L1343:;
        qc_pclgen_do_tag(a);
        break;
    case 68:;
        qc_pcllib_genpc((int64)21);
        qc_pclgen_do_tag(a);
        break;
    case 8:;
        qc_pcllib_genpc_int((int64)18,(int64)((*p).valuemode));
        break;
    case 85:;
        qc_pclgen_do_tag(a);
        qc_pclgen_do_tag(b);
        break;
    case 9:;
        qc_pcllib_genpc_str((int64)15,(*p).svalue,(int64)((*p).slength));
        qc_pcllib_genpc_int((int64)85,(int64)7);
        break;
    case 54:;
        qc_pclgen_do_print(p,a,b);
        break;
    case 55:;
        qc_pclgen_do_fprint(p,a,b,c);
        break;
    case 126:;
        qc_pclgen_do_clamp(a,b,c);
        break;
    case 94:;
        qc_pclgen_do_applyopx(a,b,c);
        break;
    case 150:;
        opc = qc_pclgen_getpclop((int64)((*p).opcode));
        qc_pcllib_genpc_int2((int64)17,opc,qc_pclgen_noperands);
        break;
    case 83:;
        nmult = (int64)0;
L1344:;
        while (!!(a)) {
            if ((nmult >= (int64)50)) {
                qc_support_gerror((byte*)"Too many mult elems",(struct var_decls_unitrec *)(0));
            }
            mlist[(++nmult)-1] = a;
            a = (*a).nextunit;
L1345:;
        }
L1346:;
L1347:;
        for (i=nmult;i>=(int64)1;--i) {
L1348:;
            qc_pclgen_do_tag(mlist[(i)-1]);
L1349:;
        }
L1350:;
        break;
    default:;
        printf("%s\n",(char*)(qc_tables_jtagnames[((int64)((*p).tag))]));
        qc_support_gerror((byte*)"E:CAN'T EVALUATE",p);
    }
    var_decls_mlineno = oldmlineno;
}

int64 qc_pclgen_codegen(int64 n) {
    static struct var_decls_modulerec m;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    memcpy(&m,&var_decls_moduletable[(n)],118);
    qc_pcllib_linetable = m.linetable;
    qc_pclgen_initgenpcl((int64)(m.sourcelen));
    qc_pclgen_convertalltypes();
    d = (*m.stmodule).deflist;
L1351:;
    while (!!(d)) {
        if ((((int64)((*d).nameid) == (int64)6) && (qc_lib_getscope(d) != (int64)2))        ) {
            qc_pclgen_do_procdef(d);
            e = (*d).deflist;
L1354:;
            while (!!(e)) {
                if (((int64)((*e).nameid) == (int64)6)) {
                    qc_pclgen_do_procdef(e);
                }
                e = (*e).nextdef;
L1355:;
            }
L1356:;
        }
        else if (((int64)((*d).nameid) == (int64)5)) {
            e = (*d).deflist;
L1357:;
            while (!!(e)) {
                if (((int64)((*e).nameid) == (int64)6)) {
                    qc_pclgen_do_procdef(e);
                }
                e = (*e).nextdef;
L1358:;
            }
L1359:;
        }
        d = (*d).nextdef;
L1352:;
    }
L1353:;
    qc_pclgen_genstartproc(m.stmodule);
    qc_pcllib_genpc((int64)4);
    m.pccode = qc_pcllib_pccode;
    m.npccode = (int32)(qc_pcllib_npccode);
    m.pcindex = (int32)(qc_pcllib_pcindex);
    m.linetable = qc_pcllib_linetable;
    memcpy(&var_decls_moduletable[(n)],&m,118);
    return (int64)1;
}

void qc_pclgen_convertalltypes(void) {
    int64 i;
L1360:;
    for (i=(qc_pcllib_nconvertedtypes + (int64)1);i<=var_decls_ntypes;++i) {
L1361:;
        qc_pcllib_converttype(i);
L1362:;
    }
L1363:;
    qc_pcllib_nconvertedtypes = var_decls_ntypes;
}

static void qc_pclgen_scanidata(struct var_decls_strec * p) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  defs[2000];
    int64 i;
    int64 ndefs;
    qc_pclgen_genidata(p);
    d = (*p).deflist;
    if (!(!!(d))) {
        return;
    }
    ndefs = (int64)0;
L1364:;
    while (!!(d)) {
        ++ndefs;
        if ((ndefs > (int64)2000)) {
            qc_support_gerror((byte*)"Too many idata defs",(struct var_decls_unitrec *)(0));
        }
        defs[(ndefs)-1] = d;
        d = (*d).nextdef;
L1365:;
    }
L1366:;
L1367:;
    for (i=ndefs;i>=(int64)1;--i) {
L1368:;
        d = defs[(i)-1];
        if (!!((*d).attribs.ax_autovar)) {
            qc_pclgen_scanidata(d);
        }
L1369:;
    }
L1370:;
L1371:;
    for (i=ndefs;i>=(int64)1;--i) {
L1372:;
        d = defs[(i)-1];
        if (!(!!((*d).attribs.ax_autovar))) {
            qc_pclgen_scanidata(d);
        }
L1373:;
    }
L1374:;
}

static void qc_pclgen_genidata(struct var_decls_strec * p) {
    struct var_decls_unitrec *  e;
    if (((int64)((*p).nameid) == (int64)2)) {
        return;
    }
    if ((qc_lib_getscope(p) == (int64)2)) {
        return;
    }
    if (((int64)((*p).nameid) == (int64)10)) {
        e = (*p).code;
        if ((e == 0)) {
            return;
        }
        qc_pclgen_do_tag(e);
        qc_pcllib_genpc_s(((int64)32 + (int64)((*p).attribs.ax_frame)),p);
    }
}

static void qc_pclgen_initgenpcl(int64 sourcelen) {
    struct var_decls_strec *  dgen;
    qc_pcllib_initpcl(msysc_m_imax((sourcelen / (int64)2),(int64)1000));
    qc_pclgen_loopindex = (int64)0;
    qc_pcllib_stcurrproc = (struct var_decls_strec *)(0);
    qc_pclgen_st_startproc = qc_lib_getduplnameptr(var_decls_stmodule,qc_lex_addnamestr((byte*)"$startproc"),(int64)6);
    (*qc_pclgen_st_startproc).attribs.ax_global = (uint8)1u;
    (*qc_pclgen_st_startproc).mode = (int16)0;
    qc_lib_adddef_nodupl(var_decls_stmodule,qc_pclgen_st_startproc);
}

void qc_pclgen_doprogramstartup(void) {
    int64 i;
    struct var_decls_strec *  d;
    qc_pcllib_initpcl((int64)1000);
L1375:;
    for (i=(int64)1;i<=var_decls_nmodules;++i) {
L1376:;
        d = qc_lib_finddefstr(var_decls_moduletable[(i)].stmodule,(byte*)"$startproc");
        if ((d == 0)) {
            printf("%s\n",(char*)(var_decls_moduletable[(i)].name));
            qc_support_gerror((byte*)"Can't find $startproc",(struct var_decls_unitrec *)(0));
        }
        qc_pcllib_genpc_s((int64)63,d);
        qc_pcllib_genopnd_int((int64)0);
L1377:;
    }
L1378:;
    var_decls_stopseq = &(*qc_pcllib_pccode)[((qc_pcllib_pcindex + (int64)1))-1];
    qc_pclgen_genpushint((uint64)((int64)0));
    qc_pcllib_genpc((int64)73);
    var_decls_raiseseq = &(*qc_pcllib_pccode)[((qc_pcllib_pcindex + (int64)1))-1];
    qc_pcllib_genpc((int64)208);
    qc_pcllib_genpc((int64)208);
    qc_pcllib_genpc((int64)208);
    qc_pcllib_genpc((int64)208);
    qc_pcllib_genpc((int64)4);
    var_decls_moduletable[((int64)0)].pccode = qc_pcllib_pccode;
    var_decls_moduletable[((int64)0)].npccode = (int32)(qc_pcllib_npccode);
    var_decls_moduletable[((int64)0)].pcindex = (int32)(qc_pcllib_pcindex);
    var_decls_moduletable[((int64)0)].linetable = qc_pcllib_linetable;
}

static void qc_pclgen_do_block(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    q = (*p).a;
L1379:;
    while (!!(q)) {
        qc_pclgen_do_tag(q);
        q = (*q).nextunit;
L1380:;
    }
L1381:;
}

static void qc_pclgen_do_print(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64 issprint;
    struct var_decls_unitrec *  x;
    issprint = (int64)(((int64)((*p).tag) == (int64)54));
    if (!!(issprint)) {
        qc_pclgen_callhostfn((int64)3,(int64)0);
    }
    else {
        if (!!(a)) {
            qc_pclgen_do_tag(a);
            qc_pclgen_callhostfn((int64)1,(int64)0);
        }
        else {
            qc_pclgen_callhostfn((int64)2,(int64)0);
        }
    }
    x = b;
L1382:;
    while (!!(x)) {
        if (((int64)((*x).tag)==(int64)12)) {
            qc_pclgen_do_tag((*x).b);
            qc_pclgen_do_tag((*x).a);
            qc_pclgen_callhostfn((int64)7,(int64)0);
        } else if (((int64)((*x).tag)==(int64)13)) {
            qc_pclgen_callhostfn((int64)10,(int64)0);
        }
        else {
            qc_pcllib_genpc((int64)19);
            qc_pclgen_do_tag(x);
            qc_pclgen_callhostfn((int64)7,(int64)0);
        }
        x = (*x).nextunit;
L1383:;
    }
L1384:;
    if (((int64)((*p).tag) == (int64)49)) {
        qc_pclgen_callhostfn((int64)9,(int64)0);
    }
    if (!!(issprint)) {
        qc_pcllib_genpc((int64)19);
        qc_pclgen_callhostfn((int64)6,(int64)1);
    }
    else {
        qc_pclgen_callhostfn((int64)5,(int64)0);
    }
}

static void qc_pclgen_do_fprint(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c) {
    int64 issfprint;
    struct var_decls_unitrec *  x;
    issfprint = (int64)(((int64)((*p).tag) == (int64)55));
    if (!!(issfprint)) {
        qc_pclgen_callhostfn((int64)3,(int64)0);
    }
    else {
        if (!!(a)) {
            qc_pclgen_do_tag(a);
            qc_pclgen_callhostfn((int64)1,(int64)0);
        }
        else {
            qc_pclgen_callhostfn((int64)2,(int64)0);
        }
    }
    qc_pclgen_do_tag(b);
    qc_pclgen_callhostfn((int64)4,(int64)0);
    x = c;
L1385:;
    while (!!(x)) {
        if (((int64)((*x).tag)==(int64)12)) {
            qc_pclgen_do_tag((*x).b);
            qc_pclgen_do_tag((*x).a);
            qc_pclgen_callhostfn((int64)7,(int64)0);
        } else if (((int64)((*x).tag)==(int64)13)) {
            qc_pclgen_callhostfn((int64)10,(int64)0);
        }
        else {
            qc_pcllib_genpc((int64)19);
            qc_pclgen_do_tag(x);
            qc_pclgen_callhostfn((int64)7,(int64)0);
        }
        x = (*x).nextunit;
L1386:;
    }
L1387:;
    if (((int64)((*p).tag) == (int64)51)) {
        qc_pclgen_callhostfn((int64)9,(int64)0);
    }
    if (!!(issfprint)) {
        qc_pcllib_genpc((int64)19);
        qc_pclgen_callhostfn((int64)6,(int64)1);
    }
    else {
        qc_pclgen_callhostfn((int64)5,(int64)0);
    }
}

static void qc_pclgen_do_read(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  xloop;
    if (((int64)((*p).tag) == (int64)58)) {
        if (!!(a)) {
            qc_pclgen_do_tag(a);
            qc_pclgen_callhostfn((int64)11,(int64)0);
        }
        else {
            qc_pcllib_genpc((int64)19);
            qc_pclgen_callhostfn((int64)11,(int64)0);
        }
    }
    xloop = b;
L1388:;
    while (!!(xloop)) {
        x = xloop;
        qc_pcllib_genpc((int64)19);
        if (((int64)((*x).tag) == (int64)12)) {
            qc_pclgen_do_tag((*x).b);
            qc_pclgen_callhostfn((int64)13,(int64)1);
            x = (*x).a;
        }
        else {
            qc_pcllib_genpc((int64)19);
            qc_pclgen_callhostfn((int64)13,(int64)1);
        }
        if (((int64)((*x).tag) == (int64)3)) {
            qc_pcllib_genpc_s(((int64)25 + (int64)((*(*x).def).attribs.ax_frame)),(*x).def);
            (*(*x).def).attribs.ax_used = (uint8)1u;
        }
        else {
            qc_pclgen_evalref(x);
            qc_pcllib_genpc((int64)30);
        }
        xloop = (*xloop).nextunit;
L1389:;
    }
L1390:;
}

static void qc_pclgen_do_assign(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64 fstore;
    int64 n;
    int64 mult;
    struct var_decls_unitrec *  q;
    struct var_decls_strec *  d;
    fstore = (int64)((((int64)((*p).tag) == (int64)86) | ((int64)((*p).tag) == (int64)87)));
    qc_pclgen_do_tag(b);
    if (((int64)((*p).tag)==(int64)19) || ((int64)((*p).tag)==(int64)87)) {
        qc_pcllib_genpc((int64)36);
    }
    if (((int64)((*a).tag) == (int64)83)) {
        a = (*a).a;
        mult = (int64)1;
    }
    else {
        mult = (int64)0;
    }
L1391:;
    while (!!(a)) {
        switch ((int64)((*a).tag)) {
        case 3:;
            d = (*a).def;
            if (((int64)((*d).nameid)==(int64)11)) {
                (*d).attribs.ax_used = (uint8)1u;
            } else if (((int64)((*d).nameid)==(int64)10)) {
            } else if (((int64)((*d).nameid)==(int64)12)) {
                if (!!((*d).attribs.ax_byrefmode)) {
                    qc_pcllib_genpc_s((int64)6,d);
                    qc_pcllib_genpc((!!(fstore)?(int64)31:(int64)30));
                    return;
                }
            }
            else {
                printf("%s %s\n",(char*)(pq_common_namenames[((int64)((*d).nameid))]),(char*)((*d).name));
                qc_support_gerror((byte*)"Can't assign to",(struct var_decls_unitrec *)(0));
            }
            qc_pcllib_genpc_s(((!!(fstore)?(int64)27:(int64)25) + (int64)((*d).attribs.ax_frame)),d);
            break;
        case 127:;
        case 131:;
        case 129:;
        case 134:;
        case 130:;
        case 135:;
        case 138:;
            qc_pclgen_evalref(a);
            qc_pcllib_genpc((!!(fstore)?(int64)31:(int64)30));
            break;
        case 77:;
            q = (*a).a;
            if ((q == 0)) {
                qc_support_gerror((byte*)"assign to ()?",(struct var_decls_unitrec *)(0));
            }
            else {
                n = (int64)0;
L1394:;
                while (!!(q)) {
                    ++n;
                    qc_pclgen_evalref(q);
                    q = (*q).nextunit;
L1395:;
                }
L1396:;
                qc_pcllib_genpc_int2((int64)75,n,(int64)1);
            }
            qc_pcllib_genpc((!!(fstore)?(int64)31:(int64)30));
            break;
        case 139:;
            qc_pclgen_evalref((*a).a);
            d = (*(*a).b).def;
            qc_pcllib_genpc_int((int64)83,(int64)((*d).offset));
            qc_pcllib_genpc((!!(fstore)?(int64)31:(int64)30));
            break;
        case 144:;
            qc_pclgen_evalref(a);
            qc_pcllib_genpc((!!(fstore)?(int64)31:(int64)30));
            break;
        case 90:;
            qc_pclgen_evalref(a);
            qc_pcllib_genpc((!!(fstore)?(int64)31:(int64)30));
            break;
        default:;
            printf("%s\n",(char*)(qc_tables_jtagnames[((int64)((*a).tag))]));
            qc_support_gerror((byte*)"DOASSIGN?",p);
        }
        if (!!(mult)) {
            a = (*a).nextunit;
        }
        else {
            goto L1393;
        }
L1392:;
    }
L1393:;
}

static void qc_pclgen_do_to(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c) {
    int64 lab_a;
    int64 lab_b;
    int64 lab_c;
    int64 lab_d;
    struct var_decls_strec *  temp;
    lab_a = qc_pclgen_definelabel();
    temp = (*c).def;
    qc_pclgen_do_tag(a);
    qc_pcllib_genpc_s((int64)33,temp);
    lab_b = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d);
    if (((int64)((*a).tag) != (int64)1)    ) {
        qc_pcllib_genpc_s((int64)6,temp);
        qc_pcllib_genpc_int((int64)11,(int64)0);
        qc_pcllib_genpc_lab((int64)48,lab_d);
    }
    else if (((*a).value <= (int64)0)) {
        qc_pcllib_genpc_lab((int64)39,lab_d);
    }
    qc_pclgen_definefwdlabel(&lab_b);
    qc_pclgen_do_block(b);
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pcllib_genpc_lab((int64)58,lab_b);
    qc_pcllib_genopnd_s(temp);
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_while(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c) {
    int64 lab_ab;
    int64 lab_c;
    int64 lab_d;
    lab_ab = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_ab,&lab_ab,&lab_c,&lab_d);
    qc_pclgen_genjumpl(lab_c);
    qc_pclgen_definefwdlabel(&lab_ab);
    qc_pclgen_do_block(b);
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pclgen_genjumpcond((int64)1,a,lab_ab);
    if (!!(c)) {
        qc_pclgen_do_block(c);
    }
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_repeat(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64 lab_ab;
    int64 lab_c;
    int64 lab_d;
    lab_ab = qc_pclgen_definelabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_ab,&lab_ab,&lab_c,&lab_d);
    qc_pclgen_do_block(a);
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pclgen_genjumpcond((int64)0,b,lab_ab);
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_forstep(struct var_decls_unitrec * p,struct var_decls_unitrec * pvar,struct var_decls_unitrec * pbody,struct var_decls_unitrec * pautovar) {
    struct var_decls_unitrec *  pfrom;
    struct var_decls_unitrec *  pto;
    struct var_decls_unitrec *  pstep;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  plimit;
    struct var_decls_strec *  dvar;
    struct var_decls_strec *  limitvar;
    int64 lab_a;
    int64 lab_b;
    int64 lab_c;
    int64 lab_d;
    int64 lab_e;
    int64 opc;
    int64 step;
    int64 fromval;
    int64 limit;
    int64 jumpinto;
    pfrom = (*pvar).nextunit;
    pto = (*pfrom).nextunit;
    pstep = (*pto).nextunit;
    pelse = (*pbody).nextunit;
    dvar = (*pvar).def;
    (*dvar).attribs.ax_used = (uint8)1u;
    if (((int64)((*p).tag)==(int64)23)) {
        step = (int64)1;
    } else if (((int64)((*p).tag)==(int64)24)) {
        step = (int64)-1;
    }
    else {
        step = qc_lib_getconstvalue(pstep,(int64)101);
        if (((step != (int64)1) && (step != (int64)-1))) {
            qc_support_gerror((byte*)"Can't do for with odd step",(struct var_decls_unitrec *)(0));
        }
    }
    jumpinto = (int64)1;
    lab_a = qc_pclgen_definelabel();
    lab_b = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    lab_e = (!!(pelse)?qc_pclgen_createfwdlabel():lab_d);
    qc_pclgen_stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d);
    if (((int64)((*pfrom).tag) == (int64)1)) {
        fromval = (*pfrom).value;
        if (((int64)((*pto).tag) == (int64)1)) {
            limit = (*pto).value;
            (*pto).valuemode = (int32)1;
            if ((((step == (int64)-1) && (fromval >= limit)) || ((step == (int64)1) && (fromval <= limit)))) {
                jumpinto = (int64)0;
            }
        }
        if (!!(jumpinto)) {
            if ((step < (int64)0)) {
                ++fromval;
            }
            else {
                --fromval;
            }
            (*pfrom).value = fromval;
        }
        qc_pclgen_genpushint((uint64)((*pfrom).value));
        qc_pcllib_genpc_s(((int64)25 + (int64)((*dvar).attribs.ax_frame)),dvar);
    }
    else {
        qc_pclgen_do_tag(pfrom);
        qc_pcllib_genpc_s(((int64)25 + (int64)((*dvar).attribs.ax_frame)),dvar);
        qc_pcllib_genpc_s((((step < (int64)0)?(int64)88:(int64)93) + (int64)((*dvar).attribs.ax_frame)),dvar);
    }
    if (!!(pautovar)) {
        if ((((int64)((*pto).tag) == (int64)3) && !!((*(*pto).def).attribs.ax_frame))) {
            pautovar = (struct var_decls_unitrec *)(0);
        }
    }
    if (!!(pautovar)) {
        qc_pclgen_do_tag(pto);
        limitvar = (*pautovar).def;
        qc_pcllib_genpc_s((int64)33,limitvar);
        pto = pautovar;
    }
    else {
        limitvar = (*pto).def;
    }
    if (!!(jumpinto)) {
        qc_pclgen_genjumpl(lab_c);
    }
    qc_pclgen_definefwdlabel(&lab_b);
    qc_pclgen_do_block(pbody);
    qc_pclgen_definefwdlabel(&lab_c);
    if (((int64)((*pto).tag) == (int64)1)) {
        opc = ((step < (int64)0)?(int64)61:(int64)59);
    }
    else {
        opc = ((step < (int64)0)?(int64)62:(int64)60);
    }
    qc_pcllib_genpc_lab(opc,lab_b);
    qc_pcllib_genopnd_s(dvar);
    qc_pcllib_genopnd_s(limitvar);
    if (!!(pelse)) {
        qc_pclgen_definefwdlabel(&lab_e);
        qc_pclgen_do_block(pelse);
    }
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_forall(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pbody,struct var_decls_unitrec * pautovar) {
    int64 lab_a;
    int64 lab_b;
    int64 lab_c;
    int64 lab_d;
    int64 lab_e;
    int64 step;
    struct var_decls_unitrec *  pvar;
    struct var_decls_unitrec *  plist;
    struct var_decls_unitrec *  pelse;
    struct var_decls_unitrec *  q;
    struct var_decls_strec *  indexvar;
    struct var_decls_strec *  vardef;
    struct var_decls_strec *  autodef;
    pvar = (*pindex).nextunit;
    vardef = (*pvar).def;
    plist = (*pvar).nextunit;
    pelse = (*pbody).nextunit;
    indexvar = (*pindex).def;
    step = ((((int64)((*p).tag) == (int64)26) || ((int64)((*p).tag) == (int64)28))?(int64)1:(int64)-1);
    lab_a = qc_pclgen_definelabel();
    lab_b = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    lab_e = (!!(pelse)?qc_pclgen_createfwdlabel():lab_d);
    qc_pclgen_stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d);
    qc_pclgen_do_tag(plist);
    qc_pcllib_genpc((int64)131);
    qc_pcllib_genpc((int64)215);
    autodef = (*pautovar).def;
    if ((step == (int64)1)) {
        qc_pcllib_genpc_s((int64)33,autodef);
        qc_pcllib_genpc((int64)98);
        qc_pcllib_genpc_s((!!((*indexvar).attribs.ax_autovar)?(int64)33:(int64)26),indexvar);
    }
    else {
        qc_pcllib_genpc((int64)97);
        qc_pcllib_genpc_s((!!((*indexvar).attribs.ax_autovar)?(int64)33:(int64)26),indexvar);
        qc_pcllib_genpc_s((int64)33,autodef);
    }
    qc_pclgen_genjumpl(lab_c);
    qc_pclgen_definefwdlabel(&lab_b);
    qc_pclgen_do_tag(plist);
    qc_pclgen_do_tag(pindex);
    if ((((int64)((*p).tag) == (int64)26) || ((int64)((*p).tag) == (int64)27))) {
        qc_pcllib_genpc((int64)194);
    }
    else {
        qc_pcllib_genpc((int64)195);
    }
    qc_pcllib_genpc_s((int64)26,vardef);
    if (((int64)((*pbody).tag) == (int64)4)) {
        qc_pclgen_do_block(pbody);
    }
    else {
        qc_pclgen_do_tag(pbody);
    }
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pcllib_genpc_lab(((step == (int64)1)?(int64)60:(int64)62),lab_b);
    qc_pcllib_genopnd_s(indexvar);
    qc_pcllib_genopnd_s(autodef);
    if (!!(pelse)) {
        qc_pclgen_definefwdlabel(&lab_e);
        qc_pclgen_do_block(pelse);
    }
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_do(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64 lab_abc;
    int64 lab_d;
    int64 lab_test;
    lab_abc = qc_pclgen_definelabel();
    lab_d = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_abc,&lab_abc,&lab_abc,&lab_d);
    qc_pclgen_do_block(a);
    qc_pclgen_genjumpl(lab_abc);
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_cfor(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64 lab_a;
    int64 lab_b;
    int64 lab_c;
    int64 lab_d;
    int64 lab_test;
    struct var_decls_unitrec *  pinit;
    struct var_decls_unitrec *  pcond;
    struct var_decls_unitrec *  pstep;
    lab_a = qc_pclgen_definelabel();
    lab_b = qc_pclgen_createfwdlabel();
    lab_c = qc_pclgen_createfwdlabel();
    lab_d = qc_pclgen_createfwdlabel();
    lab_test = qc_pclgen_createfwdlabel();
    qc_pclgen_stacklooplabels(&lab_a,&lab_b,&lab_c,&lab_d);
    pinit = a;
    pcond = (*pinit).nextunit;
    pstep = (*pcond).nextunit;
    qc_pclgen_do_tag(pinit);
    qc_pclgen_genjumpl(lab_test);
    qc_pclgen_definefwdlabel(&lab_b);
    qc_pclgen_do_block(b);
    qc_pclgen_definefwdlabel(&lab_c);
    qc_pclgen_do_tag(pstep);
    qc_pclgen_definefwdlabel(&lab_test);
    qc_pclgen_genjumpcond((int64)1,pcond,lab_b);
    qc_pclgen_definefwdlabel(&lab_d);
    qc_pclgen_unstacklooplabels();
}

static void qc_pclgen_do_if(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * pelse) {
    int64 lab1;
    int64 lab2;
    lab1 = qc_pclgen_createfwdlabel();
    if (!!(pelse)) {
        lab2 = qc_pclgen_createfwdlabel();
    }
    qc_pclgen_genjumpcond((int64)0,a,lab1);
    qc_pclgen_do_block(b);
    if (!!(pelse)) {
        qc_pclgen_genjumpl(lab2);
        qc_pclgen_definefwdlabel(&lab1);
        qc_pclgen_do_block(pelse);
        qc_pclgen_definefwdlabel(&lab2);
    }
    else {
        qc_pclgen_definefwdlabel(&lab1);
    }
}

static void qc_pclgen_do_longif(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_unitrec *  q;
    int64 labend;
    int64 lab2;
    labend = qc_pclgen_createfwdlabel();
    q = a;
L1397:;
    while (!!(q)) {
        lab2 = qc_pclgen_createfwdlabel();
        qc_pclgen_genjumpcond((int64)0,qc_pclgen_checkeqeq((*q).a),lab2);
        qc_pclgen_do_block((*q).b);
        q = (*q).nextunit;
        if ((!!(q) || !!(b))) {
            qc_pclgen_genjumpl(labend);
        }
        qc_pclgen_definefwdlabel(&lab2);
L1398:;
    }
L1399:;
    if (!!(b)) {
        qc_pclgen_do_block(b);
    }
    qc_pclgen_definefwdlabel(&labend);
}

static void qc_pclgen_do_callproc(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  pm;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  r;
    int64 naparams;
    int64 fkeyword;
    int64 nparams;
    int64 i;
    int64 j;
    int64 k;
    int64 ffcode;
    int64 isfn;
    int64 fbyref;
    struct var_decls_unitrec *  cparams[64];
    struct var_decls_strec *  dparams[64];
    int64 dparamsdone = (int64)0;
    byte *  name;
    int64 *  pc;
    if (((int64)((*a).tag) != (int64)3)) {
        qc_pclgen_do_callptr(p,a,b);
        return;
    }
    d = (*a).def;
    if (((int64)((*d).nameid)==(int64)6) || ((int64)((*d).nameid)==(int64)7)) {
    }
    else {
        printf("%s\n",(char*)((*d).name));
        qc_support_gerror((byte*)"Callproc: not proc",p);
    }
    pbody = (*d).code;
    if (((ffcode = (int64)((*d).attribs.ax_fflang))==(int64)1) || ((ffcode = (int64)((*d).attribs.ax_fflang))==(int64)2) || ((ffcode = (int64)((*d).attribs.ax_fflang))==(int64)4)) {
        qc_pclgen_do_calldll(p,a,b);
        return;
    }
    isfn = (int64)(((int64)((*d).mode) != (int64)0));
    if (!!(isfn)) {
        qc_pcllib_genpc((int64)19);
    }
    nparams = (int64)((*d).attribs.ax_nparams);
    memset((void *)(&cparams),(int32)0,(uint64)(((int64)8 * nparams)));
    fkeyword = (int64)0;
    x = b;
    naparams = (int64)0;
L1400:;
    while (!!(x)) {
        ++naparams;
        if ((naparams > nparams)) {
            printf("%s %lld %lld\n",(char*)((*d).name),(int64)naparams,(int64)nparams);
            qc_support_gerror((byte*)"Too many params",p);
        }
        if ((!!(fkeyword) && ((int64)((*x).tag) != (int64)84))) {
            qc_support_gerror((byte*)"Normal param follows keyword param",p);
        }
        if (((int64)((*x).tag)==(int64)84)) {
            if (!(((int64)((*(*x).a).tag) == (int64)3))) {
                qc_support_gerror((byte*)"Kwd: not name",(struct var_decls_unitrec *)(0));
            }
            fkeyword = (int64)1;
            name = (*(*(*x).a).def).name;
            if (!(!!(dparamsdone))) {
                qc_pclgen_extractparams(d,&dparams);
                dparamsdone = (int64)1;
            }
            j = (int64)0;
            k = (int64)0;
L1403:;
            for (j=(int64)1;j<=nparams;++j) {
L1404:;
                if (!!(mlib_eqstring((*dparams[(j)-1]).name,name))) {
                    k = j;
                    goto L1406;
                }
L1405:;
            }
L1406:;
            if ((k == (int64)0)) {
                printf("%s %s %s\n",(char*)(name),(char*)((byte*)"in"),(char*)((*d).name));
                qc_support_gerror((byte*)"Can't find keyword param",(struct var_decls_unitrec *)(0));
            }
            if (!!(cparams[(k)-1])) {
                printf("%s\n",(char*)(name));
                qc_support_gerror((byte*)"Param already set",(struct var_decls_unitrec *)(0));
            }
            cparams[(k)-1] = (*x).b;
        } else if (((int64)((*x).tag)==(int64)2)) {
        }
        else {
            cparams[(naparams)-1] = x;
        }
        x = (*x).nextunit;
L1401:;
    }
L1402:;
L1407:;
    for (i=(int64)1;i<=nparams;++i) {
L1408:;
        x = cparams[(i)-1];
        if ((x == 0)) {
            if (!(!!(dparamsdone))) {
                qc_pclgen_extractparams(d,&dparams);
                dparamsdone = (int64)1;
            }
            pm = dparams[(i)-1];
            if (!!((*pm).code)            ) {
                cparams[(i)-1] = (*pm).code;
            }
            else if (!(!!((*pm).attribs.ax_optional))) {
                printf("%s %s %s\n",(char*)((*pm).name),(char*)((byte*)"in"),(char*)((*d).name));
                qc_support_gerror((byte*)"Param not optional",(struct var_decls_unitrec *)(0));
            }
        }
L1409:;
    }
L1410:;
L1411:;
    for (i=nparams;i>=(int64)1;--i) {
L1412:;
        x = cparams[(i)-1];
        if (!(!!(dparamsdone))) {
            qc_pclgen_extractparams(d,&dparams);
            dparamsdone = (int64)1;
        }
        fbyref = (int64)((*dparams[(i)-1]).attribs.ax_byrefmode);
        if ((x == 0)) {
            if (!!(fbyref)) {
                qc_support_gerror((byte*)"&void param",(struct var_decls_unitrec *)(0));
            }
            qc_pcllib_genpc((int64)19);
        }
        else {
            if (!!(fbyref)) {
                qc_pclgen_evalref(x);
            }
            else {
                qc_pclgen_do_tag(x);
            }
        }
L1413:;
    }
L1414:;
    qc_pcllib_genpc_s((int64)63,d);
    qc_pcllib_genopnd_int((int64)0);
L1415:;
    for (i=(int64)1;i<=nparams;++i) {
L1416:;
        r = cparams[(i)-1];
        if (((r == 0) || !!(qc_pclgen_issimpleparam(r)))) {
            if (((*qc_pcllib_lastopc)==(int64)72)) {
                ++(*(qc_pcllib_lastopc + (int64)1));
            } else if (((*qc_pcllib_lastopc)==(int64)63)) {
                if (((*(qc_pcllib_lastopc + (int64)2)) < (int64)8)) {
                    ++(*(qc_pcllib_lastopc + (int64)2));
                }
                else {
                    qc_pcllib_genpc_int((int64)72,(int64)1);
                }
            }
            else {
                qc_pcllib_genpc_int((int64)72,(int64)1);
            }
        }
        else {
            if (((*qc_pcllib_lastopc)==(int64)71)) {
                ++(*(qc_pcllib_lastopc + (int64)1));
            }
            else {
                qc_pclgen_genfree((int64)1);
            }
        }
L1417:;
    }
L1418:;
    if ((!!(isfn) && ((int64)((*p).tag) == (int64)14))) {
        qc_pclgen_genfree((int64)1);
    }
}

static void qc_pclgen_do_callhostproc(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64 calledasfn;
    int64 isfn;
    int64 index;
    int64 nap;
    int64 i;
    int64 nparams;
    int64 fparams;
    struct var_decls_unitrec *  plist[10];
    struct var_decls_unitrec *  q;
    int64 av_1;
    calledasfn = (int64)(((int64)((*p).tag) == (int64)92));
    index = (int64)((*p).opcode);
    isfn = pq_common_hostisfn[(index)];
    if ((!!(calledasfn) && !(!!(isfn)))) {
        qc_support_gerror((byte*)"Host proc is not function",(struct var_decls_unitrec *)(0));
    }
    if (((!!(isfn) && (index == (int64)64)) && (((!!(a) && ((*a).nextunit == 0)) && ((int64)((*a).tag) == (int64)1)) && ((*a).value == (int64)0)))) {
        qc_pclgen_genpushint((uint64)(qc_pclgen_nprocparamvars));
        return;
    }
    if (!!(isfn)) {
        qc_pcllib_genpc((int64)19);
    }
    q = a;
    nap = (int64)0;
L1419:;
    while (!!(q)) {
        if ((nap >= (int64)10)) {
            qc_support_gerror((byte*)"far too many host params",(struct var_decls_unitrec *)(0));
        }
        ++nap;
        plist[(nap)-1] = q;
        q = (*q).nextunit;
L1420:;
    }
L1421:;
    if (((index == (int64)67) && (a == 0))) {
        nparams = (int64)1;
    }
    else {
        nparams = nap;
    }
    if (((nparams == (int64)0) && !!(qc_tables_hostlvset[(index)]))) {
        qc_support_gerror((byte*)"LV hostfn: needs 1+ params",(struct var_decls_unitrec *)(0));
    }
    fparams = pq_common_hostnparams[(index)];
    if ((nparams > fparams)) {
        qc_support_gerror((byte*)"Hostfn too many params",(struct var_decls_unitrec *)(0));
    }
    av_1 = (fparams - nparams);
    while (av_1-- > 0) {
L1422:;
        qc_pcllib_genpc((int64)19);
L1423:;
    }
L1424:;
L1425:;
    for (i=nparams;i>=(int64)1;--i) {
L1426:;
        if (((i == (int64)1) && !!(qc_tables_hostlvset[(index)]))        ) {
            qc_pclgen_evalref(plist[(i)-1]);
        }
        else if ((((i == (int64)1) && (index == (int64)67)) && (nap == (int64)0))) {
            isfn = (int64)(((int64)((*qc_pcllib_stcurrproc).mode) != (int64)0));
            qc_pcllib_genpc_s((int64)9,qc_pcllib_stcurrproc);
        }
        else {
            qc_pclgen_do_tag(plist[(i)-1]);
        }
L1427:;
    }
L1428:;
    qc_pclgen_callhostfn(index,calledasfn);
}

static void qc_pclgen_do_return(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64 isfn;
    isfn = (int64)(((int64)((*qc_pcllib_stcurrproc).mode) != (int64)0));
    if ((a == 0)) {
        if (!!(isfn)) {
            qc_support_gerror((byte*)"Fn needs return value",p);
        }
        if (!!(qc_pclgen_trylevel)) {
            qc_pcllib_genpc_int((int64)72,qc_pclgen_trylevel);
        }
        if (!!(qc_pclgen_nprocframevars)) {
            qc_pclgen_genjumpl(qc_pclgen_retindex);
        }
        else {
            qc_pcllib_genpc((int64)65);
        }
        return;
    }
    if (!(!!(isfn))) {
        printf("%s\n",(char*)((*qc_pcllib_stcurrproc).name));
        qc_support_gerror((byte*)"Can't return value from proc",(struct var_decls_unitrec *)(0));
    }
    qc_pclgen_do_tag(a);
    qc_pcllib_genpc_s((int64)33,qc_pclgen_stretval);
    if (!!(qc_pclgen_trylevel)) {
        qc_pcllib_genpc_int((int64)72,qc_pclgen_trylevel);
    }
    if (!!(qc_pclgen_nprocframevars)) {
        qc_pclgen_genjumpl(qc_pclgen_retindex);
    }
    else {
        qc_pcllib_genpc((int64)65);
    }
}

static void qc_pclgen_genstartproc(struct var_decls_strec * dmodule) {
    int64 retadjust;
    int64 lab1;
    int64 lab2;
    struct var_decls_strec *  stmain;
    struct var_decls_strec *  ststart;
    if ((qc_pclgen_st_startproc == 0)) {
        qc_support_gerror((byte*)"$startproc not present",(struct var_decls_unitrec *)(0));
    }
    retadjust = (int64)0;
    qc_pcllib_genpc_s((int64)2,qc_pclgen_st_startproc);
    qc_pcllib_genopnd_int((int64)0);
    (*qc_pclgen_st_startproc).index = (int32)((qc_pcllib_pcindex + (int64)1));
    qc_pclgen_scanidata(dmodule);
    stmain = qc_lib_finddefstr(var_decls_stmodule,(byte*)"main");
    ststart = qc_lib_finddefstr(var_decls_stmodule,(byte*)"start");
    if ((!!(stmain) && !!(ststart))    ) {
        lab1 = qc_pclgen_createfwdlabel();
        lab2 = qc_pclgen_createfwdlabel();
        qc_pcllib_genpc((int64)19);
        qc_pcllib_genpc_str((int64)15,(*var_decls_stmodule).name,(int64)((*var_decls_stmodule).namelen));
        qc_pclgen_callhostfn((int64)26,(int64)1);
        qc_pcllib_genpc_lab((int64)42,lab1);
        qc_pcllib_genpc_s((int64)63,stmain);
        qc_pcllib_genopnd_int((int64)0);
        qc_pcllib_genpc_lab((int64)39,lab2);
        qc_pclgen_definefwdlabel(&lab1);
        qc_pcllib_genpc_s((int64)63,ststart);
        qc_pcllib_genopnd_int((int64)0);
        qc_pclgen_definefwdlabel(&lab2);
    }
    else if (!!(stmain)) {
        lab1 = qc_pclgen_createfwdlabel();
        qc_pcllib_genpc((int64)19);
        qc_pcllib_genpc_str((int64)15,(*var_decls_stmodule).name,(int64)((*var_decls_stmodule).namelen));
        qc_pclgen_callhostfn((int64)26,(int64)1);
        qc_pcllib_genpc_lab((int64)42,lab1);
        qc_pcllib_genpc_s((int64)63,stmain);
        qc_pcllib_genopnd_int((int64)0);
        qc_pclgen_definefwdlabel(&lab1);
    }
    else if (!!(ststart)) {
        qc_pcllib_genpc_s((int64)63,ststart);
        qc_pcllib_genopnd_int((int64)0);
    }
    qc_pcllib_genpc((int64)65);
    qc_pcllib_genpc((int64)3);
}

static void qc_pclgen_do_procdef(struct var_decls_strec * p) {
    int64 nfreevars;
    int64 nnofreevars;
    if ((p == qc_pclgen_st_startproc)) {
        return;
    }
    qc_pcllib_stcurrproc = p;
    qc_pclgen_retindex = qc_pclgen_createfwdlabel();
    qc_pclgen_genprocentry(p,&nfreevars,&nnofreevars);
    if (((*p).code == 0)) {
        printf("%s %s %s\n",(char*)((byte*)"EMPTY PROC BODY"),(char*)((*p).name),(char*)(qc_tables_scopenames[(qc_lib_getscope(p))]));
    }
    else {
        qc_pclgen_do_block((*p).code);
    }
    if (((int64)((*p).mode) != (int64)0)) {
        if (((int64)((*(*p).owner).nameid) != (int64)5)) {
            if (!(!!(qc_pclgen_checkblockreturn((*p).code)))) {
                printf("%s\n",(char*)((*p).name));
                qc_support_gerror((byte*)"Function needs explicit return statement",(*p).code);
            }
        }
    }
    qc_pclgen_definefwdlabel(&qc_pclgen_retindex);
    qc_pclgen_genprocexit(nfreevars,nnofreevars);
    qc_pcllib_genpc((int64)3);
}

static void qc_pclgen_genprocentry(struct var_decls_strec * p,int64 * nfreevars,int64 * nnofreevars) {
    int64 nparamvars;
    int64 nframevars;
    int64 isfn;
    int64 hasretval;
    int64 fv;
    int64 nallocvars;
    int64 ninitvars;
    int64 i;
    int64 j;
    int64 nextoffset;
    struct var_decls_strec *  d;
    struct var_decls_strec *  varlist[64];
    int64 fvlist[64];
    struct var_decls_unitrec *  expr;
    struct var_decls_strec *  locals[256];
    int64 nlocals;
    d = (*p).deflist;
    isfn = (int64)(((int64)((*p).mode) != (int64)0));
    if (!!(isfn)) {
        qc_pclgen_stretval = qc_lib_getduplnameptr(p,qc_lex_addnamestr((byte*)"$retval"),(int64)12);
        (*qc_pclgen_stretval).mode = (*p).mode;
        (*qc_pclgen_stretval).attribs.ax_autovar = (uint8)1u;
        qc_lib_adddef_nodupl(p,qc_pclgen_stretval);
    }
    else {
        qc_pclgen_stretval = (struct var_decls_strec *)(0);
    }
    nparamvars = (nframevars = (int64)0);
    hasretval = (int64)0;
    d = (*p).deflist;
    nlocals = (int64)0;
L1429:;
    while (!!(d)) {
        if ((nlocals >= (int64)256)) {
            qc_support_gerror((byte*)"Too many locals",(struct var_decls_unitrec *)(0));
        }
        locals[(++nlocals)-1] = d;
        d = (*d).nextdef;
L1430:;
    }
L1431:;
L1432:;
    for (i=nlocals;i>=(int64)1;--i) {
L1433:;
        d = locals[(i)-1];
        if (((int64)((*d).nameid)==(int64)11)) {
            if ((nframevars >= (int64)64)) {
                var_decls_mlineno = (int64)((*d).lineno);
                printf("%s %s %lld\n",(char*)((*p).name),(char*)((*d).name),(int64)nframevars);
                qc_support_gerror((byte*)"Too many frame vars",(struct var_decls_unitrec *)(0));
            }
            ++nframevars;
            varlist[(nframevars)-1] = d;
            fvlist[(nframevars)-1] = (int64)0;
        } else if (((int64)((*d).nameid)==(int64)12)) {
            (*d).index = (int32)(++nparamvars);
            if (!!((*d).attribs.ax_autovar)) {
                hasretval = (int64)1;
            }
        }
L1434:;
    }
L1435:;
    qc_pclgen_nprocframevars = nframevars;
    qc_pclgen_nprocparamvars = (nparamvars - isfn);
    nallocvars = (ninitvars = (int64)0);
    (*nfreevars) = ((*nnofreevars) = (int64)0);
L1436:;
    for (i=(int64)1;i<=nframevars;++i) {
L1437:;
        d = varlist[(i)-1];
        expr = (struct var_decls_unitrec *)(0);
        if (!!((*d).code)) {
            expr = (*d).code;
        }
        if (!!((*d).attribs.ax_autovar)        ) {
            fv = (int64)0;
            ++nallocvars;
            ++(*nnofreevars);
        }
        else if (!!(expr)) {
            fv = (int64)1;
            ++nallocvars;
            ++(*nfreevars);
        }
        else {
            fv = (int64)2;
            ++ninitvars;
            ++(*nfreevars);
        }
        fvlist[(i)-1] = fv;
L1438:;
    }
L1439:;
    nextoffset = (int64)0;
L1440:;
    for (i=(int64)2;i>=(int64)0;--i) {
L1441:;
L1444:;
        for (j=(int64)1;j<=nframevars;++j) {
L1445:;
            if ((fvlist[(j)-1] == i)) {
                nextoffset -= (int64)1;
                (*varlist[(j)-1]).index = (int32)(nextoffset);
            }
L1446:;
        }
L1447:;
L1442:;
    }
L1443:;
    qc_pcllib_genpc_s((int64)2,p);
    qc_pcllib_genopnd_int((nparamvars - hasretval));
    (*p).index = (int32)((qc_pcllib_pcindex + (int64)1));
    if (!!((ninitvars + nallocvars))) {
        qc_pcllib_genpc_int((int64)70,(ninitvars + nallocvars));
    }
L1448:;
    for (i=(int64)1;i<=nframevars;++i) {
L1449:;
        d = varlist[(i)-1];
        if (!!((*d).code)) {
            qc_pclgen_do_tag((*d).code);
            (*d).attribs.ax_used = (uint8)1u;
            qc_pcllib_genpc_s((int64)33,d);
        }
L1450:;
    }
L1451:;
}

static void qc_pclgen_genprocexit(int64 nfree,int64 nnofree) {
    if (!!(nnofree)) {
        qc_pcllib_genpc_int((int64)72,nnofree);
    }
    if (!!(nfree)) {
        qc_pclgen_genfree(nfree);
    }
    qc_pcllib_genpc((int64)65);
}

static void qc_pclgen_do_preincr(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64 isincr;
    isincr = (int64)((((int64)((*p).tag) == (int64)229) | ((int64)((*p).tag) == (int64)231)));
    if ((((int64)((*a).tag) == (int64)3) && ((int64)((*(*a).def).nameid) != (int64)12))) {
        qc_pcllib_genpc_s(((!!(isincr)?(int64)88:(int64)93) + (int64)((*(*a).def).attribs.ax_frame)),(*a).def);
    }
    else {
        qc_pclgen_evalref(a);
        qc_pcllib_genpc((!!(isincr)?(int64)87:(int64)92));
    }
}

static void qc_pclgen_do_exit(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    int64 k;
    int64 index;
    int64 n;
    if (((int64)((*p).tag)==(int64)36)) {
        k = (int64)1;
    } else if (((int64)((*p).tag)==(int64)37)) {
        k = (int64)2;
    } else if (((int64)((*p).tag)==(int64)38)) {
        k = (int64)3;
    } else if (((int64)((*p).tag)==(int64)39)) {
        k = (int64)4;
    }
    if (!!(a)) {
        index = (*a).value;
    }
    else {
        index = (int64)1;
    }
    n = qc_pclgen_findlooplabel(k,index);
    if ((n == (int64)0)) {
        qc_support_gerror((byte*)"Bad exit/loop index",p);
    }
    else {
        if ((qc_pclgen_trylevel > qc_pclgen_looptrylevel)) {
            qc_pcllib_genpc_int((int64)72,(qc_pclgen_trylevel - qc_pclgen_looptrylevel));
        }
        qc_pclgen_genjumpl(n);
    }
}

static void qc_pclgen_do_goto(struct var_decls_unitrec * p,struct var_decls_unitrec * a) {
    struct var_decls_strec *  d;
    int64 ntries;
    int64 lab;
    if (((int64)((*a).tag)==(int64)3)) {
        d = (*a).def;
        if (((int64)((*d).index) == (int64)0)) {
            (*d).index = (int32)(qc_pclgen_createfwdlabel());
        }
        if (((int64)((*d).nameid)==(int64)16)) {
            ntries = (qc_pclgen_trylevel - (int64)((*d).offset));
            if ((ntries < (int64)0)            ) {
                qc_support_gerror((byte*)"Jumping into try block",(struct var_decls_unitrec *)(0));
            }
            else if (!!(ntries)) {
                qc_pcllib_genpc_int((int64)72,ntries);
            }
            qc_pcllib_genpc_lab((int64)39,(int64)((*d).index));
        }
        else {
            printf("%s\n",(char*)((*d).name));
            qc_support_gerror((byte*)"Not label name",(struct var_decls_unitrec *)(0));
        }
    }
    else {
        qc_support_gerror((byte*)"GOTO PTR",(struct var_decls_unitrec *)(0));
    }
}

static void qc_pclgen_do_switch(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse) {
    int64 minlab;
    int64 maxlab;
    int64 x;
    int64 y;
    int64 i;
    int64 n;
    struct var_decls_unitrec *  w;
    struct var_decls_unitrec *  wt;
    minlab = (int64)1000000;
    maxlab = (int64)-1000000;
    n = (int64)0;
    wt = pwhenthen;
L1452:;
    while (!!(wt)) {
        w = (*wt).a;
L1455:;
        while (!!(w)) {
            if (((int64)((*w).tag)==(int64)1)) {
                if (((int64)((*w).valuemode)==(int64)4)) {
                    x = (int64)((*w).range_lower);
                    y = (int64)((*w).range_upper);
//dorange:
L1458:;
L1459:;
                    for (i=x;i<=y;++i) {
L1460:;
                        minlab = (minlab<i?minlab:i);
                        maxlab = (maxlab>i?maxlab:i);
L1461:;
                    }
L1462:;
                } else if (((int64)((*w).valuemode)==(int64)1)) {
                    x = (y = (*w).value);
                    goto L1458;
                }
                else {
                    qc_support_gerror((byte*)"Switch when1: not const int",w);
                }
            } else if (((int64)((*w).tag)==(int64)149)) {
                x = (y = (int64)((*w).valuemode));
                goto L1458;
            }
            else {
                printf("%s %p %s\n",(char*)((byte*)"STREXPR(W)="),(void*)(qc_lib_strexpr(w)),(char*)(qc_tables_jtagnames[((int64)((*w).tag))]));
                qc_support_gerror((byte*)"Switch when2: not const",w);
            }
            w = (*w).nextunit;
L1456:;
        }
L1457:;
        wt = (*wt).nextunit;
L1453:;
    }
L1454:;
    if (((maxlab - minlab) <= (int64)512)) {
        qc_pclgen_do_simpleswitch(p,pindex,pwhenthen,pelse,minlab,maxlab);
        return;
    }
    qc_support_gerror((byte*)"COMPLEX SWITCH/NOT COMPLETE",(struct var_decls_unitrec *)(0));
}

static void qc_pclgen_do_simpleswitch(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse,int64 a,int64 b) {
    struct var_decls_unitrec *  w;
    struct var_decls_unitrec *  wt;
    struct var_decls_unitrec *  q;
    int64 loopsw;
    int64 n;
    int64 offset;
    int64 x;
    int64 y;
    int64 x0;
    int64 i;
    int64 labstmt;
    int64 elselab;
    int64 labels[513];
    int64 lab_a;
    int64 lab_b;
    int64 lab_c;
    int64 lab_d;
    loopsw = (int64)(((int64)((*p).tag) == (int64)45));
    n = ((b - a) + (int64)1);
    offset = (a - (int64)1);
    if (!!(loopsw)) {
        lab_a = qc_pclgen_definelabel();
        lab_d = qc_pclgen_createfwdlabel();
        qc_pclgen_stacklooplabels(&lab_a,&lab_a,&lab_a,&lab_d);
    }
    else {
        lab_d = qc_pclgen_createfwdlabel();
    }
    qc_pclgen_do_tag(pindex);
    qc_pcllib_genpc_int2((int64)55,n,a);
L1463:;
    for (i=(int64)1;i<=n;++i) {
L1464:;
        qc_pcllib_genpc_lab((int64)53,(int64)0);
        labels[(i)-1] = qc_pcllib_pcindex;
L1465:;
    }
L1466:;
    qc_pcllib_genpc_lab((int64)53,(int64)0);
    labels[((n + (int64)1))-1] = qc_pcllib_pcindex;
    wt = pwhenthen;
L1467:;
    while (!!(wt)) {
        labstmt = qc_pclgen_definelabel();
        w = (*wt).a;
L1470:;
        while (!!(w)) {
            if (((int64)((*w).tag)==(int64)1)) {
                if (((int64)((*w).valuemode) == (int64)4)) {
                    x0 = (int64)((*w).range_lower);
                    y = (int64)((*w).range_upper);
                }
                else {
                    x0 = (y = (*w).value);
                }
            } else if (((int64)((*w).tag)==(int64)149)) {
                x0 = (y = (int64)((*w).valuemode));
            }
L1473:;
            for (x=x0;x<=y;++x) {
L1474:;
                i = (x - offset);
                if (!!((*qc_pcllib_pccode)[(labels[(i)-1])-1])) {
                    printf("%lld %u\n",(int64)x,(byte)(x));
                    qc_support_gerror((byte*)"Dupl switch value",(struct var_decls_unitrec *)(0));
                }
                (*qc_pcllib_pccode)[(labels[(i)-1])-1] = labstmt;
L1475:;
            }
L1476:;
            w = (*w).nextunit;
L1471:;
        }
L1472:;
        qc_pclgen_do_block((*wt).b);
        if (!(!!(loopsw))) {
            qc_pclgen_genjumpl(lab_d);
        }
        else {
            qc_pclgen_genjumpl(lab_a);
        }
        wt = (*wt).nextunit;
L1468:;
    }
L1469:;
    if (!!(pelse)) {
        if (((*pelse).nextunit == 0)) {
            q = pelse;
        }
        else {
            q = (struct var_decls_unitrec *)(0);
        }
        if ((((!!(loopsw) && !!(q)) && ((int64)((*q).tag) == (int64)39)) && (((*q).a == 0) || (qc_lib_getconstvalue((*q).a,(int64)102) == (int64)1)))) {
            elselab = lab_d;
            pelse = (struct var_decls_unitrec *)(0);
        }
        else {
            elselab = qc_pclgen_createfwdlabel();
        }
    }
    else {
        elselab = (!!(loopsw)?lab_a:lab_d);
    }
    if (!!(pelse)) {
        qc_pclgen_definefwdlabel(&elselab);
        qc_pclgen_do_block(pelse);
    }
L1477:;
    for (i=(int64)1;i<=n;++i) {
L1478:;
        if (((*qc_pcllib_pccode)[(labels[(i)-1])-1] == (int64)0)) {
            (*qc_pcllib_pccode)[(labels[(i)-1])-1] = elselab;
        }
L1479:;
    }
L1480:;
    (*qc_pcllib_pccode)[(labels[((n + (int64)1))-1])-1] = elselab;
    if (!!(loopsw)) {
        qc_pclgen_genjumpl(lab_a);
        qc_pclgen_definefwdlabel(&lab_d);
        qc_pclgen_unstacklooplabels();
    }
    else {
        qc_pclgen_definefwdlabel(&lab_d);
    }
}

static void qc_pclgen_do_case(struct var_decls_unitrec * p,struct var_decls_unitrec * pindex,struct var_decls_unitrec * pwhenthen,struct var_decls_unitrec * pelse) {
    int64 lab_a;
    int64 lab_d;
    int64 loopsw;
    int64 fmult;
    int64 labnextwhen;
    int64 labstmtstart;
    struct var_decls_unitrec *  w;
    struct var_decls_unitrec *  wt;
    loopsw = (int64)(((int64)((*p).tag) == (int64)43));
    if (!!(loopsw)) {
        lab_a = qc_pclgen_definelabel();
        lab_d = qc_pclgen_createfwdlabel();
        qc_pclgen_stacklooplabels(&lab_a,&lab_a,&lab_a,&lab_d);
    }
    else {
        lab_d = qc_pclgen_createfwdlabel();
    }
    qc_pclgen_do_tag(pindex);
    wt = pwhenthen;
L1481:;
    while (!!(wt)) {
        w = (*wt).a;
        fmult = (int64)(((*w).nextunit != 0));
        labnextwhen = qc_pclgen_createfwdlabel();
        if (!!(fmult)) {
            labstmtstart = qc_pclgen_createfwdlabel();
        }
L1484:;
        while (!!(w)) {
            qc_pclgen_do_tag(w);
            w = (*w).nextunit;
            if (!!(w)) {
                qc_pcllib_genpc_lab((int64)51,labstmtstart);
            }
            else {
                qc_pcllib_genpc_lab((int64)52,labnextwhen);
            }
L1485:;
        }
L1486:;
        if (!!(fmult)) {
            qc_pclgen_definefwdlabel(&labstmtstart);
        }
        qc_pclgen_do_block((*wt).b);
        if (!(!!(loopsw))) {
            qc_pclgen_genjumpl(lab_d);
        }
        else {
            qc_pclgen_genjumpl(lab_a);
        }
        qc_pclgen_definefwdlabel(&labnextwhen);
        wt = (*wt).nextunit;
L1482:;
    }
L1483:;
    qc_pclgen_genfree((int64)1);
    if (!!(pelse)) {
        qc_pclgen_do_block(pelse);
    }
    if (!!(loopsw)) {
        qc_pclgen_genjumpl(lab_a);
        qc_pclgen_definefwdlabel(&lab_d);
        qc_pclgen_unstacklooplabels();
    }
    else {
        qc_pclgen_definefwdlabel(&lab_d);
    }
}

static void qc_pclgen_do_try(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64 labend;
    int64 labx;
    struct var_decls_unitrec *  ptry;
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  pexcept;
    struct var_decls_unitrec *  pexcode;
    ++qc_pclgen_trylevel;
    labend = qc_pclgen_createfwdlabel();
    ptry = a;
    labx = qc_pclgen_createfwdlabel();
    pexcept = b;
    if ((pexcept == 0)    ) {
        qc_support_gerror((byte*)"try: no except",(struct var_decls_unitrec *)(0));
    }
    else if (!!((*pexcept).nextunit)) {
        qc_support_gerror((byte*)"Try:multiple except block not implemented",(struct var_decls_unitrec *)(0));
    }
L1487:;
    while (!!(pexcept)) {
        pexcode = (*pexcept).a;
        if (((pexcode == 0) || !!((*pexcode).nextunit))) {
            qc_support_gerror((byte*)"Try:multiple except codes not implemented",(struct var_decls_unitrec *)(0));
        }
        qc_pcllib_genpc_lab((int64)207,labx);
        qc_pcllib_genopnd_int(qc_lib_getconstvalue(pexcode,(int64)103));
        qc_pcllib_genopnd_int((int64)1);
        qc_pclgen_do_block(ptry);
        qc_pclgen_genjumpl(labend);
        qc_pclgen_definefwdlabel(&labx);
        qc_pclgen_do_block((*pexcept).b);
        qc_pclgen_definefwdlabel(&labend);
        pexcept = (*pexcept).nextunit;
L1488:;
    }
L1489:;
    qc_pcllib_genpc_int((int64)72,(int64)1);
    --qc_pclgen_trylevel;
}

static void qc_pclgen_do_applyop(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b,struct var_decls_unitrec * c) {
    int64 lab;
    if (!!(c)) {
        qc_pclgen_evalref(b);
        qc_pclgen_do_tag(c);
        qc_pclgen_do_tag(a);
        qc_pcllib_genpc_int((int64)209,(int64)2);
    }
    else {
        qc_pclgen_evalref(b);
        qc_pclgen_do_tag(a);
        qc_pcllib_genpc_int((int64)209,(int64)1);
    }
    lab = qc_pclgen_createfwdlabel();
    qc_pcllib_genpc_lab((int64)39,lab);
    qc_pcllib_genpc((int64)1);
    qc_pclgen_definefwdlabel(&lab);
}

static void qc_pclgen_evalref(struct var_decls_unitrec * p) {
    struct var_decls_strec *  d;
    int64 lab1;
    int64 lab2;
    switch ((int64)((*p).tag)) {
    case 1:;
        qc_support_gerror((byte*)"ref on const",(struct var_decls_unitrec *)(0));
        break;
    case 3:;
        d = (*p).def;
        if (((int64)((*d).nameid)==(int64)6)) {
            qc_pcllib_genpc_s((int64)9,d);
        } else if (((int64)((*d).nameid)==(int64)10)) {
            qc_pcllib_genpc_s((int64)7,d);
        } else if (((int64)((*d).nameid)==(int64)11)) {
            qc_pcllib_genpc_s((int64)8,d);
            (*d).attribs.ax_used = (uint8)1u;
        } else if (((int64)((*d).nameid)==(int64)12)) {
            if (!!((*d).attribs.ax_byrefmode)) {
                qc_pcllib_genpc_s((int64)6,d);
            }
            else {
                qc_pcllib_genpc_s((int64)8,d);
            }
        } else if (((int64)((*d).nameid)==(int64)16)) {
            if (((int64)((*d).index) == (int64)0)) {
                (*d).index = (int32)(qc_pclgen_createfwdlabel());
            }
            qc_pcllib_genpc_lab((int64)10,(int64)((*d).index));
        } else if (((int64)((*d).nameid)==(int64)7)) {
            qc_pcllib_genpc_s((int64)206,d);
        }
        else {
            printf("%s\n",(char*)(pq_common_namenames[((int64)((*d).nameid))]));
            qc_support_gerror((byte*)"&name",(struct var_decls_unitrec *)(0));
        }
        break;
    case 127:;
    case 129:;
        qc_pclgen_evalref((*p).a);
        qc_pclgen_do_tag((*p).b);
        qc_pcllib_genpc((int64)198);
        break;
    case 131:;
        qc_pclgen_evalref((*p).a);
        qc_pclgen_do_tag((*p).b);
        qc_pcllib_genpc((int64)199);
        break;
    case 134:;
        qc_pclgen_do_tag((*p).a);
        qc_pclgen_do_tag((*p).b);
        qc_pcllib_genpc((int64)195);
        break;
    case 138:;
        qc_pclgen_evalref((*p).a);
        qc_pclgen_do_tag((*p).b);
        qc_pcllib_genpc_int((int64)202,(int64)((*p).valuemode));
        break;
    case 130:;
    case 135:;
        qc_pclgen_do_tag((*p).b);
        qc_pclgen_evalref((*p).a);
        qc_pcllib_genpc((int64)200);
        break;
    case 144:;
        qc_pclgen_do_tag((*p).a);
        break;
    case 139:;
        qc_pclgen_evalref((*p).a);
        d = (*(*p).b).def;
        qc_pcllib_genpc_int((int64)83,(int64)((*d).offset));
        break;
    case 90:;
        lab1 = qc_pclgen_createfwdlabel();
        lab2 = qc_pclgen_createfwdlabel();
        qc_pclgen_genjumpcond((int64)0,(*p).a,lab1);
        qc_pclgen_evalref((*p).b);
        qc_pclgen_genjumpl(lab2);
        qc_pclgen_definefwdlabel(&lab1);
        qc_pclgen_evalref((*p).c);
        qc_pcllib_genpc((int64)1);
        qc_pclgen_definefwdlabel(&lab2);
        break;
    default:;
        printf("%s %s %lld\n",(char*)(qc_tables_jtagnames[((int64)((*p).tag))]),(char*)((byte*)"MLINENO="),(int64)var_decls_mlineno);
        qc_support_gerror((byte*)"EVALREF: Can't do tag",(struct var_decls_unitrec *)(0));
    }
}

static int64 qc_pclgen_getpclop(int64 opc) {
    int64 i;
    int64 av_1;
L1490:;
    for (i=(int64)1;i<=(int64)100;++i) {
L1491:;
        if ((qc_pclgen_pcl_jcodes[(i)-1] == opc)) {
            qc_pclgen_noperands = (int64)(qc_pclgen_pcl_nopnds[(i)-1]);
            return qc_pclgen_pcl_kcodes[(i)-1];
        }
L1492:;
    }
L1493:;
    printf("%s\n",(char*)(qc_tables_jtagnames[(opc)]));
    qc_support_gerror((byte*)"PCL:GETOPC No Op",(struct var_decls_unitrec *)(0));
    return (int64)0;
}

static void qc_pclgen_genjumpl(int64 lab) {
    qc_pcllib_genpc_lab((int64)39,lab);
}

static int64 qc_pclgen_definelabel(void) {
    int64 lab = (qc_pcllib_pcindex + (int64)1);
    qc_pcllib_lastopc = &qc_pclgen_dummyop;
    return lab;
}

static int64 qc_pclgen_createfwdlabel(void) {
    int64 lab;
    if ((qc_pcllib_nextfreelabel == (int64)0)) {
        printf("%lld\n",(int64)(int64)1000);
        qc_support_gerror((byte*)"Too many labels",(struct var_decls_unitrec *)(0));
    }
    lab = qc_pcllib_nextfreelabel;
    qc_pcllib_nextfreelabel = (int64)(qc_pcllib_labeltable[(lab)-1]);
    qc_pcllib_labeltable[(lab)-1] = (int32)0;
    return -(lab);
}

static void qc_pclgen_definefwdlabel(int64 * oldlab) {
    int64 pc;
    int64 nextpc;
    int64 newlab;
    int64 index;
    qc_pcllib_lastopc = &qc_pclgen_dummyop;
    index = (*oldlab);
    if ((index >= (int64)0)) {
        qc_support_gerror((byte*)"deffwdlabel?",(struct var_decls_unitrec *)(0));
    }
    index = -(index);
    newlab = (qc_pcllib_pcindex + (int64)1);
    pc = (int64)(qc_pcllib_labeltable[(index)-1]);
L1494:;
    while (!!(pc)) {
        nextpc = (*qc_pcllib_pccode)[(pc)-1];
        (*qc_pcllib_pccode)[(pc)-1] = newlab;
        pc = nextpc;
L1495:;
    }
L1496:;
    qc_pcllib_labeltable[(index)-1] = (int32)(qc_pcllib_nextfreelabel);
    qc_pcllib_nextfreelabel = index;
    (*oldlab) = newlab;
}

static void qc_pclgen_stacklooplabels(int64 * a,int64 * b,int64 * c,int64 * d) {
    if ((qc_pclgen_loopindex >= (int64)20)) {
        qc_support_gerror((byte*)"Too many nested loops",(struct var_decls_unitrec *)(0));
    }
    ++qc_pclgen_loopindex;
    qc_pclgen_loopstack[(qc_pclgen_loopindex)-1][((int64)1)-1] = a;
    qc_pclgen_loopstack[(qc_pclgen_loopindex)-1][((int64)2)-1] = b;
    qc_pclgen_loopstack[(qc_pclgen_loopindex)-1][((int64)3)-1] = c;
    qc_pclgen_loopstack[(qc_pclgen_loopindex)-1][((int64)4)-1] = d;
    qc_pclgen_trylevelstack[(qc_pclgen_loopindex)-1] = qc_pclgen_trylevel;
}

static void qc_pclgen_unstacklooplabels(void) {
    --qc_pclgen_loopindex;
}

static int64 qc_pclgen_findlooplabel(int64 k,int64 n) {
    int64 i;
    if ((n == (int64)0)) {
        i = (int64)1;
    }
    else {
        i = (qc_pclgen_loopindex - (n - (int64)1));
    }
    if (((i < (int64)1) || (i > qc_pclgen_loopindex))) {
        qc_support_gerror((byte*)"Bad loop index",(struct var_decls_unitrec *)(0));
    }
    qc_pclgen_looptrylevel = qc_pclgen_trylevelstack[(i)-1];
    return (*qc_pclgen_loopstack[(i)-1][(k)-1]);
}

static int64 qc_pclgen_issimpleparam(struct var_decls_unitrec * p) {
    switch ((int64)((*p).tag)) {
    case 1:;
        return (int64)1;
        break;
    case 180:;
    case 178:;
    case 179:;
    case 96:;
    case 97:;
    case 98:;
    case 99:;
    case 101:;
    case 100:;
    case 156:;
    case 208:;
    case 207:;
    case 210:;
    case 209:;
        return (int64)1;
        break;
    default:;
    }
    return (int64)0;
}

static void qc_pclgen_genjumpcond(int64 opc,struct var_decls_unitrec * p,int64 lab) {
    int64 oldmlineno;
    int64 lab2;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    int64 x;
    oldmlineno = var_decls_mlineno;
    var_decls_mlineno = (int64)((*p).lineno);
    q = (*p).a;
    r = (*p).b;
    switch ((int64)((*p).tag)) {
    case 72:;
        if ((opc==(int64)0)) {
            qc_pclgen_genjumpcond((int64)0,q,lab);
            qc_pclgen_genjumpcond((int64)0,r,lab);
        } else if ((opc==(int64)1)) {
            lab2 = qc_pclgen_createfwdlabel();
            qc_pclgen_genjumpcond((int64)0,q,lab2);
            qc_pclgen_genjumpcond((int64)1,r,lab);
            qc_pclgen_definefwdlabel(&lab2);
        }
        break;
    case 73:;
        if ((opc==(int64)0)) {
            lab2 = qc_pclgen_createfwdlabel();
            qc_pclgen_genjumpcond((int64)1,q,lab2);
            qc_pclgen_genjumpcond((int64)0,r,lab);
            qc_pclgen_definefwdlabel(&lab2);
        } else if ((opc==(int64)1)) {
            qc_pclgen_genjumpcond((int64)1,q,lab);
            qc_pclgen_genjumpcond((int64)1,r,lab);
        }
        break;
    case 75:;
        if ((opc==(int64)0)) {
            qc_pclgen_genjumpcond((int64)1,q,lab);
        } else if ((opc==(int64)1)) {
            qc_pclgen_genjumpcond((int64)0,q,lab);
        }
        break;
    case 76:;
        qc_pclgen_genjumpcond(opc,q,lab);
        break;
    case 96:;
    case 97:;
    case 98:;
    case 99:;
    case 101:;
    case 100:;
        qc_pclgen_gcomparejump(opc,p,q,r,lab);
        break;
    case 3:;
        qc_pclgen_do_tag(p);
        qc_pcllib_genpc_lab((!!(opc)?(int64)41:(int64)42),lab);
        break;
    case 1:;
        x = (*p).value;
        if (((int64)((*p).valuemode) == (int64)1)) {
            goto L1497;
        }
        if ((((x != (int64)0) && (opc == (int64)1)) || ((x == (int64)0) && (opc == (int64)0)))) {
            qc_pclgen_genjumpl(lab);
        }
        break;
    default:;
//doelse:
L1497:;
        if (((int64)((*p).tag)==(int64)190) || ((int64)((*p).tag)==(int64)188)) {
            qc_pclgen_do_tag(q);
            if ((opc == (int64)1)) {
                qc_pcllib_genpc_lab((((int64)((*p).tag) == (int64)190)?(int64)43:(int64)44),lab);
            }
            else {
                qc_pcllib_genpc_lab((((int64)((*p).tag) == (int64)190)?(int64)44:(int64)43),lab);
            }
        }
        else {
            qc_pclgen_do_tag(p);
            qc_pcllib_genpc_lab((!!(opc)?(int64)41:(int64)42),lab);
        }
    }
    var_decls_mlineno = oldmlineno;
}

static void qc_pclgen_gcomparejump(int64 jumpopc,struct var_decls_unitrec * p,struct var_decls_unitrec * lhs,struct var_decls_unitrec * rhs,int64 lab) {
    int64 cond;
    int64 opc;
    cond = (int64)((*p).tag);
    if ((jumpopc == (int64)0)) {
        cond = qc_pclgen_reversecond(cond);
    }
    if ((cond==(int64)96)) {
        opc = (int64)45;
    } else if ((cond==(int64)97)) {
        opc = (int64)46;
    } else if ((cond==(int64)98)) {
        opc = (int64)47;
    } else if ((cond==(int64)99)) {
        opc = (int64)48;
    } else if ((cond==(int64)101)) {
        opc = (int64)49;
    } else if ((cond==(int64)100)) {
        opc = (int64)50;
    }
    qc_pclgen_do_tag(lhs);
    qc_pclgen_do_tag(rhs);
    qc_pcllib_genpc_lab(opc,lab);
}

static int64 qc_pclgen_reversecond(int64 op) {
    if ((op==(int64)96)) {
        return (int64)97;
    } else if ((op==(int64)97)) {
        return (int64)96;
    } else if ((op==(int64)98)) {
        return (int64)101;
    } else if ((op==(int64)99)) {
        return (int64)100;
    } else if ((op==(int64)101)) {
        return (int64)98;
    } else if ((op==(int64)100)) {
        return (int64)99;
    }
    return (int64)0;
}

static void qc_pclgen_do_convert(int64 m,struct var_decls_unitrec * p) {
    int64 n;
    int64 elemmode;
    int64 i;
    int64 lowerx;
    int64 lbound;
    struct var_decls_unitrec *  plist[50];
    if ((((int64)((*p).tag) != (int64)77) && ((int64)((*p).tag) != (int64)78))) {
//doconv:
L1498:;
        qc_pclgen_do_tag(p);
        qc_pcllib_genpc_int((int64)85,m);
        return;
    }
    n = qc_pclgen_unitstoarray((*p).a,&plist,(int64)50);
    if (((int64)(var_decls_ttbasetype[(m)])==(int64)32) || ((int64)(var_decls_ttbasetype[(m)])==(int64)33)) {
        if ((n < (int64)(var_decls_ttlength[(m)]))        ) {
            printf("%s\n",(char*)(var_decls_ttname[(m)]));
            qc_support_gerror((byte*)"Too few fields",p);
        }
        else if ((n > (int64)(var_decls_ttlength[(m)]))) {
            printf("%s\n",(char*)(var_decls_ttname[(m)]));
            qc_support_gerror((byte*)"Too many fields",p);
        }
L1499:;
        for (i=(int64)1;i<=n;++i) {
L1500:;
            qc_pclgen_do_tag(plist[(i)-1]);
L1501:;
        }
L1502:;
        qc_pcllib_genpc_int2((((int64)(var_decls_ttbasetype[(m)]) == (int64)32)?(int64)76:(int64)78),n,m);
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)29)) {
        if (!!((*p).b)) {
            lowerx = qc_lib_getconstvalue((*p).b,(int64)104);
        }
        else {
            lowerx = (int64)1;
        }
        if ((n == (int64)0)) {
            qc_pcllib_genpc_int((int64)22,lowerx);
        }
        else {
L1503:;
            for (i=(int64)1;i<=n;++i) {
L1504:;
                qc_pclgen_do_tag(plist[(i)-1]);
L1505:;
            }
L1506:;
            qc_pcllib_genpc_int2((int64)75,n,lowerx);
        }
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)30)) {
L1507:;
        for (i=(int64)1;i<=n;++i) {
L1508:;
            qc_pclgen_do_tag(plist[(i)-1]);
L1509:;
        }
L1510:;
        if ((m == (int64)30)) {
            if (!!((*p).b)) {
                lbound = qc_lib_getconstvalue((*p).b,(int64)105);
            }
            else {
                lbound = (int64)1;
            }
            if ((n == (int64)0)) {
                qc_pcllib_genpc_int2((int64)24,(int64)39,lbound);
            }
            else {
                qc_pcllib_genpc_int4((int64)77,n,lbound,(int64)30,(int64)39);
            }
        }
        else {
            elemmode = (int64)(var_decls_tttarget[(m)]);
            if (!!((*p).b)) {
                qc_support_gerror((byte*)"2:Can't override lwb",(struct var_decls_unitrec *)(0));
            }
            lbound = (int64)(var_decls_ttlower[(m)]);
            if (!!(var_decls_ttlength[(m)])) {
                if ((n < (int64)(var_decls_ttlength[(m)]))                ) {
                    printf("%s\n",(char*)(var_decls_ttname[(m)]));
                    qc_support_gerror((byte*)"Too few elements",p);
                }
                else if ((n > (int64)(var_decls_ttlength[(m)]))) {
                    printf("%s\n",(char*)(var_decls_ttname[(m)]));
                    qc_support_gerror((byte*)"Too many elements",p);
                }
                if ((n == (int64)0)) {
                    qc_pcllib_genpc_int2((int64)24,elemmode,lbound);
                }
                else {
                    qc_pcllib_genpc_int4((int64)77,n,lbound,m,elemmode);
                }
            }
            else {
                if ((n == (int64)0)) {
                    qc_pcllib_genpc_int2((int64)24,elemmode,lbound);
                }
                else {
                    qc_pcllib_genpc_int4((int64)77,n,lbound,m,elemmode);
                }
            }
        }
    }
    else {
        qc_pclgen_do_tag(p);
        qc_pcllib_genpc_int((int64)85,m);
    }
}

static void qc_pclgen_do_selectx(struct var_decls_unitrec * pindex,struct var_decls_unitrec * pplist,struct var_decls_unitrec * pelse) {
    int64 n;
    int64 labend;
    int64 i;
    int64 lab;
    int64 elselab;
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  plist[512];
    int64 labels[513];
    n = qc_pclgen_unitstoarray(pplist,&plist,(int64)512);
    if ((n > (int64)512)) {
        qc_support_gerror((byte*)"Selectx too complex",(struct var_decls_unitrec *)(0));
    }
    labend = qc_pclgen_createfwdlabel();
    qc_pclgen_do_tag(pindex);
    qc_pcllib_genpc_int2((int64)55,n,(int64)1);
L1511:;
    for (i=(int64)1;i<=n;++i) {
L1512:;
        qc_pcllib_genpc_lab((int64)53,(int64)0);
        labels[(i)-1] = qc_pcllib_pcindex;
L1513:;
    }
L1514:;
    qc_pcllib_genpc_lab((int64)53,(int64)0);
    labels[((n + (int64)1))-1] = qc_pcllib_pcindex;
    i = (int64)1;
L1515:;
    for (i=(int64)1;i<=n;++i) {
L1516:;
        x = plist[(i)-1];
        lab = qc_pclgen_definelabel();
        (*qc_pcllib_pccode)[(labels[(i)-1])-1] = lab;
        qc_pclgen_do_tag(x);
        qc_pclgen_genjumpl(labend);
L1517:;
    }
L1518:;
    elselab = qc_pclgen_definelabel();
    (*qc_pcllib_pccode)[(labels[((n + (int64)1))-1])-1] = elselab;
    qc_pclgen_do_tag(pelse);
    qc_pcllib_genpc((int64)1);
    qc_pclgen_definefwdlabel(&labend);
}

static void qc_pclgen_do_calldll(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  pm;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  x;
    int64 naparams;
    int64 fkeyword;
    int64 nparams;
    int64 i;
    int64 j;
    int64 k;
    int64 resmode;
    int64 m;
    int64 varparams;
    int64 isfn;
    int64 fbyref;
    int64 langcode;
    struct var_decls_unitrec *  cparams[64];
    struct var_decls_strec *  dparams[64];
    int64 dparamsdone = (int64)0;
    byte *  name;
    d = (*a).def;
    if (!!((varparams = (int64)((*d).attribs.ax_varparams)))) {
        qc_pclgen_do_calldllvar(p,a,b);
        return;
    }
    resmode = (int64)((*d).mode);
    isfn = (int64)((resmode != (int64)0));
    if ((((int64)((*p).tag) == (int64)88) && !(!!(isfn)))) {
        qc_support_gerror((byte*)"DLL: needs function",(struct var_decls_unitrec *)(0));
    }
    if (((int64)((*p).tag) == (int64)14)) {
        isfn = (int64)0;
        resmode = (int64)0;
    }
    if (!!(isfn)) {
        qc_pcllib_genpc((int64)19);
    }
    fkeyword = (int64)0;
    naparams = (int64)0;
    nparams = (int64)((*d).attribs.ax_nparams);
    memset((void *)(&cparams),(int32)0,(uint64)(((int64)8 * nparams)));
    x = b;
L1519:;
    while (!!(x)) {
        ++naparams;
        cparams[(naparams)-1] = (struct var_decls_unitrec *)(0);
        if ((!!(fkeyword) && ((int64)((*x).tag) != (int64)84))) {
            qc_support_gerror((byte*)"Normal param follows keyword param",p);
        }
        if (((int64)((*x).tag)==(int64)84)) {
            fkeyword = (int64)1;
            name = (*(*(*x).a).def).name;
            if (!(!!(dparamsdone))) {
                qc_pclgen_extractparams(d,&dparams);
                dparamsdone = (int64)1;
            }
            k = (int64)0;
L1522:;
            for (j=(int64)1;j<=nparams;++j) {
L1523:;
                if (!!(mlib_eqstring((*dparams[(j)-1]).name,name))) {
                    k = j;
                    goto L1525;
                }
L1524:;
            }
L1525:;
            if ((k == (int64)0)) {
                printf("%s %s %s\n",(char*)(name),(char*)((byte*)"in"),(char*)((*d).name));
                qc_support_gerror((byte*)"Can't find keyword param",(struct var_decls_unitrec *)(0));
            }
            if (!!(cparams[(k)-1])) {
                printf("%s\n",(char*)(name));
                qc_support_gerror((byte*)"Param already set",(struct var_decls_unitrec *)(0));
            }
            cparams[(k)-1] = (*x).b;
        } else if (((int64)((*x).tag)==(int64)2)) {
        }
        else {
            cparams[(naparams)-1] = x;
        }
        x = (*x).nextunit;
L1520:;
    }
L1521:;
L1526:;
    for (i=(int64)1;i<=nparams;++i) {
L1527:;
        x = cparams[(i)-1];
        if ((x == 0)) {
            if (!(!!(dparamsdone))) {
                qc_pclgen_extractparams(d,&dparams);
                dparamsdone = (int64)1;
            }
            pm = dparams[(i)-1];
            if (!!((*pm).code)            ) {
                cparams[(i)-1] = (*pm).code;
            }
            else if (!(!!((*pm).attribs.ax_optional))) {
                printf("%s %s %s\n",(char*)((*pm).name),(char*)((byte*)"in"),(char*)((*d).name));
                qc_support_gerror((byte*)"Param not optional",(struct var_decls_unitrec *)(0));
            }
        }
L1528:;
    }
L1529:;
    qc_pcllib_genpc((int64)66);
L1530:;
    for (i=(int64)1;i<=nparams;++i) {
L1531:;
        x = cparams[(i)-1];
        if (!(!!(dparamsdone))) {
            qc_pclgen_extractparams(d,&dparams);
            dparamsdone = (int64)1;
        }
        m = (int64)((*dparams[(i)-1]).mode);
        fbyref = (int64)((*dparams[(i)-1]).attribs.ax_byrefmode);
        if (!!(fbyref)) {
            qc_support_gerror((byte*)"Byref on dll call",(struct var_decls_unitrec *)(0));
        }
        if ((x == 0)) {
            qc_support_gerror((byte*)"Dll missing param - no default",(struct var_decls_unitrec *)(0));
        }
        else {
            qc_pclgen_do_tag(x);
            qc_pcllib_genpc_int((int64)67,m);
        }
L1532:;
    }
L1533:;
    if (((int64)((*d).attribs.ax_fflang)==(int64)1)) {
        langcode = (int64)87;
    } else if (((int64)((*d).attribs.ax_fflang)==(int64)2)) {
        langcode = (int64)67;
    } else if (((int64)((*d).attribs.ax_fflang)==(int64)4)) {
        langcode = (int64)77;
    }
    else {
        qc_support_gerror((byte*)"Bad FF?",(struct var_decls_unitrec *)(0));
    }
    qc_pcllib_genpc_s((int64)68,d);
    qc_pcllib_genopnd_int(langcode);
    qc_pcllib_genopnd_int(resmode);
}

static int64 qc_pclgen_islogical(struct var_decls_unitrec * p) {
    if (((int64)((*p).tag)==(int64)76) || ((int64)((*p).tag)==(int64)75) || ((int64)((*p).tag)==(int64)72) || ((int64)((*p).tag)==(int64)73) || ((int64)((*p).tag)==(int64)74)) {
        return (int64)1;
    }
    return (int64)0;
}

static void qc_pclgen_do_and(struct var_decls_unitrec * x,struct var_decls_unitrec * y) {
    int64 a;
    int64 b;
    a = qc_pclgen_createfwdlabel();
    b = qc_pclgen_createfwdlabel();
    qc_pclgen_genjumpcond((int64)0,x,a);
    qc_pclgen_genjumpcond((int64)0,y,a);
    qc_pcllib_genpc_int((int64)11,(int64)1);
    qc_pclgen_genjumpl(b);
    qc_pclgen_definefwdlabel(&a);
    qc_pcllib_genpc_int((int64)11,(int64)0);
    qc_pcllib_genpc((int64)1);
    qc_pclgen_definefwdlabel(&b);
}

static void qc_pclgen_do_or(struct var_decls_unitrec * x,struct var_decls_unitrec * y) {
    int64 a;
    int64 b;
    a = qc_pclgen_createfwdlabel();
    b = qc_pclgen_createfwdlabel();
    qc_pclgen_genjumpcond((int64)1,x,a);
    qc_pclgen_genjumpcond((int64)1,y,a);
    qc_pcllib_genpc_int((int64)11,(int64)0);
    qc_pclgen_genjumpl(b);
    qc_pclgen_definefwdlabel(&a);
    qc_pcllib_genpc_int((int64)11,(int64)1);
    qc_pcllib_genpc((int64)1);
    qc_pclgen_definefwdlabel(&b);
}

static void qc_pclgen_do_callptr(struct var_decls_unitrec * p,struct var_decls_unitrec * pproc,struct var_decls_unitrec * pparams) {
    int64 n;
    int64 i;
    int64 j;
    struct var_decls_unitrec *  params[64];
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  q;
    qc_pcllib_genpc((int64)19);
    n = (int64)0;
    q = pparams;
L1534:;
    while (!!(q)) {
        params[(++n)-1] = q;
        q = (*q).nextunit;
L1535:;
    }
L1536:;
L1537:;
    for (i=n;i>=(int64)1;--i) {
L1538:;
        x = params[(i)-1];
        if (((int64)((*x).tag) == (int64)2)) {
            qc_pcllib_genpc_int((int64)18,(int64)0);
        }
        else {
            qc_pclgen_do_tag(x);
        }
L1539:;
    }
L1540:;
    if (((int64)((*pproc).tag) != (int64)144)) {
        qc_support_gerror((byte*)"Callptr?",(struct var_decls_unitrec *)(0));
    }
    qc_pclgen_do_tag((*pproc).a);
    qc_pcllib_genpc_int2((int64)64,n,(int64)0);
    if (!!(n)) {
        qc_pclgen_genfree(n);
    }
    if (((int64)((*p).tag) == (int64)14)) {
        qc_pclgen_genfree((int64)1);
    }
}

static void qc_pclgen_do_callmproc(struct var_decls_unitrec * p,struct var_decls_unitrec * pproc,struct var_decls_unitrec * pparams,int64 calledasfn) {
    int64 n;
    int64 isfn;
    int64 i;
    struct var_decls_unitrec *  params[64];
    struct var_decls_unitrec *  x;
    struct var_decls_unitrec *  pleft;
    isfn = (int64)1;
    if (!!(isfn)) {
        qc_pcllib_genpc((int64)19);
    }
    n = qc_pclgen_unitstoarray(pparams,&params,(int64)64);
L1541:;
    for (i=n;i>=(int64)1;--i) {
L1542:;
        x = params[(i)-1];
        if (((int64)((*x).tag) == (int64)2)) {
            qc_pcllib_genpc((int64)19);
        }
        else {
            qc_pclgen_do_tag(x);
        }
L1543:;
    }
L1544:;
    if (((int64)((*pproc).tag) != (int64)139)) {
        qc_support_gerror((byte*)"Callmproc/not dot",(struct var_decls_unitrec *)(0));
    }
    pleft = (*pproc).a;
    qc_pclgen_evalref(pleft);
    qc_pclgen_do_tag(pproc);
    qc_pcllib_genpc_int2((int64)64,(n + (int64)1),(int64)0);
    qc_pclgen_genfree((n + (int64)1));
    if (!(!!(calledasfn))) {
        qc_pclgen_genfree((int64)1);
    }
}

static int64 qc_pclgen_checkblockreturn(struct var_decls_unitrec * p) {
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  r;
    if ((p == 0)) {
        return (int64)0;
    }
    if (((int64)((*p).tag) != (int64)4)) {
        qc_support_gerror((byte*)"CBR?",(struct var_decls_unitrec *)(0));
    }
    q = (*p).a;
    if ((q == 0)) {
        return (int64)0;
    }
L1545:;
    while (!!((r = (*q).nextunit))) {
        q = r;
L1546:;
    }
L1547:;
    if (((int64)((*q).tag)==(int64)16)) {
        return (int64)1;
    } else if (((int64)((*q).tag)==(int64)21)) {
        return (!!(qc_pclgen_checkblockreturn((*q).b)) && !!(qc_pclgen_checkblockreturn((*q).c)));
    } else if (((int64)((*q).tag)==(int64)22)) {
        r = (*q).a;
L1548:;
        while (!!(r)) {
            if (!(!!(qc_pclgen_checkblockreturn((*r).b)))) {
                return (int64)0;
            }
            r = (*r).nextunit;
L1549:;
        }
L1550:;
        return qc_pclgen_checkblockreturn((*q).b);
    }
    return (int64)0;
}

static void qc_pclgen_genfree(int64 n) {
    qc_pcllib_genpc_int((int64)71,n);
}

static void qc_pclgen_do_clamp(struct var_decls_unitrec * x,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    qc_pclgen_do_tag(x);
    qc_pclgen_do_tag(a);
    qc_pcllib_genpc((int64)175);
    qc_pclgen_do_tag(b);
    qc_pcllib_genpc((int64)174);
}

static void qc_pclgen_do_applyopx(struct var_decls_unitrec * x,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64 lab;
    if (!!(b)) {
        qc_pclgen_do_tag(a);
        qc_pclgen_do_tag(b);
        qc_pclgen_do_tag(x);
        qc_pcllib_genpc_int((int64)209,(int64)2);
    }
    else {
        qc_pclgen_do_tag(a);
        qc_pclgen_do_tag(x);
        qc_pcllib_genpc_int((int64)209,(int64)1);
    }
    lab = qc_pclgen_createfwdlabel();
    qc_pcllib_genpc_lab((int64)39,lab);
    qc_pcllib_genpc((int64)1);
    qc_pclgen_definefwdlabel(&lab);
}

static void qc_pclgen_do_calldllvar(struct var_decls_unitrec * p,struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    struct var_decls_strec *  d;
    struct var_decls_strec *  pm;
    struct var_decls_unitrec *  pbody;
    struct var_decls_unitrec *  q;
    struct var_decls_unitrec *  x;
    int64 naparams;
    int64 fkeyword;
    int64 nparams;
    int64 i;
    int64 j;
    int64 k;
    int64 resmode;
    int64 m;
    int64 isfn;
    int64 t;
    int64 langcode;
    struct var_decls_unitrec *  cparams[64];
    struct var_decls_strec *  dparams[64];
    int64 dparamsdone = (int64)0;
    byte *  name;
    d = (*a).def;
    resmode = (int64)((*d).mode);
    isfn = (int64)((resmode != (int64)0));
    if ((((int64)((*p).tag) == (int64)88) && !(!!(isfn)))) {
        qc_support_gerror((byte*)"DLL: needs function",(struct var_decls_unitrec *)(0));
    }
    if (((int64)((*p).tag) == (int64)14)) {
        isfn = (int64)0;
        resmode = (int64)0;
    }
    if (!!(isfn)) {
        qc_pcllib_genpc((int64)19);
    }
    nparams = (int64)((*d).attribs.ax_nparams);
    qc_pclgen_extractparams(d,&dparams);
    qc_pcllib_genpc((int64)66);
    x = b;
    naparams = (int64)0;
    i = (int64)1;
L1551:;
    while (!!(x)) {
        ++naparams;
        qc_pclgen_do_tag(x);
        if ((i <= nparams)) {
            t = (int64)((*dparams[(i)-1]).mode);
        }
        else {
            t = (int64)0;
        }
        qc_pcllib_genpc_int((int64)67,t);
        x = (*x).nextunit;
        ++i;
L1552:;
    }
L1553:;
    if (((int64)((*d).attribs.ax_fflang)==(int64)1)) {
        langcode = (int64)87;
    } else if (((int64)((*d).attribs.ax_fflang)==(int64)2)) {
        langcode = (int64)67;
    } else if (((int64)((*d).attribs.ax_fflang)==(int64)4)) {
        langcode = (int64)77;
    }
    else {
        qc_support_gerror((byte*)"Bad FF?",(struct var_decls_unitrec *)(0));
    }
    qc_pcllib_genpc_s((int64)68,d);
    qc_pcllib_genopnd_int(langcode);
    qc_pcllib_genopnd_int(resmode);
}

static void qc_pclgen_callhostfn(int64 fnindex,int64 calledasfn) {
    qc_pcllib_genpc_int((int64)69,fnindex);
    if ((!!(pq_common_hostisfn[(fnindex)]) && !(!!(calledasfn)))) {
        qc_pclgen_genfree((int64)1);
    }
}

static void qc_pclgen_extractparams(struct var_decls_strec * d,struct var_decls_strec * (*params)[]) {
    struct var_decls_strec *  p;
    int64 i;
    p = (*d).paramlist;
    i = (int64)0;
L1554:;
    while (!!(p)) {
        (*params)[(++i)-1] = p;
        p = (*p).nextparam;
L1555:;
    }
L1556:;
}

static int64 qc_pclgen_unitstoarray(struct var_decls_unitrec * p,struct var_decls_unitrec * (*plist)[],int64 maxunits) {
    int64 n;
    n = (int64)0;
L1557:;
    while (!!(p)) {
        if ((n >= maxunits)) {
            qc_support_gerror((byte*)"UTO Too many units",(struct var_decls_unitrec *)(0));
        }
        (*plist)[(++n)-1] = p;
        p = (*p).nextunit;
L1558:;
    }
L1559:;
    return n;
}

static void qc_pclgen_do_idiv(struct var_decls_unitrec * a,struct var_decls_unitrec * b) {
    int64 x;
    int64 n;
    if ((b == 0)) {
        qc_support_gerror((byte*)"Idiv?",(struct var_decls_unitrec *)(0));
    }
    qc_pclgen_do_tag(a);
    if ((((int64)((*b).tag) == (int64)1) && ((int64)((*b).valuemode) == (int64)1))) {
        if (((x = (*b).value)==(int64)0)) {
            qc_support_gerror((byte*)"div 0",(struct var_decls_unitrec *)(0));
        } else if (((x = (*b).value)==(int64)1)) {
            return;
        }
        else {
        }
    }
    qc_pclgen_do_tag(b);
    qc_pcllib_genpc((int64)157);
}

static int64 qc_pclgen_ispoweroftwo(int64 x) {
    int64 a;
    int64 n;
    int64 av_1;
    a = (int64)1;
    n = (int64)0;
    av_1 = (int64)30;
    while (av_1-- > 0) {
L1560:;
        ++n;
        a = (a << (int64)1);
        if ((a == x)) {
            return n;
        }
L1561:;
    }
L1562:;
    return (int64)0;
}

static void qc_pclgen_genpushint(uint64 a) {
    qc_pcllib_genpc_int((int64)11,(int64)(a));
}

static struct var_decls_unitrec * qc_pclgen_checkeqeq(struct var_decls_unitrec * p) {
    int64 leftop;
    int64 rightop;
    struct var_decls_unitrec *  w;
    struct var_decls_unitrec *  y1;
    struct var_decls_unitrec *  y2;
    struct var_decls_unitrec *  z;
    if (((int64)((*p).tag)==(int64)96) || ((int64)((*p).tag)==(int64)97) || ((int64)((*p).tag)==(int64)98) || ((int64)((*p).tag)==(int64)99) || ((int64)((*p).tag)==(int64)100) || ((int64)((*p).tag)==(int64)101)) {
        if (((int64)((*(*p).a).tag)==(int64)96) || ((int64)((*(*p).a).tag)==(int64)97) || ((int64)((*(*p).a).tag)==(int64)98) || ((int64)((*(*p).a).tag)==(int64)99) || ((int64)((*(*p).a).tag)==(int64)101) || ((int64)((*(*p).a).tag)==(int64)100)) {
        }
        else {
            return p;
        }
    } else if (((int64)((*p).tag)==(int64)72) || ((int64)((*p).tag)==(int64)73)) {
        qc_pclgen_checkeqeq((*p).a);
        qc_pclgen_checkeqeq((*p).b);
        return p;
    }
    else {
        return p;
    }
    w = (*p).a;
    y1 = (*w).b;
    y2 = y1;
    z = (*p).b;
    leftop = (int64)((*w).tag);
    rightop = (int64)((*p).tag);
    (*p).tag = (int32)72;
    (*p).b = qc_lib_createunit2(rightop,y2,z);
    qc_pclgen_checkeqeq(w);
    qc_pclgen_checkeqeq(y2);
    qc_pclgen_checkeqeq(z);
    return p;
}

void qc_pcllib_initpcl(int64 size) {
    int64 i;
    int64 j;
    int64 nn;
    qc_pcllib_npccode = (size * (int64)2);
    qc_pcllib_pccode = (int64 (*)[])(mlib_pcm_alloc(((qc_pcllib_npccode + (int64)16) * (int64)8)));
    qc_pcllib_linetable = (uint16 (*)[])(mlib_pcm_allocz((qc_pcllib_npccode * (int64)2)));
    qc_pcllib_pcindex = (int64)0;
    var_decls_mlineno = (int64)0;
L1563:;
    for (i=(int64)1;i<=(int64)216;++i) {
L1564:;
        nn = (int64)0;
L1567:;
        for (j=(int64)1;j<=(int64)4;++j) {
L1568:;
            if (((int64)(pq_common_cmdfmt[(i)][(j)-1]) == (int64)0)) {
                goto L1570;
            }
            ++nn;
L1569:;
        }
L1570:;
        qc_pcllib_cmdnopnds[(i)] = (int32)(nn);
L1565:;
    }
L1566:;
}

void qc_pcllib_initpcldata(void) {
    int64 i;
    int64 j;
    int64 nn;
L1571:;
    for (i=(int64)1;i<=(int64)216;++i) {
L1572:;
        nn = (int64)0;
L1575:;
        for (j=(int64)1;j<=(int64)4;++j) {
L1576:;
            if (((int64)(pq_common_cmdfmt[(i)][(j)-1]) == (int64)0)) {
                goto L1578;
            }
            ++nn;
L1577:;
        }
L1578:;
        qc_pcllib_cmdnopnds[(i)] = (int32)(nn);
L1573:;
    }
L1574:;
    var_decls_stringtable = (byte * (*)[])(mlib_alloctable((int64)5000,(int64)8));
    var_decls_stringlentable = (int64 (*)[])(mlib_alloctable((int64)5000,(int64)8));
}

void qc_pcllib_initpclgen(void) {
    int64 i;
    int64 av_1;
L1579:;
    for (i=(int64)1;i<=(int64)999;++i) {
L1580:;
        qc_pcllib_labeltable[(i)-1] = (int32)((i + (int64)1));
L1581:;
    }
L1582:;
    qc_pcllib_labeltable[((int64)1000)-1] = (int32)0;
    qc_pcllib_nextfreelabel = (int64)1;
}

static void qc_pcllib_writepcl3(int64 pc) {
    byte str[512];
    byte fmt[4];
    int64 cmdcode;
    int64 a;
    int64 needcomma;
    int64 i;
    int64 lineno;
    int64 *  ptr;
    struct var_decls_strec *  d;
    ptr = &(*qc_pcllib_pccode)[(pc)-1];
    cmdcode = (*ptr++);
    memcpy((void *)(&fmt),(void *)(&pq_common_cmdfmt[(cmdcode)]),(uint64)((int64)4));
    lineno = (int64)((*qc_pcllib_linetable)[(pc)]);
    sprintf(str,(byte*)"%5d: %05d ",lineno,pc);
    mlib_gs_str(qc_pcllib_pcl,str);
    if ((cmdcode==(int64)2)) {
        mlib_gs_str(qc_pcllib_pcl,(byte*)"PROC:");
        d = (struct var_decls_strec *)((*ptr));
        mlib_gs_str(qc_pcllib_pcl,(*d).name);
        mlib_gs_strln(qc_pcllib_pcl,(byte*)":");
        return;
    } else if ((cmdcode==(int64)3)) {
        mlib_gs_line(qc_pcllib_pcl);
        return;
    }
    if (!!((*qc_pcllib_labelmap)[(pc)-1])) {
        sprintf(str,(byte*)"L%d:",pc);
        mlib_gs_strln(qc_pcllib_pcl,str);
        mlib_gs_str(qc_pcllib_pcl,(byte*)"             ");
    }
    strcpy(str,(pq_common_cmdnames[(cmdcode)] + (int64)1));
    a = (int64)1;
    if ((cmdcode==(int64)69)) {
        a = (int64)2;
        strcat(str,(byte*)".");
        strcat(str,(pq_common_hostfnnames[((*ptr++))] + (int64)5));
    }
    mlib_gs_leftstr(qc_pcllib_pcl,(byte*)" ",(int64)11,(int64)45);
    mlib_gs_leftstr(qc_pcllib_pcl,str,(int64)23,(int64)32);
    mlib_gs_str(qc_pcllib_pcl,(byte*)"     ");
    needcomma = (int64)0;
L1583:;
    for (i=a;i<=(int64)4;++i) {
L1584:;
        if (((int64)(fmt[(i)-1])==(int64)0)) {
            goto L1586;
        }
        else {
            if (!!(needcomma)) {
                mlib_gs_str(qc_pcllib_pcl,(byte*)", ");
            }
            strcpy(str,qc_pcllib_writepclopnd3((int64)(fmt[(i)-1]),(*ptr++),i,cmdcode));
            mlib_gs_str(qc_pcllib_pcl,str);
            needcomma = (int64)1;
        }
L1585:;
    }
L1586:;
    mlib_gs_line(qc_pcllib_pcl);
}

static byte * qc_pcllib_writepclopnd3(int64 fmt,int64 x,int64 n,int64 cmdcode) {
    static byte str[512];
    static byte str2[512];
    struct var_decls_strec *  d;
    byte *  suffix;
    int64 slen;
    d = (struct var_decls_strec *)(x);
    if ((fmt==(int64)0)) {
        return (byte*)"None";
    } else if ((fmt==(int64)9) || (fmt==(int64)10) || (fmt==(int64)11) || (fmt==(int64)12)) {
        if ((fmt==(int64)9)) {
            suffix = (byte*)"i";
        } else if ((fmt==(int64)10)) {
            suffix = (byte*)"d";
        } else if ((fmt==(int64)11)) {
            suffix = (byte*)"w";
        }
        else {
            suffix = (byte*)"";
        }
        sprintf(str,(byte*)"%lld%s",x,suffix);
    } else if ((fmt==(int64)13)) {
        sprintf(str,(byte*)"%lld..%lld",(x & (int64)4294967295),(x >> (int64)32));
    } else if ((fmt==(int64)14)) {
        slen = (*var_decls_stringlentable)[(x)-1];
        if ((slen >= (int64)255)) {
            slen = (int64)255;
        }
        memcpy((void *)(str),(void *)((*var_decls_stringtable)[(x)-1]),(uint64)(slen));
        str[((slen + (int64)1))-1] = (uint8)0u;
        qc_lib_convertstring(str,str2);
        sprintf(str,(byte*)"\"%s\"",str2);
    } else if ((fmt==(int64)1)) {
        strcpy(str,(byte*)">>[");
        strcat(str,qc_lib_getdottedname(d));
        strcat(str,(byte*)"]");
    } else if ((fmt==(int64)2)) {
        sprintf(str,(byte*)"[%s:%d]",qc_lib_getdottedname(d),(*d).index);
    } else if ((fmt==(int64)3)) {
        sprintf(str,(byte*)"[&%s] %d",qc_lib_getdottedname(d),(*d).index);
    } else if ((fmt==(int64)4)) {
        sprintf(str,(byte*)"[DLL:%s %p]",qc_lib_getdottedname(d),d);
    } else if ((fmt==(int64)7)) {
        sprintf(str,(byte*)"GENFIELD:%d",x);
    } else if ((fmt==(int64)6)) {
        sprintf(str,(byte*)".%s",(*d).name);
    } else if ((fmt==(int64)15)) {
        sprintf(str,(byte*)"T:%s <%d>",var_decls_ttname[(x)],x);
    } else if ((fmt==(int64)8)) {
        sprintf(str,(byte*)"L%d",x);
    } else if ((fmt==(int64)16)) {
        sprintf(str,(byte*)"OP:%s",pq_common_cmdnames[(x)]);
    }
    else {
        sprintf(str,(byte*)"<%d %s>",fmt,pq_common_opndnames[(fmt)]);
    }
    return str;
}

struct mlib_strbuffer * qc_pcllib_writepccode(byte * caption,int64 n) {
    int64 cmd;
    int64 pc;
    int64 i;
    int64 lastline;
    int64 line;
    int64 lab;
    mlib_gs_init(qc_pcllib_pcl);
    mlib_gs_str(qc_pcllib_pcl,(byte*)"PROC ");
    mlib_gs_str(qc_pcllib_pcl,caption);
    mlib_gs_str(qc_pcllib_pcl,(byte*)"/MODULE:");
    mlib_gs_str(qc_pcllib_pcl,var_decls_moduletable[(n)].name);
    mlib_gs_str(qc_pcllib_pcl,(byte*)"/");
    mlib_gs_strint(qc_pcllib_pcl,n);
    mlib_gs_str(qc_pcllib_pcl,(byte*)"/");
    mlib_gs_strint(qc_pcllib_pcl,(int64)(var_decls_moduletable[(n)].pcindex));
    mlib_gs_strln(qc_pcllib_pcl,(byte*)":");
    mlib_gs_line(qc_pcllib_pcl);
    qc_pcllib_pccode = var_decls_moduletable[(n)].pccode;
    qc_pcllib_pcindex = (int64)(var_decls_moduletable[(n)].pcindex);
    pc = (int64)1;
    qc_pcllib_linetable = var_decls_moduletable[(n)].linetable;
    qc_pcllib_labelmap = (byte (*)[])(mlib_zalloctable(qc_pcllib_pcindex,(int64)1));
L1587:;
    while ((pc <= qc_pcllib_pcindex)) {
        cmd = (*qc_pcllib_pccode)[(pc)-1];
        if (((int64)(pq_common_cmdfmt[(cmd)][((int64)1)-1]) == (int64)8)) {
            lab = (*qc_pcllib_pccode)[((pc + (int64)1))-1];
            (*qc_pcllib_labelmap)[(lab)-1] = (uint8)1u;
        }
        pc += ((int64)(qc_pcllib_cmdnopnds[(cmd)]) + (int64)1);
L1588:;
    }
L1589:;
    pc = (int64)1;
L1590:;
    while ((pc <= qc_pcllib_pcindex)) {
        cmd = (*qc_pcllib_pccode)[(pc)-1];
        qc_pcllib_writepcl3(pc);
        pc += ((int64)(qc_pcllib_cmdnopnds[(cmd)]) + (int64)1);
L1591:;
    }
L1592:;
    mlib_gs_line(qc_pcllib_pcl);
    return qc_pcllib_pcl;
}

void qc_pcllib_genpc(int64 opc) {
    if ((qc_pcllib_pcindex >= qc_pcllib_npccode)) {
        printf("%s %lld %lld\n",(char*)((byte*)"PCINDEX="),(int64)qc_pcllib_pcindex,(int64)qc_pcllib_npccode);
        qc_support_gerror((byte*)"pccode overflow",(struct var_decls_unitrec *)(0));
    }
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = opc;
    qc_pcllib_lastopc = &(*qc_pcllib_pccode)[(qc_pcllib_pcindex)-1];
    (*qc_pcllib_linetable)[(qc_pcllib_pcindex)] = (uint16)(var_decls_mlineno);
}

void qc_pcllib_genopnd_int(int64 x) {
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = x;
}

void qc_pcllib_genopnd_s(struct var_decls_strec * d) {
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = (int64)(d);
}

void qc_pcllib_genpc_int(int64 opc,int64 a) {
    qc_pcllib_genpc(opc);
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = a;
}

void qc_pcllib_genpc_int2(int64 opc,int64 a,int64 b) {
    qc_pcllib_genpc(opc);
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = a;
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = b;
}

void qc_pcllib_genpc_int4(int64 opc,int64 a,int64 b,int64 c,int64 d) {
    qc_pcllib_genpc(opc);
    qc_pcllib_genopnd_int(a);
    qc_pcllib_genopnd_int(b);
    qc_pcllib_genopnd_int(c);
    qc_pcllib_genopnd_int(d);
}

void qc_pcllib_genpc_s(int64 opc,struct var_decls_strec * d) {
    if (((((opc == (int64)6) && !!(qc_pcllib_lastopc)) && ((*qc_pcllib_lastopc) == (int64)26)) || ((opc == (int64)5) && ((*qc_pcllib_lastopc) == (int64)25)))) {
        if (((int64)(d) == (*qc_pcllib_pccode)[(qc_pcllib_pcindex)-1])) {
            (*qc_pcllib_lastopc) = ((opc == (int64)6)?(int64)28:(int64)27);
            return;
        }
    }
    qc_pcllib_genpc(opc);
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = (int64)(d);
}

void qc_pcllib_genpc_str(int64 opc,byte * s,int64 length) {
    qc_pcllib_genpc(opc);
    qc_pcllib_genopnd_str(s,length);
}

void qc_pcllib_genopnd_str(byte * s,int64 length) {
    qc_pcllib_genopnd_int(qc_pcllib_addstringtotable(s,length));
}

void qc_pcllib_genpc_lab(int64 opc,int64 a) {
    int64 lastpc;
    qc_pcllib_genpc(opc);
    if ((a >= (int64)0)) {
        (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = a;
        return;
    }
    a = -(a);
    lastpc = (int64)(qc_pcllib_labeltable[(a)-1]);
    (*qc_pcllib_pccode)[(++qc_pcllib_pcindex)-1] = lastpc;
    qc_pcllib_labeltable[(a)-1] = (int32)(qc_pcllib_pcindex);
}

int64 qc_pcllib_isframe_s(struct var_decls_strec * p) {
    return (int64)((*p).attribs.ax_frame);
}

void qc_pcllib_converttype(int64 m) {
    struct var_decls_strec *  d;
    int64 first;
    int64 a;
    int64 b;
    int64 nbits;
    int64 recordsize;
    int64 index;
    struct var_decls_strec *  fieldlist[256];
    int64 nofields;
    if (!!(var_decls_ttsize[(m)])) {
        return;
    }
    if (((int64)(var_decls_ttbasetype[(m)])==(int64)5) || ((int64)(var_decls_ttbasetype[(m)])==(int64)21)) {
        var_decls_ttsize[(m)] = var_decls_ttlength[(m)];
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)9)) {
        var_decls_ttsize[(m)] = (int32)(((int64)(var_decls_ttlength[(m)]) / (int64)64));
        if ((((int64)(var_decls_ttsize[(m)]) * (int64)64) < (int64)(var_decls_ttlength[(m)]))) {
            ++var_decls_ttsize[(m)];
        }
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)30)) {
        if (((int64)(var_decls_ttbasetype[(m)])==(int64)41) || ((int64)(var_decls_ttbasetype[(m)])==(int64)42) || ((int64)(var_decls_ttbasetype[(m)])==(int64)43)) {
            nbits = (int64)((var_decls_ttlength[(m)] * var_decls_ttbitwidth[((int64)(var_decls_tttarget[(m)]))]));
            var_decls_ttsize[(m)] = (int32)((((nbits - (int64)1) / (int64)8) + (int64)1));
        }
        else {
            qc_pcllib_converttype((int64)(var_decls_tttarget[(m)]));
            var_decls_ttsize[(m)] = (var_decls_ttlength[(m)] * var_decls_ttsize[((int64)(var_decls_tttarget[(m)]))]);
        }
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)12)) {
        first = (int64)1;
        a = (b = (int64)0);
        d = (*var_decls_ttnamedef[(m)]).deflist;
L1593:;
        while (!!(d)) {
            if (((int64)((*d).nameid) == (int64)15)) {
                if (!!(first)) {
                    first = (int64)0;
                    a = (b = (int64)((*d).index));
                }
                else {
                    a = msysc_m_imin(a,(int64)((*d).index));
                    b = msysc_m_imax(b,(int64)((*d).index));
                }
            }
            d = (*d).nextdef;
L1594:;
        }
L1595:;
        var_decls_ttlower[(m)] = (int32)(a);
        var_decls_ttlength[(m)] = (int32)(((b - a) + (int64)1));
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)23)) {
        qc_pcllib_converttype((int64)(var_decls_tttarget[(m)]));
        var_decls_ttsize[(m)] = (int32)8;
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)32)) {
        nofields = (int64)0;
        d = (*var_decls_ttnamedef[(m)]).deflist;
L1596:;
        while (!!(d)) {
            if (((int64)((*d).nameid) == (int64)13)) {
                if (((int64)(var_decls_ttbasetype[((int64)((*d).mode))]) > (int64)35)) {
                    printf("%s\n",(char*)(var_decls_ttname[(m)]));
                    qc_support_gerror((byte*)"Packtype in record",(struct var_decls_unitrec *)(0));
                }
                if ((nofields >= (int64)256)) {
                    qc_support_gerror((byte*)"CT: too many fields",(struct var_decls_unitrec *)(0));
                }
                fieldlist[(++nofields)-1] = d;
                qc_pcllib_converttype((int64)((*d).mode));
            }
            d = (*d).nextdef;
L1597:;
        }
L1598:;
        qc_pcllib_nallfields = (qc_pcllib_nfields = (int64)0);
        recordsize = qc_pcllib_scanrecord(&fieldlist,nofields);
        var_decls_ttlower[(m)] = (int32)1;
        var_decls_ttsize[(m)] = (int32)(recordsize);
        var_decls_ttlength[(m)] = (int32)(qc_pcllib_nfields);
    } else if (((int64)(var_decls_ttbasetype[(m)])==(int64)33)) {
        nofields = (int64)0;
        d = (*var_decls_ttnamedef[(m)]).deflist;
L1599:;
        while (!!(d)) {
            if (((int64)((*d).nameid) == (int64)13)) {
                if (((int64)(var_decls_ttbasetype[(m)]) == (int64)33)) {
                    if (((int64)(var_decls_ttbasetype[((int64)((*d).mode))])==(int64)35)) {
                        printf("%s\n",(char*)(var_decls_ttname[(m)]));
                        qc_support_gerror((byte*)"Var in struct",(struct var_decls_unitrec *)(0));
                    } else if (((int64)(var_decls_ttbasetype[((int64)((*d).mode))])==(int64)50) || ((int64)(var_decls_ttbasetype[((int64)((*d).mode))])==(int64)51) || ((int64)(var_decls_ttbasetype[((int64)((*d).mode))])==(int64)52)) {
                        printf("%s\n",(char*)(var_decls_ttname[(m)]));
                        qc_support_gerror((byte*)"Intm/etc in struct",(struct var_decls_unitrec *)(0));
                    }
                }
                else {
                    if (((int64)(var_decls_ttbasetype[((int64)((*d).mode))]) != (int64)35)) {
                        printf("%s\n",(char*)(var_decls_ttname[(m)]));
                        qc_support_gerror((byte*)"Packtype in record",(struct var_decls_unitrec *)(0));
                    }
                }
                if ((nofields >= (int64)256)) {
                    qc_support_gerror((byte*)"CT: too many fields",(struct var_decls_unitrec *)(0));
                }
                fieldlist[(++nofields)-1] = d;
                qc_pcllib_converttype((int64)((*d).mode));
            }
            d = (*d).nextdef;
L1600:;
        }
L1601:;
        qc_pcllib_nallfields = (qc_pcllib_nfields = (int64)0);
        index = nofields;
        recordsize = qc_pcllib_scanstruct((int64)1,&fieldlist,nofields,&index,(int64)0,(int64)2);
        d = var_decls_ttnamedef[(m)];
        if (((int64)((*d).attribs.ax_align)==(int64)2)) {
L1602:;
            while (!!((recordsize & (int64)1))) {
                ++recordsize;
L1603:;
            }
L1604:;
        } else if (((int64)((*d).attribs.ax_align)==(int64)4)) {
L1605:;
            while (!!((recordsize & (int64)3))) {
                ++recordsize;
L1606:;
            }
L1607:;
        } else if (((int64)((*d).attribs.ax_align)==(int64)8)) {
L1608:;
            while (!!((recordsize & (int64)7))) {
                ++recordsize;
L1609:;
            }
L1610:;
        }
        var_decls_ttlower[(m)] = (int32)1;
        var_decls_ttsize[(m)] = (int32)(recordsize);
        var_decls_ttlength[(m)] = (int32)(qc_pcllib_nfields);
    }
    else {
    }
}

static int64 qc_pcllib_scanstruct(int64 fstruct,struct var_decls_strec * (*flist)[],int64 flistlen,int64 * index,int64 nextoffset,int64 countmode) {
    int64 startoffset;
    int64 maxsize;
    int64 exitflag;
    int64 size;
    int64 star;
    int64 alignment;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    struct var_decls_uflagsrec flags;
    startoffset = nextoffset;
    maxsize = (int64)0;
    exitflag = (int64)0;
L1611:;
    while ((!(!!(exitflag)) && ((*index) >= (int64)1))) {
        d = (*flist)[((*index))-1];
        flags = (*d).uflags;
        if (((int64)(flags.codes[((int64)1)-1])==(int64)83)) {
            qc_pcllib_shiftflagsleft(&(*d).uflags);
            size = qc_pcllib_scanstruct((int64)1,flist,flistlen,index,nextoffset,countmode);
        } else if (((int64)(flags.codes[((int64)1)-1])==(int64)85)) {
            qc_pcllib_shiftflagsleft(&(*d).uflags);
            size = qc_pcllib_scanstruct((int64)0,flist,flistlen,index,nextoffset,(!!(countmode)?(int64)1:(int64)0));
        } else if (((int64)(flags.codes[((int64)1)-1])==(int64)69)) {
            qc_pcllib_shiftflagsleft(&(*d).uflags);
            if (((int64)((*d).uflags.ulength) == (int64)0)) {
                --(*index);
            }
            exitflag = (int64)1;
            size = (int64)0;
        } else if (((int64)(flags.codes[((int64)1)-1])==(int64)42)) {
            qc_pcllib_shiftflagsleft(&(*d).uflags);
            star = (int64)1;
            goto L1614;
        }
        else {
            star = (int64)0;
//dofield:
L1614:;
            if (!!((*d).attribs.ax_at)            ) {
                e = (*d).equiv;
                (*d).offset = (*e).offset;
                size = (int64)0;
            }
            else if (!!((*d).attribs.ax_equals)) {
                qc_support_gerror((byte*)"Can't init a field",(struct var_decls_unitrec *)(0));
            }
            else {
                size = (int64)(var_decls_ttsize[((int64)((*d).mode))]);
                alignment = (int64)((*d).attribs.ax_align);
                if ((alignment == (int64)255)) {
                    alignment = (size>(int64)8?size:(int64)8);
                }
                if ((alignment==(int64)2)) {
L1615:;
                    while (!!((nextoffset & (int64)1))) {
                        ++nextoffset;
L1616:;
                    }
L1617:;
                } else if ((alignment==(int64)4)) {
L1618:;
                    while (!!((nextoffset & (int64)3))) {
                        ++nextoffset;
L1619:;
                    }
L1620:;
                } else if ((alignment==(int64)8)) {
L1621:;
                    while (!!((nextoffset & (int64)7))) {
                        ++nextoffset;
L1622:;
                    }
L1623:;
                }
                (*d).offset = (int32)(nextoffset);
                if (!!(countmode)) {
                    ++qc_pcllib_nfields;
                }
            }
            if (!(!!(star))) {
                --(*index);
            }
            ++qc_pcllib_nallfields;
        }
        if (!!(fstruct)) {
            nextoffset += size;
        }
        else {
            maxsize = (maxsize>size?maxsize:size);
            countmode = (int64)0;
        }
L1612:;
    }
L1613:;
    return (!!(fstruct)?(nextoffset - startoffset):maxsize);
}

static int64 qc_pcllib_scanrecord(struct var_decls_strec * (*flist)[],int64 flistlen) {
    int64 size;
    int64 index;
    int64 nextoffset;
    struct var_decls_strec *  d;
    struct var_decls_strec *  e;
    nextoffset = (int64)0;
L1624:;
    for (index=flistlen;index>=(int64)1;--index) {
L1625:;
        d = (*flist)[(index)-1];
        if (!!((*d).attribs.ax_at)        ) {
            e = (*d).equiv;
            (*d).offset = (*e).offset;
            size = (int64)0;
        }
        else if (!!((*d).attribs.ax_equals)) {
            qc_support_gerror((byte*)"Can't init a field",(struct var_decls_unitrec *)(0));
        }
        else {
            size = (int64)16;
            (*d).offset = (int32)(nextoffset);
            ++qc_pcllib_nfields;
        }
        ++qc_pcllib_nallfields;
        nextoffset += size;
L1626:;
    }
L1627:;
    return nextoffset;
}

static void qc_pcllib_shiftflagsleft(struct var_decls_uflagsrec * flags) {
    int64 i;
    int64 av_1;
    if (!!((*flags).ulength)) {
L1628:;
        for (i=(int64)1;i<=((int64)((*flags).ulength) - (int64)1);++i) {
L1629:;
            (*flags).codes[(i)-1] = (*flags).codes[((i + (int64)1))-1];
L1630:;
        }
L1631:;
        (*flags).codes[((int64)((*flags).ulength))-1] = (uint8)0u;
        --(*flags).ulength;
    }
}

static void qc_pcllib_gstest(int64 id) {
    int64 i;
    printf("%s %lld\n",(char*)((byte*)"ID="),(int64)id);
L1632:;
    for (i=(int64)1;i<=(int64)10000;++i) {
L1633:;
        mlib_gs_strln(qc_pcllib_pcl,(byte*)"bartsimpson");
L1634:;
    }
L1635:;
}

int64 qc_pcllib_addstringtotable(byte * s,int64 length) {
    int64 i;
    if ((var_decls_nstrings >= (int64)5000)) {
        qc_support_gerror((byte*)"Too many strings",(struct var_decls_unitrec *)(0));
    }
    ++var_decls_nstrings;
    (*var_decls_stringtable)[(var_decls_nstrings)-1] = s;
    (*var_decls_stringlentable)[(var_decls_nstrings)-1] = length;
    return var_decls_nstrings;
}

byte * q_libs_getintlib(byte * name) {
    int64 i;
    byte *  source;
    byte *  newsource;
    return (byte *)(0);
}


/* ********** End of C Code ********** */
